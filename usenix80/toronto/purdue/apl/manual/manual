








             A Beginner's Guide to Unix APL\11


                       John D. Bruner
                        A. P. Reeves







     This manual is intended to serve as a guide to the  use
of Unix APL.  It is not intended to be a reference manual on
the APL language; rather, it describes the local implementa-
tion of APL.

_W_h_a_t'_s _a _W_o_r_k_s_p_a_c_e?

     One of the most important concepts  pertaining  to  the
use  of  APL is the idea of a "workspace".  Simply stated, a
workspace is a collection  of  information  (including  both
functions  and  data)  to  be processed by APL.  Programmers
accustomed to compiler languages such as  FORTRAN  may  find
this  concept  somewhat  unusual,  so let's explore it a bit
further.

     Perhaps the best way to start describing a workspace is
to  define another term -- "file".  A file is also a collec-
tion of information.  On Unix, however, a file _u_s_u_a_l_l_y  con-
tains only one type of information; e.g. a C program or data
for a FORTRAN program.  A standard program, perhaps  written
in  FORTRAN,  may  access  data in the file by "opening" the
file and reading it.  The file may also be "created",  writ-
ten, or removed.

     APL differs from FORTRAN in that while it  is  running,
all of the information it needs is internal to itself.  That
is, all of the variables  APL  functions  will  require  are
already available.  As functions are written, they are added
to this internal storehouse of information.   As  the  func-
tions  are  run, and data is generated, the data is added to
this internal storehouse.  APL provides the facility to save
part  or  all  of  this  information  in  a  special  format
("workspace" or "load" format) in a Unix  file.   This  file
can  only  be  used by APL in later runs (it should not, for
instance, be printed on the line-printer).

     In addition, APL is capable of working with  more  con-
ventional  files,  which  are in character format and can be
edited and displayed outside of APL.   These  files  are  in



                     February 17, 1979





                           - 2 -


"ASCII" format.

_G_e_t_t_i_n_g _o_n _U_n_i_x

     If you do not have a Unix  account,  you  can  get  one
either  through your EE class or from Mrs. Murray if you are
an EE student or are taking an EE class.  You will be  given
a  "login  name"  and also a "password".  Your login name is
your user identifier.  Find an unused Unix terminal and turn
it  on.  Hold down the Control key and type a D.  The termi-
nal should erase the screen, print a message identifying the
Unix system, and ask:

Login:

Type your "login name", followed by a carriage return.   The
system will respond with:

Password:

Type your password.  Unix will not display what you type  so
someone  cannot  look over your shoulder at the terminal and
steal your account.

     When Unix is satisfied that  you  can  login,  it  will
print  the  "message  of the day", which is comprised of any
important news about the system, and then it will type out a
percent sign:

%

This is the standard Unix prompt, which  means  that  it  is
waiting for you to enter a command.

_H_o_w _d_o _I _s_t_a_r_t _A_P_L?

     The answer in this case is extremely simple -- type the
command:

% apl

APL will print a title identifying itself and  the  date  of
the  current  version,  will print "clear ws", and will then
tab 8 spaces to the right.   This  is  APL's  prompt,  which
means  that  it  is  expecting  you  to type something.  The
"clear ws" message means that you do not  have  anything  in
your   workspace   (no  functions  or  variables  have  been
defined).

     Equally important to getting into APL is  getting  out.
To exit APL, type a Control-D (hold down the Control key and
press a D).  You will once again get the percent-sign  as  a
prompt.




                     February 17, 1979





                           - 3 -


     Here's the point at which  running  Unix  APL  can  get
somewhat  confusing.   Unix  APL  at  Purdue  was originally
designed to run on terminals which do not have the  standard
APL  character  set.  These terminals will be referred to as
"ASCII terminals".  During the summer of 1978, some  of  the
Unix  terminals  were  modified so that they would print out
standard APL symbols.   These  APL  terminals  can  be  dis-
tinguished  by  a  small switch on the left side.  When this
switch is in the upward position, the terminal is a  regular
ASCII terminal.  When the switch is flipped down, the termi-
nal uses the APL character set.

     It is necessary for you to tell APL  when  you  run  it
what type of terminal you are using.  If you are running APL
on an ASCII terminal, you must use the default ASCII charac-
ter  set.   In  this  case, you run APL exactly as described
previously:

% apl

Also, if you are using a modified terminal, but you wish  to
run  APL  in ASCII mode, you may leave the switch up and run
APL the same way you would from an ASCII terminal.

     If you wish to run APL using a modified terminal in APL
mode (switch set down), you must type the command:

% apl -m

This will inform APL that you want it  to  process  the  APL
character set rather than the ASCII character set.  When APL
starts running, it will print a reminder on your  screen  to
switch the terminal to APL mode.

     Unfortunately, there is still a problem.  On  Unix,  if
you  want to correct a mis-typed keystroke, you type what is
called an "erase character".  This character is, by default,
a  Control-H  (hold  Control,  press H).  The problem arises
from the fact that APL uses "overstrike" characters  --  one
character,  followed  by  a  backspace,  followed by another
character.  If you are running APL at an APL terminal,  this
is no problem, because you generate overstrike characters by
typing the first character, typing the backspace  character,
and  then  typing the second character.  (The character that
results from the overstrike will be printed on your screen.)
However,  on an ASCII terminal, the only way to get an over-
strike is to type the first character, a Control-H, and then
the  second  character.   (On ASCII terminals, you will only
see the second character when you finish this sequence.)

     As you probably noticed, this means that on ASCII  ter-
minals, APL wants the Control-H to be a valid character, but
Unix considers it to be a special character, used  to  erase
mistakes.   The  solution  is  to  tell  Unix to use another



                     February 17, 1979





                           - 4 -


character as an erase character.  This is done by the "stty"
command.   The  underline  character is not required in Unix
APL, so you may use the command:

% stty erase _

to make it your erase character.  (You must type  this  com-
mand in response to the percent sign, _n_o_t inside APL.) After
you type this command, you may use the Control-H as a  back-
space  for  overstrikes  and may erase mistakes by typing an
underline.

_W_h_a_t _a_r_e _a_l_l _o_f _t_h_o_s_e _f_u_n_n_y _c_h_a_r_a_c_t_e_r_s?

     Part of the power of APL comes from the  fact  that  it
has  so  many  primitive  operators,  usually referred to as
"functions" in APL literature.  That is, many  common  func-
tions, from addition and subtraction, to trigonometric func-
tions, and to matrix operations, can  be  specified  with  a
couple  of  characters.   As a result, the character set for
APL does look a little strange.  Basically,  there  are  two
major  types  of primitive functions.  The most common func-
tions,  such  as  the  arithmetic   operators,   etc.,   are
represented  by a single character.  For example, the symbol
"+" represents addition.  Because there  are  only  so  many
keys  on the keyboard, the other operators in APL, for exam-
ple matrix inversion, are  called  "overstrike"  characters.
As we discussed in the last section, an overstrike character
is treated as one symbol by APL  but  requires  three  keys-
trokes on the terminal.  One common example is the "comment"
symbol.  This symbol is composed of the three characters:  C
<backspace>  J.   (This  is  also the same thing as J <back-
space> C).

     On an ASCII terminal, an overstrike character is  typed
by typing:

<first char> <control-H> <second-char>

As we discussed earlier, if you use an  ASCII  terminal  you
must have previously typed the command:

% stty erase X

(where "X" is some character such as "_") in order  for  the
control-H to work properly in APL.  Note that because of the
way the ASCII terminals work, when you type the second char-
acter  on  top  of the first, the terminal will only display
the second character.

     On an APL terminal, you may type an overstrike  charac-
ter in one of two ways.  You may type:

<first character> <control-H> <second character>



                     February 17, 1979





                           - 5 -


just as you would on an ASCII terminal.  As  with  an  ASCII
terminal, you must have typed an "stty" command earlier, and
when you type the control-H and then type the second charac-
ter  on  top  of  the first one, only the second one will be
displayed.

     If you are using an APL terminal, there is another  way
to  type overstrikes which you may find more convenient.  In
APL mode, the key which is labelled with "~" and "^"  (upper
right  end  of  keyboard)  is recognized by APL as a special
backspace key.  You may use this backspace  key  instead  of
the control-H.  Thus, the sequence is:

<first character> <backspace key> <second character>

There are two  advantages  to  using  this  key  instead  of
control-H.   The  first advantage is that you do not have to
type an "stty" command, and you can  use  control-H  as  the
Unix erase character to correct typing mistakes.  The second
advantage is that when you type the backspace and then  type
the  second  character,  the  teminal will display a special
character representing the two characters you typed  on  top
of  each  other.   (If  you try to type an illegal APL over-
strike symbol, you will get  a  "beep"  at  your  terminal).
This  way,  you can see both characters you typed instead of
only the last one.

     It is not the purpose of  this  manual  to  attempt  to
describe  how  to  use APL's many primitive functions.  How-
ever, they are listed in Appendix A for reference purposes.

_A_P_L _S_y_s_t_e_m _C_o_m_m_a_n_d_s

     There are a number of "system commands" in APL.   These
commands  are  used to control your current session.  System
commands to APL may be typed at any time in APL when  it  is
prompting for input.  (They may not be included in APL func-
tions, however.) As stated previously, when APL  is  waiting
for input from the keyboard, it will type eight spaces.

     There are two types of  system  commands,  those  which
request  information  and those which specify action by APL.
All system commands are preceeded by  a  right  parenthesis.
As an example, the following is a typical entry into APL:

% apl
a p l \ 1 1
25 oct 1978

clear ws

     _

(the underline character "_" represents the "cursor" on  the



                     February 17, 1979





                           - 6 -


terminal).  The ")lib" command could then be typed:

     )lib


     Commands which specify action are composed of the  com-
mand  name  and some other value.  For instance, to edit the
function "fn", the command would be:

     )editf fn


     Before we start examining the  available  commands  and
what  they  can do for us, a final warning is necessary: the
command and the left parenthesis must be together:

     ) editf fn

is invalid and will give an error message.

_A_v_a_i_l_a_b_l_e _C_o_m_m_a_n_d_s

     Most of the APL system commands are described here.   A
few   commands  are  strongly  oriented  toward  APL  system
development  and  not  toward  general  use;  they  are  not
included.    Also  omitted  are  commands  which  are  being
developed but do not operate properly.

)clear        This command is used to completely  initialize
              an  APL  workspace.  As we saw before, usually
              when APL is started,  it  will  print:  "clear
              ws".  This means that no internal variables or
              functions  are  defined.   Sometimes,  it   is
              desirable  to completely erase everything, and
              this command serves that purpose.  To let  you
              know that everything has been erased, APL will
              output the message "clear ws".

)erase list   This command is handy when it is desirable  to
              get  rid of parts of a workspace without using
              ")clear" to eliminate all of it.   A  list  of
              function  and  variable  names  (separated  by
              spaces or tabs) may be specified.   The  named
              functions  and  variables will be deleted from
              the internal workspace.  The remainder of  the
              workspace will not be affected.

)save xxx     As we discussed previously, while APL is  run-
              ning it keeps all of the information about the
              current session in  an  internal  "workspace".
              This  command causes APL to write its internal
              workspace into a Unix file.  This  allows  the
              current session to be resumed at a later time.
              If the save is successful, APL will output the



                     February 17, 1979





                           - 7 -


              date and time.

)vsave xxx    This command allows parts of a workspace to be
              saved.   The functions and variables which are
              specified will be saved in a Unix file in  the
              same  format as produced by ")save".  APL will
              prompt for the  names  of  the  functions  and
              variables  to be saved.  When you have entered
              the last name, type a blank line  to  end  the
              save   operation.    The  workspace  you  have
              created  with  ")vsave"  may  be  loaded  with
              ")load" at some later time.  ")vsave" does not
              affect variables in the internal workspace.

)load xxx     This command is used to tell APL to  load  the
              Unix  file  "xxx"  into  APL  as  a workspace.
              After  the  file  is  loaded,  APL's  internal
              workspace  will be the save as it was when the
              workspace file was  saved  with  ")save",  and
              that  APL  session  may  be  resumed.   If the
              workspace  file  exists  and  is  successfully
              loaded,  APL will print the time and date that
              the workspace was last saved.

)copy xxx     This command instructs APL to locate the  Unix
              file  "xxx"  and  load  it  into  its internal
              workspace, similar  to  the  ")load"  command.
              The  difference between ")load" and ")copy" is
              that ")load" will replace the current internal
              workspace  with  the  one being read in, while
              ")copy" merges the current internal  workspace
              with  the  one  being  read in.  Functions and
              variables which are loaded from the file  take
              precedence over functions and variables of the
              same name existing  already  in  the  internal
              workspace.

)digits n     This command is used to  specify  to  APL  how
              many  digits are to be displayed when a number
              is printed in  floating-point  or  exponential
              format.   By default, APL will print 9 digits.
              You may specify any number between  1  and  19
              for the number of digits (n).  APL will answer
              with the number of digits it was using.

)origin n     This command is used to change  the  "origin".
              By  default, the origin is 1.  The "origin" is
              the starting index for arrays.   For  example,
              if  the origin is 0, then the first element of
              a 3-element array A is A[0].  If the origin is
              5,  the  first element will be A[5].  Although
              standard APL permits only 0 or 1 for the  ori-
              gin,  Unix  APL allows any integer value.  APL
              will answer with the origin it was using.



                     February 17, 1979





                           - 8 -


)width n      This command tells  APL  how  many  characters
              wide  your  terminal screen is.  This way, you
              can control how many  characters  are  printed
              per  line.   The  default  value  is  72.  APL
              answers this command with the previous  termi-
              nal width.

)off          This  command  does  the  same  thing  that  a
              control-D  does  -- it terminates the APL ses-
              sion.  The Unix command program will come back
              and print its prompt ("% ").

)continue     This  is  a  very  powerful  system   command.
              ")continue"  is  a  combination of the ")save"
              and  ")off"  commands.   First,  the  internal
              workspace is saved in a file named "continue",
              and then APL is terminated.  This command will
              be discussed in more detail later.

)fns          This command causes APL to list the  names  of
              all  of the functions which are defined in its
              internal workspace.

)vars         This command causes APL to list the  names  of
              all  of the variables which are defined in its
              internal workspace.

)lib          This command is similar to the "ls" command in
              Unix.   It causes APL to list the names of all
              of the Unix files in the current directory.

)editf xxx    This command is used to create and edit  func-
              tions.   If the function named "xxx" exists in
              the workspace, APL will write it into  a  tem-
              porary  Unix  file  and  then will execute the
              Unix editor "ed" to edit that function.   When
              you  have  finished  editing the file, and you
              exit the editor, APL will come back  and  will
              read the function in from the temporary file.

)edit xxx     This command is  similar  to  ")editf"  except
              that  "xxx" is a Unix filename.  APL will exe-
              cute the editor to edit the  Unix  file  named
              "xxx",  and  when the editing is complete, APL
              will read that file into the  workspace.   The
              difference  between  ")edit"  and  ")editf" is
              that  ")editf"  essentially  edits   functions
              directly  from  the  workspace,  while ")edit"
              gets the functions from the Unix directory.

)read xxx     At times it is desirable to  read  a  function
              which  is  stored  in  an  ASCII file into the
              internal  workspace.   The   ")read"   command
              causes  APL  to read the Unix file named "xxx"



                     February 17, 1979





                           - 9 -


              into the workspace as a function.   Note  that
              ")read"  and  ")load"  are _n_o_t the same thing.
              ")load" reads a complete  new  workspace  into
              APL   from   a  workspace-format  file,  while
              ")read" reads a function from  an  ASCII  file
              and adds it to the current workspace.

)write xxx    This command is the complement of ")read".  It
              takes  the  function  "xxx"  from  the current
              workspace and writes it to an ASCII file named
              "xxx".   This  is useful for writing functions
              which  will  be  ")read"  later   into   other
              workspaces  or  which  will  be printed on the
              line-printer.  Note ")write" and ")vsave"  are
              not  the  same  thing, for ")write" is used to
              write  a  function  into  an  ASCII  file  and
              ")vsave" saves a selected subset of the inter-
              nal workspace in a workspace-format file.

)drop list    This command performs  the  same  function  as
              "rm"  in  Unix.   The names of the files to be
              deleted should be separated by spaces or tabs.
              The  files may be APL workspaces, ASCII files,
              or any other type of Unix file.

)script xxx   This command  places  APL  into  a  "protocol"
              mode.   Following  this command, APL will copy
              all input from the terminal and output to  the
              terminal  to the file "xxx".  Thus, "xxx" is a
              complete transcript of the  APL  session.   To
              turn  off the script file, type ")script off".
              The protocol file which is produced will  con-
              tain all of the output produced by APL itself,
              but will, unfortunately, not contain any  out-
              put  produced  by another process (such as the
              editor).

)trace        This command turns on APL's  internal  "trace"
              mode.   When  tracing  is  turned on, APL will
              report the function name and  line  number  of
              each  line  in every function executed.  Thus,
              the flow of execution from the  start  to  the
              end of a run can be followed.

)untrace      This command turns off "trace" mode.

)si           This command is  useful  when  something  goes
              wrong.   When  an  error  occurs, the function
              that was executing is "suspended".  The  ")si"
              command  causes  APL to print a traceback from
              the suspended function.  This command will  be
              discussed in more detail later.





                     February 17, 1979





                           - 10 -


)reset        This command is used to reset the state  indi-
              cator.   All  suspended  functions  are reset.
              This command will be discussed in more  detail
              later.

)shell        This command is useful when it is  desired  to
              return  to  Unix temporarily without having to
              save the current internal workspace, exit APL,
              and   later   re-enter   APL  and  reload  the
              workspace.  ")shell" causes APL to execute the
              Unix  "shell"  program  (command interpreter).
              When you have finished with the shell,  logout
              and you will be returned to APL.

)list xxxx    This command causes APL to print out the func-
              tion  named  "xxxx".   This  is very handy for
              looking at a function without  having  to  use
              the  editor  --  especially  when an error has
              occurred and you want to look  at  a  function
              without  disturbing  the state indicator.  The
              state indicator and the use  of  this  command
              will be discussed in more detail later.

_A_u_t_o_m_a_t_i_c _W_o_r_k_s_p_a_c_e _L_o_a_d_i_n_g

     Unix APL has the nice feature that  you  can  automati-
cally load a workspace file into the internal workspace when
you start APL.  Instead of using the command:

% apl   <or>    % apl -m

and then loading the workspace you want with:

     )load workspace

you can say:

% apl workspace    <or>     % apl -m workspace

APL will be started, and will  automatically  look  for  and
load the file "workspace".

     As an additional convenience,  APL  will  automatically
load  a  file  named  "continue" if it exists.  Thus, if you
wish to run APL and use the file "continue" as your  initial
workspace, you need only type:

% apl   <or>    % apl -m


     You may recall from the discussion of  system  commands
that the ")continue" command creates a workspace named "con-
tinue".  Thus, Unix APL provides a convenient method of ter-
minating  an  APL  session,  and  restarting it later with a



                     February 17, 1979





                           - 11 -


minimum of effort.  You may, for instance, end your APL ses-
sion with:

     )continue

and then resume it later by merely starting APL with

% apl

(Recall that if you don't have a file named "continue",  APL
starts with "clear ws".)

_W_o_r_k_s_p_a_c_e _L_i_b_r_a_r_y

     When you specify a workspace to  be  loaded,  APL  will
first look in your directory.  If it finds the workspace, it
will load it.  If not, it will look in  the  library  direc-
tory:  /usr/lib/apl.   Thus, if you do not have a file named
"news" and you type:

% apl news

APL will be started, will see that you don't have  a  "news"
file, and will print:

[Using /usr/lib/apl/news]

Equivalently, if you are in APL and you type:

     )load news      <or>    )copy news

you will get the library file if you don't have a file named
"news".   If  the  workspace  you  specify does not exist in
either your directory or in /usr/lib/apl, you  will  get  an
error message.

_T_h_e _S_t_a_t_e _I_n_d_i_c_a_t_o_r

     APL is a recursive language which supports local  vari-
ables.   Therefore,  it  is  essential that it maintain some
sort of information concerning its current state  of  execu-
tion,  local  variables,  and  status of functions.  Part of
this information -- the current status of active  functions,
is  called  the  "state  indicator".   Each  time a function
begins execution, APL keeps track of the current line number
in  that  function.  When the current function calls another
function, the line number where  the  request  was  made  is
recorded in the state indicator.

     When a function terminates abnormally, it is said to be
"suspended".   This  means  that  APL stops execution of the
function, but retains  all  information  about  its  current
state  of  execution.   In  some  cases,  the problem can be
corrected and the function  restarted  where  it  left  off.



                     February 17, 1979





                           - 12 -


This  discussion  will  not  include that technique.  In any
event, when the function is  suspended,  APL  will  print  a
traceback automatically, perhaps such as:


used before set
at      fn3[5]
from    fn2[12]
from    main[4]


In this case, the error (undefined variable) occurred in the
function  "fn3" at line 5.  "fn3" was called by the function
"fn2" at line 12, which in turn was called by  the  function
"main" at line 14.

     The ")si" command produces a  similar  traceback.   For
the above example, the traceback could be:


fn3[5]  *
fn2[12]
main[4]


This shows that the function  "fn3"  was  suspended  due  to
error,  and  that "fn2" and "main" are waiting for "fn3" and
"fn2", respectively.

     When an error occurs and a function is  suspended,  all
of  that  function's  variables are accessible from the key-
board.  Thus, you can examine the current variables to  help
detemine the problem.  As stated above, in some cases it may
be possible to change some variables and resume execution of
the  suspended  function.   However,  in  general, after you
examine the variables you will probably want to restart from
the  beginning.  In order to do this, type the ")reset" com-
mand.  This causes APL to clear the state indicator,  reset-
ting suspended functions and releasing local variables.

     If you do not use ")reset", you will find  two  things.
First,  if  you  get  another error, the state indicator may
look like:


fn3[3]  *
fn2[12]
main[4]
fn3[5]  *
fn2[12]
main[4]


This shows that "fn3" was suspended due to an error at  line



                     February 17, 1979





                           - 13 -


3,  and  it  traces  execution  back to the start of "main".
Then, it shows that in a previous run, "fn3"  was  suspended
due  to  an error at line 5, and it traces execution back to
the start of "main".  You can still use the ")reset" command
to get back to a clear state indicator.

     The other effect which you will notice if  you  do  not
")reset"  the  state indicator is that you will be unable to
edit some functions.  If a function is suspended (it appears
in the state indicator), it cannot be changed, because it is
possible that the error condition may be corrected and  exe-
cution  resumed.   Therefore,  if you try to edit a function
which appears in the state indicator, you will get the error
message:

si damage -- type ')reset'

To  edit  the  function,  clear  the  state  indicator  with
")reset" first, and then you may proceeed with an ")edit" or
")editf" command.

     A useful technique for finding errors is to look at the
function  which  "blew  up" and try typing in the line which
failed, a little bit at a time.  This  often  helps  isolate
the  problem.   Generally,  you  want  to do this before the
state indicator is ")reset" so that  the  state  of  APL  is
exactly  the  same  as  it  was when the error was detected.
Since you cannot run the editor to list the function without
typing  ")reset",  you will probably want to use the ")list"
command to look at the bad function.

     As an example, suppose your  "friend"  Chris  (male  or
female,  take  your  pick) gave you the following program to
compute the reciprocal of the numbers from 1 to x:

        r { recip x
[1]       r { % Ix

You are using origin 0, and your attempt to run the function
yields the following:

        recip 10
recip domain
at      recip[1]

It looks like Chris gave you a bum steer.  You decide to try
to  debug the function.  You can't use the editor to look at
it with ")editf" unless you type ")reset" first.  You  don't
want  to  ")reset",  because that would take you back to the
beginning and you would lose  any  temporary  variables  (in
this  case,  just  "x").  Thus, you can use the ")list" com-
mand:





                     February 17, 1979





                           - 14 -


        )list recip

        y { recip x
[1]       y { %Ix

Now, you can experiment with the function by typing the com-
mands yourself:

        x
10

        Ix
0 1 2 3 4 5 6 7 8 9

At this point, you immediately spot the trouble --  APL  was
trying  to  take  the reciprocal of 0.  The function "recip"
was written assuming that the origin was 1,  but  Chris  did
not tell you and you were using 0 instead.  Thus, you merely
say:

        )reset

(now that you've found the problem, you want to reset APL to
clear the state indicator), and

        )origin 1
was 0

        recip
 1.00000000e+00 5.00000000e-01 3.33333333e-01 2.50000000e-01
                2.00000000e-01 1.66666667e-01 1.42857143e-01
                1.25000000e-01 1.11111111e-01 1.00000000e-01


_E_d_i_t_i_n_g _F_u_n_c_t_i_o_n_s

     Editing functions is relatively straightforward, except
as  noted  above  that suspended functions cannot be editing
without first typing ")reset".  However, there is one  other
problem which presents itself that should be discussed.

     When using ")editf", APL  writes  the  function  to  be
edited  out of its internal workspace into a temporary ASCII
file, and then it calls the Unix editor to edit  that  file.
When  editing  is complete, APL reads the file back in.  The
problem that occasionally occurs is that  APL  examines  the
first  line  of the file in order to determine what the name
of the function is.  If a syntax error is detected in line 0
of  the  file,  APL  will  _n_o_t read it in!  As a result, the
function no longer is defined in the workspace, and the only
other  copy  exists  in a temporary file.  Thus, in order to
save you a lot of work retyping, APL will automatically copy
the  temporary  file  into a file called "apl_badfn" when it
detects a syntax error while reading.



                     February 17, 1979





                           - 15 -


     An example is probably called  for  at  this  point  to
clear  the  mud  somewhat.  The function "xyz" is defined in
the workspace, and the following occurs:

        )editf xyz
XED V5.45       [ 10/17 21:37 ]
*** Use at your own risk ***
5 lines
>0
[ 0 ]   xyz
>c
[ 0 ]   xyz+1
[ 1 ]   .
>w
>q
xyz+1
   ^
syntax error
Function saved in apl_badfn

As the error message indicates, "xyz+1" is  illegal  in  the
function  header, so the bad function was copied to the file
"apl_badfn".  To get it back, you could say:

        )editf xyz
        [new fn]
XED V5.45       [ 10/17 21:37 ]
*** Use at your own risk ***
0 lines
>r apl_badfn
>0c
[ 0 ]   xyz
>w
>q

and the problem would be corrected.

     If you use ")edit" instead of ")editf",  APL  will  not
worry  about  saving the function in "apl_badfn" because you
were editing from a Unix file rather than from the  internal
workspace.

_Q_u_a_d _F_u_n_c_t_i_o_n_s

     Quad functions are special operators in APL  that  per-
form  tasks  which  are  closer to the system level, but are
accessible within APL functins.  There  are  many  available
quad  functions  in  Unix  APL, but only two are probably of
interest to you  at  this  time.   The  interested  user  is
referred to Appendix B for a complete list.

Lrun xxx      This function can be used to  execute  a  Unix
              process  from  inside  an  APL  function.  The
              variable "xxx" should  be  a  character  array



                     February 17, 1979





                           - 16 -


              containing  the  command to be executed by the
              Unix shell (command program).  For example, to
              run  the  "who"  program, the expression might
              be:

                            Lrun 'who'

                            <or, using an array>

                            x { 'who'
                            Lrun x

              Note that any output generated by the  program
              run  by "Lrun" is _n_o_t written to a script file
              if ")script" was used.

Lcr xxx       This quad function  is  a  standard  APL  quad
              function.   The  argument  "xxx"  should  be a
              character vector containing the name of an APL
              function   which   exists   in   the  internal
              workspace.   "Lcr"  will  return  a  character
              array  containing  the  function definition in
              ASCII.  This provides a very convenient way to
              get the listing of an APL function.  For exam-
              ple, if you want to define the array  "fnlist"
              to  be the function definition of the function
              "xyz", you can say:

                            fnlist { Lcr 'xyz'

              or, equivalently,

                            fnname { 'xyz'
                            fnlist { Lcr fnname

              Another possible use of "Lcr"  is  to  list  a
              function on the terminal without having to use
              ")editf".  (As we discussed earlier,  when  an
              error occurs you cannot edit a suspended func-
              tion  without  using   ")reset"   first,   and
              ")reset"  gets  rid  of  the  current state of
              APL.) However, the ")list" system  command  is
              far  more  efficient  for  this purpose and is
              therefore strongly recommended.

_I-_B_e_a_m _F_u_n_c_t_i_o_n_s

     The I-beam function in Unix APL is a method of  obtain-
ing  system parameters.  The available I-beams are listed in
Appendix C for the interested user; they are  not  generally
required for the average APL session.






                     February 17, 1979





                           - 17 -


_W_h_a_t _a_r_e _t_h_o_s_e _f_u_n_n_y _m_e_s_s_a_g_e_s?

     You probably figured that at some point in this  manual
you'd  see  something  about error messages.  Unfortunately,
errors do occur, and some of APL's error messages can really
throw  you.   In addition, some of APL's status messages can
seem cryptic at times.  Thus, in this section we'll  explore
some of the more common status and error messages.

     First, some of APL's less obvious and relatively common
abbreviations are:

        asgn    assignment
        cat     catenation
        crc     circle
        dfmt    dyadic format
        dibm    dyadic i-beam
        exec    execute
        fn      function
        imm     immediate
        iprod   inner product
        mdom    monadic domino
        menc    monadic encode
        miot    monadic iota
        oprod   outer product
        red     reduction
        var     variable


     There are three major types of error messages which may
be  generated as a result of an APL session.  The error mes-
sage may be the result of a fatal error  in  APL  which  has
caused  APL to abort, the result of some internal problem in
APL, or an error produced by incorrect use of APL.  We  will
examine them in this order.

_F_a_t_a_l _E_r_r_o_r _M_e_s_s_a_g_e_s

     In most cases, when APL detects that  some  irreparable
damage  has been done, it will print an error message of the
form:

Fatal system error: message

where the "message" represents a type of  Unix  termination.
The  most  common  one probably is "segmentation violation",
which means that APL needed too much memory for its internal
workspace  and  was  aborted in its attempt to get more than
permitted in Unix.  Other possible messages include:








                     February 17, 1979





                           - 18 -


        Quit
        illegal instruction
        trace trap
        EMT trap
        bus error
        bad sys call
        write no pipe

APL terminates itself when the error is detected,  and  does
not produce a core file in your directory.

     In some cases, APL is unable  to  print  a  termination
message, and the system aborts it.  This usually will result
in a message such as:

Memory fault -- core dumped

and the operating system will produce a file named "core" in
your  directory.   This file is probably useless and you can
delete it with:

% rm core

_N_o_n-_f_a_t_a_l _E_r_r_o_r _M_e_s_s_a_g_e_s

     Usually, APL can  detect  serious  errors  before  they
become fatal.  When this occurs, it will issue an error mes-
sage but will not terminate.  You can then take  appropriate
action.   For  instance, usually APL will not attempt to get
more internal workspace memory if it already has the maximum
permissible amount.  It will then inform you:

workspace exceeded

Other possible messages of this nature are:

        directory botch
        save botch
        elid botch
        stack overflow
        pop botch

In general, if an error message such  as  this  occurs,  you
should save your internal workspace in a different file than
you started from (in case it may have  been  "corrupted"  or
otherwise damaged by the error in APL), and then should exit
APL and restart.  You can then determine whether or not any-
thing happened to your workspace, and can recover any losses
from the original workspace file.  These type of errors gen-
erally  occur  as  the result of some other error, such as a
function which calls itself  indefinitely  or  declaring  an
array which is too large for the workspace.

     By far, majority of error messages produced by APL  are



                     February 17, 1979





                           - 19 -


not  fatal or serious, but simply indicate some error in the
definition or execution of a function.   These  errors  fall
into some common types:

conformability      The variable which you are passing to  a
                    function or operator does not "conform".
                    That is,.  it is not  the  proper  shape
                    (e.g.  array  has  the  wrong  number of
                    dimensions or a scalar is  used  instead
                    of  an  array, etc.) For example, trying
                    to add a 2X2 array to a 2-element vector
                    will produce this error.

botch               A "botch" can occur for several reasons.
                    Attempting  to  read  from  non-existant
                    element of an array will produce a "get-
                    dat   botch".    (Storing  into  a  non-
                    existant variable or array element  will
                    produce a "putdat botch".)

domain              A domain error means  that  somehow  the
                    variable  passed to a function or opera-
                    tor  cannot  be  used.    For   example,
                    attempting  to  take  the logarithm of a
                    negative  number  will  produce  a  "log
                    domain" error message.

index               A bad  index  was  specified.   A  quick
                    example  of  this  error is to have ori-
                    gin=1  and  attempt  to   access   A[0].
                    Attempting  to  concatenate  two  arrays
                    along a non-existant dimension will pro-
                    duce a "cat index" error message.

syntax              This error message is probably painfully
                    familiar  -- it indicates that the indi-
                    cated APL expression was  not  syntacti-
                    cally  correct.   If  this  error occurs
                    during the processing of a function, the
                    traceback   will  show  which  line  was
                    incorrect.

rank                This type of error  indicates  that  the
                    argument  to an operator or function has
                    the wrong number of dimensions.   As  an
                    example,  if  you  attempt to declare an
                    array with more than 8  dimensions,  you
                    will get a "max rank" error message.

     Some other common error messages do not fall  into  any
of the above classes.  These include:






                     February 17, 1979





                           - 20 -


used before set     This message means that a  variable  was
                    referenced   which   had  not  yet  been
                    defined.  An easy example:

                                    y { 2
                                    z { x + y
                            used before set


fn arg undefined    This message  means  the  same  this  as
                    "used  before set" except it occurs when
                    one of the arguments to  a  function  is
                    not  defined when the function is refer-
                    enced.

no fn result        This error occurs  when  an  attempt  is
                    made  to  use  the  returned  value of a
                    function which doesn't return  a  value.
                    As  an  example,  if  the function "xyz"
                    returns no  value,  then  the  following
                    sequence will result in an error:

                                    z { xyz
                            no fn result


si damage           This error message,  discussed  earlier,
                    usually  occurs  when an attempt is made
                    to edit a function  which  is  suspended
                    due to an error.  Type ")reset" and then
                    you may edit the function.

can't open file     This error message occurs  when  a  non-
                    existant  file  is  used  for a ")load",
                    ")read", ")save", etc.

_A "_s_t_a_r_t_u_p" _f_u_n_c_t_i_o_n _i_n _A_P_L?

     APL has a startup facility which allows automatic  exe-
cution  of an APL expression when a workspace is loaded.  If
you define the variable "Llx" to be some APL expression  and
then   save   the  workspace,  when  you  next  ")load"  the
workspace, APL will automatically read  and  execute  "Llx".
For  example,  if  you have the function "hello" which looks
like this:

                hello
        [1]     'hi there, my friend'
        [2]     'welcome to apl"

and you want APL  to  perform  "hello"  when  you  load  the
workspace file "hi", you can say:





                     February 17, 1979





                           - 21 -


        Llx { 'hello'
        )save hi
  14.59.31 10/26/78
        )off

Then, if you run APL with:

% apl hi

you will get:

a p l \ 1 1
25 oct 1978

  14.59.31 10/26/78 loaded hi

hi there, my friend
welcome to apl

        _


_U_n_i_x _A_P_L\_1_1 _L_i_m_i_t_a_t_i_o_n_s

     Unix APL does  have  some  limitations.   Of  principal
interest  to  the new APL user is that it is not possible to
take more from an array than already  exists,  a  capability
which  standard  APL  does  permit.  Other limitations which
probably will not affect new users include the lack  of  the
laminate and dyadic format operators, and lack of quad vari-
ables (except for Llx).

     The other major  limitation  for  Unix  APL  is  space.
Despite  efforts to use as much memory as Unix permits, only
about 5000 numeric values may be stored in an APL workspace.
In order to permit workspaces containing more data, there is
a second version of Unix APL called "apl2".   APL2  is  used
exactly  the  same way as APL -- the only difference is that
it uses single precision floating-point instead  of  double-
precision.   As  a  result, some precision is lost, but APL2
allows twice as many workspace items as APL.  Although  APL2
and  APL  workspaces  are in different formats, APL and APL2
will convert each other's workspace files  they  are  loaded
with  ")load"  or  merged with ")copy", so workspaces may be
used interchangably.  In all other respects,  the  operation
of APL2 is identical to the operation of APL.

_C_o_n_c_l_u_s_i_o_n

     Well, that wraps up this manual.  Reference information
about APL is found in the on-line help system.  Type:

% help apl




                     February 17, 1979





                           - 22 -


and you'll get a list of the available files.  You thus will
always  have any reference information you need at your com-
mand as you work at your terminal.  Good luck with APL!






















































                     February 17, 1979





                           - 23 -


        Appendix A -- The APL\11 ASCII Character Set


Note that the ASCII character set for APL uses both upper-case
and lower-case.

a-z             letter
0-9             digit
`               negative sign
C <bs> J  C     comment
( )
[ ; ]           indexing
L               quad
L <bs> '        quot quad

                dyadic  monadic
+               add     plus
-               sub     negate
X               mult    sign
%               div     recip
|               mod     abs
D               min     floor
S               max     ceil
*               pwr     exp
O <bs> *        log     loge
O               circ    pi times
!               comb    fact
^               and
V               or
^ <bs> ~        nand
V <bs> ~        nor
<               lt
>               gt
$               le
&               ge
=               eq
#               ne
~                       not
?               deal    rand
R               rho     rho
I               iota    iota
E               epsilon
N               represent
B               base
\ <bs> O        trans   trans
,               cat     ravel           *
Y               take
U               drop
{               assign
}                       goto
B <bs> N        i-beam  i-beam
L <bs> %        mat div inverse
| <bs> H        grade up                *
G <bs> |        grade down              *



                     February 17, 1979





                           - 24 -


B <bs> J                execute
N <bs> J                format
/               comp                    *
/ <bs> -        comp
\               expand                  *
\ <bs> -        expand
O <bs> |        rotate  reverse         *
O <bs> -        rotate  reverse
op /                    reduce          *
op / <bs> -             reduce
J.op            outer product
op.op           inner product

* may be subscripted with a scalar
<bs>  backspace (ctrl h)










































                     February 17, 1979





                           - 25 -


            Appendix B -- APL\11 Quad Functions


The following quad functions are defined under Unix APL:

Lcr 'name'              The result of "Lcr" is  a  character
                        array  containing the function whose
                        name is passed as an argument.

Lfx newfn               The contents of the character  array
                        specified  as  an argument are fixed
                        as an APL function.

Lrun 'unix command'     The argument  passed  to  "Lrun"  is
                        executed as a Unix shell command

Lfork xx                "xx" is a dummy argument.  A  "fork"
                        system call is performed.  This quad
                        function should be used  by  experi-
                        enced  Unix  users only and probably
                        will be followed by a  "Lexec"  quad
                        function.   The  process-id  of  the
                        child is returned to the  parent;  a
                        zero is returned to the child.

Lexec matrix            Takes  a  two-dimensional  character
                        matrix  and  formats  it into a Unix
                        "exec"  system  call.   The   matrix
                        passed  as  an argument must be two-
                        dimensional, the rows must  be  _z_e_r_o
                        terminated.    This   quad  function
                        should be used by  experienced  Unix
                        users only.

Lwait xx                This quad function is used  in  con-
                        junction  with "Lfork" -- it returns
                        a 3-element  vector  of  information
                        about a child process which has ter-
                        minated.   The  first   element   is
                        either  the PID of a completed child
                        process or -1  (no  children).   The
                        second is the status of the dead PID
                        and the last is the completion code.
                        This quad function should be used by
                        experienced Unix users only.

Lexit code              This quad function is used  to  ter-
                        minate  the execution of the current
                        process, with  the  completion  code
                        "code".   It  should be used to ter-
                        minate child processes  and  can  be
                        used  to  terminate  an APL session;
                        however,  it  is  recommended   that
                        "Lexit"  be used by experienced Unix



                     February 17, 1979





                           - 26 -


                        users only.

Lpipe xx                This quad function can  be  used  to
                        set up a pipe (used for interprocess
                        communication)  It  returns   a   2-
                        element  vector  containing  the two
                        "pipe" file descriptors.

Lchdir 'directory'      This quad function can  be  used  to
                        change  APL  to  another  directory.
                        Normally, APL runs in the  directory
                        that you were in when it was started
                        by the "apl" command.  This function
                        changes  APL  to  another directory.
                        The argument is a  character  vector
                        specifying  the new directory (there
                        is NO way to default this).  A 0  is
                        returned if the "chdir" was success-
                        ful; a -1 is returned if it failed.

mode Lopen 'file'       This function is dyadic.  It opens a
                        Unix file for use by an APL function
                        with calls via "Lread" and "Lwrite".
                        The  first  argument is the mode for
                        the    open    (0=read,     1=write,
                        2=read/write).   The second argument
                        is a character vector containing the
                        file  name.   The file descriptor of
                        the opened file is returned (-1  for
                        error).

Lclose fd               This function  complements  "Lopen".
                        The  argument is the file descriptor
                        of a Unix file to be  closed.   This
                        function returns 0 for success or -1
                        for failure.

mode Lcreat 'file'      This function creates a  Unix  file.
                        If  the  file  already exists, it is
                        truncated to zero length.  The crea-
                        tion  mode is specified as the first
                        argument  (see  CHMOD(I)  for   mode
                        description).    The   filename   is
                        specified in a character  vector  as
                        the   second   argument.   The  file
                        descriptor of the created  file  (or
                        -1 for error) is returned.

fd Lread  nbytes         This  function  reads  a  specified
                        number  of  bytes  from a designated
                        file.  The  first  argument  is  the
                        file  descriptor;  the second is the
                        number of bytes  to  be  read.   The
                        data  which  is  read  is  returned.



                     February 17, 1979





                           - 27 -


                        Note that  the  returned  vector  is
                        always  character data -- to convert
                        to numeric format see  the  function
                        "Lfloat".

fd Lwrite  data          This  function  writes  data  to  a
                        specified  file.  The first argument
                        is the file descriptor;  the  second
                        is  the  data  to  be  written.  The
                        number of bytes written is  returned
                        as  the  count.   Any  type  of data
                        (character or numeric) may be  writ-
                        ten in this manner.

Lseek (fd,pos,mode)     This function  executes  the  "seek"
                        system  call  on  a  Unix file.  The
                        argument  to  "Lseek"  is  a  three-
                        element  vector  containing the file
                        descriptor, seek  offset,  and  mode
                        (see  SEEK  (II)).   A 0 is returned
                        for  a  successful   seek;   -1   is
                        returned if an error is detected.

pid Lkill signal        This function  executes  the  "kill"
                        system  call.   The  first  argument
                        specifies what process is to be sig-
                        nalled.   The second argument speci-
                        fies what signal is to be sent.  A 0
                        is returned for a successful "kill";
                        -1 is returned if the specified pro-
                        cess  could  not  be found or is not
                        owned by the current user.  For more
                        information  on  signals,  see  KILL
                        (II).

Lrd fd                  This function reads  one  line  from
                        the  file  descriptor specified.  If
                        the line is completely blank, a null
                        string  is returned.  An end-of-file
                        will  also  return  a  null  string.
                        Otherwise, the returned value is the
                        character string which was read.

Lrm 'filename'          The specified file will be  removed,
                        equivalent  to  )drop filename.  A 0
                        is returned for a successful remove;
                        -1 is returned if the file could not
                        be removed or does not exist.

Ldup fd                 This  function  executes  the  "dup"
                        system  call.  It returns an integer
                        number which may be used as  a  file
                        descriptor  on later I/O calls.  The
                        new file descriptor is  a  duplicate



                     February 17, 1979





                           - 28 -


                        of  the argument "fd".  If the argu-
                        ment file descriptor  could  not  be
                        duplicated, -1 is returned.

fd Lap 'string'         This quad function is used to append
                        a character string onto the end of a
                        Unix  file.   The   first   argument
                        specifies the file descriptor of the
                        file (which should have been  opened
                        earlier).   The second argument is a
                        character  array  which  is  to   be
                        appended.    A  carriage  return  is
                        automatically appended to the end of
                        each row of the character array when
                        it is appended to  the  end  of  the
                        file.

Lrline fd               This quad function is  identical  to
                        "Lrd", described above.

Lnc 'arg'               This function can be used to  deter-
                        mine  what  type  of variable an APL
                        symbol is.  The apl symbol  must  be
                        specified  inside  quote  marks,  as
                        shown.  The returned value will be:
                        0 -- symbol is undefined
                        2 -- symbol is a label or variable
                        3 -- symbol is a function name
                        4 -- unknown type (should not occur)

signal Lsig action      This  quad  function  allows  signal
                        processing  to  be turned on and off
                        under  APL  function  control.   The
                        first  argument  is the signal whose
                        processing is to  be  changed.   The
                        second  argument  specifies  how the
                        signal will be processed -- if zero,
                        the signal will cause termination of
                        APL and a  possible  core  dump;  if
                        non-zero,   the   signal   will   be
                        ignored.  Note that the special  way
                        in  which  interrupts and other sig-
                        nals are processed by APL is  turned
                        off  by  a call to "Lsig" and cannot
                        be turned back on.  A -1 is returned
                        on  error, a positive number or zero
                        for success.

Lfloat charvect         This quad function is useful in con-
                        junction  with "Lwrite" and "Lread".
                        While any type of data may be  writ-
                        ten  to  a  Unix file with "Lwrite",
                        when it is read with "Lread" it will
                        be  interpreted  as  character data.



                     February 17, 1979





                           - 29 -


                        This function will convert a charac-
                        ter  array  into  numeric form.  The
                        array must be a multiple of  4  ele-
                        ments  long  for apl2 and 8 for apl.
                        The converted array is the  returned
                        value.



















































                     February 17, 1979





                           - 30 -


           Appendix C -- APL\11 I-Beam Functions


The following monadic i-beam functions are available:


20   This i-beam returns the time-of-day as the total number
     of  1/60  seconds  which  have  elapsed since midnight.
     Division by 60 gives the number of seconds  since  mid-
     night, etc.

21   This i-beam returns the total amount of CPU  time  used
     by  the  current  APL  session  in  1/60 seconds.  This
     includes the amount of time spent by  the  system  per-
     forming  I/O  (sys time) and computational time ("user"
     time).

22   This i-beam returns the number of 8-bit bytes which are
     left in the workspace.

24   This i-beam returns the time-of-day (in  1/60  seconds)
     when the current APL session was begun.

25   This i-beam returns  the  current  date  as  a  6-digit
     number  of  the  form  _m_m_d_d_y_y.  Thus, February 23, 1978
     would be 022378.

26   This i-beam returns the line  number  in  the  function
     currently  being executed.  Thus, if it is used in line
     3 of a function, it will return 3.

27   This i-beam returns a vector of  the  line  numbers  in
     pending  functions  (functions which called the current
     function and are waiting for its completion).

28   This i-beam returns the  date  (as  a  6-digit  number,
     _m_m_d_d_y_y) when the current APL session began.

29   This i-beam returns the  current  origin,  set  by  the
     ")origin" system command.

30   This i-beam returns the current width, as  set  by  the
     ")width" system command.

31   This i-beam returns the current number of digits to  be
     displayed, as set by the ")digits" system command.

32   This i-beam returns the number of workspace bytes which
     are  being  used.   It  is the complement of i-beam 22,
     which tells how many bytes are unused.  Thus, the  max-
     imum  workspace  size  (in  bytes) can be calculated by
     adding i-beams 22 and 32.





                     February 17, 1979





                           - 31 -


36   This i-beam returns the second element  of  the  vector
     returned  by  i-beam 27 -- that is, it returns the line
     number of the function which called the  current  func-
     tion.

40   This i-beam returns the total amount of CPU time  spent
     by any child processes of APL.  Children of APL include
     the editor, the shell if ")shell" is used, anything run
     by "Lrun", and any processes executed using "Lfork".

41   This i-beam returns the total  amount  of  "user"  time
     spent by APL and all of its children.

42   This i-beam returns the total "system"  time  spent  by
     APL and all of its children.

43   This i-beam returns the total  amount  of  "user"  time
     (computational time) spent by APL.

44   This i-beam returns the total amount of "sys" (I/O  and
     other system calls) time spent by APL.

96   This i-beam causes APL to dump its stack on the  termi-
     nal.  It is intended for system development of APL, and
     is probably useful only  in  generating  a  big  messy-
     looking display.

97   This i-beam returns the total  number  of  elements  on
     APL's  internal  stack.   It  is  intended  for  system
     development and debugging of APL itself.

98   This i-beam function turns off the trace of all  memory
     allocations and deallocations which i-beam 99 turns on.
     It returns a 1 if the trace was on, and a 0 if  it  was
     off already.

99   This i-beam turns on  the  alloc/free  trace  mentioned
     above,  which i-beam 98 turns off.  It also returns a 1
     if the trace was already on, or a 0 if it was off.



The following dyadic i-beam functions  were  implemented  to
compensate  for the lack of sufficient quad variables.  They
may be subject to future change.  The function is  specified
by  the  right argument, the left argument is a parameter to
that function.  The available i-beams are:

29   This i-beam may be used to set the origin to  any  per-
     mitted value.  The left argument specifies the new ori-
     gin, and the previous origin is returned.






                     February 17, 1979





                           - 32 -


30   This i-beam may be used to set the  terminal  width  to
     any  permitted  value.  The left argument specifies the
     new width, and the previous width is returned.

31   This i-beam may be used to set  the  number  of  digits
     displayed  to  any  permitted value.  The left argument
     specifies the new number of digits,  and  the  previous
     value is returned.

34   This i-beam implements the system "nice" function.  The
     "nice"  of  the  APL  process  will be set to the value
     specified  by  the  left  argument.   A  zero  will  be
     returned  for  success,  a  -1 is returned for failure.
     This  is  intended  for  background   processing,   not
     interactive use of APL.

35   This i-beam implements  the  system  "sleep"  function.
     APL  will  suspend  itself  for  the  number of seconds
     specified (by the left argument).  The  value  returned
     is the value of the left argument.

63   This i-beam implements  the  system  "empty"  function.
     The  left  argument  specifies  a  file descriptor of a
     pipe.  If the pipe is empty, a 1 will be  returned,  if
     not-empty, a 0 will be returned.  A -1 will be returned
     if the file descriptor is illegal or is not a pipe.































                     February 17, 1979


