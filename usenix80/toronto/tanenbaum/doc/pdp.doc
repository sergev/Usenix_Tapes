.po 4
.de ht
'sp 4
.ns
..
.de ft
'bp
..
.wh 0 ht
.wh -7 ft
.de p0
.ne 10
.sp 2
.ti -4
\\$1 \\$2 \\$3
.sp 1
..
.de p1
.in 8
.ne 10
.sp 2
.ti -8
\\$1
.sp 1
..
.de p2
.in 18
.ne \\$1
.ti -10
.br
..
.de cd
.ti -4
Called\ by:
..
.de pa
.ti -4
Parameters:
.br
..
.ta 11,19,27,35,41

.sp 30
.ce 2
Description of the optimizing EM1 Unix-as translator
.br
(version 23 March 1979)
.bp
.p0 Introduction
Pdp is a program,
developed to translate and optimize EM1 code,
as described
in A.S.Tanenbaum et.al.
"Description of an experimental machine architecture
for use with block structured languages",
to UNIX-assembly code.
.br
There are a number of features of EM1 which are not included in pdp,
e.g. virtual memory.
The major differences are discussed below.
.p0 Register Allocation
Differences between EM1-registers and the code produced by pdp:
.br
PS	- Not implemented,
'in +10
because we have not implemented User/Monitor mode.
UNIX system-calls can be made by using procedures written in as.
.in -10
PB	- Not implemented,
'in +10
we could not find any job for it.
.in -10
PC	- The usual r7
.br
EB	-
'in +10
address of first external. Cannot be changed, i.e. is not a proper EM1-register.
.in -10
PD	-
'in +10
Not available: there is no procedure descriptor table.
.in -10
LB	-
'in +10
r4 is used for LB. No further differences.
.in -10
SP	-
'in +10
Pdp generates code that uses two stacks:
.in +4
The operand stack.
.br
The procedure call and return stack (r6).
.in -4
.in -10
HP	-
'in +10
Same as in EM1
.in -10
ML	-
'in +10
Lowest word not implemented.
.in -10
.p0 Stack-Organization and Call/Return-mechanism
The only difference between the EM1-stack and the 'pdp-stack' is
the absence of the return addresses on the latter (r5 or SPX).
Calling sequence:
.in +4
1. Push static link.
.br
2. Push dynamic link.
.br
3. Push parameters.
.br
4. Execute 'jsr pc,proc'
.br
5. Set LB. (is done in the CALLED procedure!)
.in -4
.sp 1
N.B. LB is pointing to the first actual parameter.
.in +5
SPX stacks upward: SPX is pointing above the top.
.br
Return-adresses are stacked on r6 (sp).
.in -5
.ne 7
.p0 Array-descriptors
The array-descriptors are as described in the EM1-article.
Descriptors entered as ROM pseudos will result in inline array-instruction
translation,
whereas all others will use runtime-routines.
.p0
.p0 I/O and Monitor/User-mode
Because we have a rather clever monitor at our disposal (UNIX),
we thought it would be unwise to write our own one.
All I/O can be done by using subroutines written in as.
The monitor mode instructions are illegal in pdp.
.p0 Traps and Interrupts
Most traps (or interrupts) will be generated by UNIX, e.g. memory fault.
.br
See for a description of error messages pc:emlib(VII).
.in -4
.p0 "Use of external assembly-routines"
The assembly program must look like this:
.bl 2
.nf
	.globl _example,statd
_example:
	sub $paramsize,r5	/r5 now points to first parameter.
	  ....		/statements of assembly program
	  ....		/not changing r5.
	add $statd,r5	/remove mark-block.
	mov functionresult,(r5)+	/!IF ANY!
	rts pc

.fi
.bl 2
.ne 5
Caution:
.in +6
- r4 should not be changed!
.br
- r5 should not be changed, except as in the example
.br
- sp should not be changed!
.in -6
.bl 2
.ne 22
The contents of the r5 stack are as follows:
.nf
.bl 1
.in +4
   on entry:                on exit:

---------------
|    empty    | <- r5
---------------
|             |
| parameters  |
|             |
---------------
|             |		---------------
| mark-block  |		|    empty    | <- r5
| with  size  |		---------------
|  -statd     |		|  function-  |
|             |		|    result   |
---------------		---------------
|/////////////|		|/////////////|
|// rest of //|		|// rest of //|
|// program-//|		|// program-//|
|//  stack  //|		|//  stack  //|
|/////////////|		|/////////////|
.p0 EXAMPLE
.nf
.ne 25
Pascal program:

program show(input,output);
var status:integer;
    pid:integer;

function fork:integer; extern;
function wait(var status:integer):integer; extern;

begin
   pid := fork;	(* now there are two processes *)
   if pid = 0 then
      writeln('I am the child, my life will be short')
   else
      begin
         writeln('I am the father, I will wait for my child');
         if pid < 0 then
            writeln('Forking failed.')
         else
            if wait(status) <> pid then
               writeln('Wrong child died')
            else
               writeln('Exit status of the child was ',status:1)
    end
end.

.fi
.ne 14
.nf
Assembly-code for external function fork:

/ function fork:integer;extern;	(* returns pid *)
.globl _fork,statd

_fork:	sys fork
	br 1f	/ This instruction is executed by child
	bec 2f	/ This one by the father
	mov $-1,r0
2:	add $statd,r5
	mov r0,(r5)+
	rts pc
1:	clr r0
	br 2b

.ne 13
Assembly-code for external function wait:

/ function wait(var status:integer):integer; (* returns pid *)
.globl _wait,statd

_wait:	sys wait
	bes 1f
2:	mov r1,*-(r5)
	add $statd,r5
	mov r0,(r5)+
	rts pc
1:	mov $-1,r0	/ if no child present return -1
	br 2b

.fi
.in -4
.in -4
.bp
.p0 "Description of the program"
.p1 Introduction
The translator has two parts:
the first reads EM1 compact code and transforms it
into an internal form and drives the second part,
which is the code generator.
.in -12
We will discuss the code-generation fase only.
.br
The code generation has been implemented in the following way:
.br
In general, code is produced only whenever an EM1-instruction
that acts as an operator, is to be translated.
This delay has been accomplished by 'executing' as many EM1-instructions
as possible internally, using a 'fake'-stack.
Whenever an instruction must be translated
that can not be 'executed' internally,
the internal fake stack is searched for the proper operands
(determined by the instruction)
and, if found, the operation is executed
producing the corresponding assembly-code.
If the top fake-frames do not represent the required type of operands,
they are manipulated in order to be of the proper type.
In this way, rather efficient pdp-11 assembly-code (with its multiple operand
instructions) can be produced,
even if the translation is, as a rule, one EM1-instruction at a time.
.p1 "The data-structures"
Two main data-structures are used: LINE and FAKELT.
.p2 15
LINE	is a structure with the following fields:
.br
instr_num the number of the EM1-mnemonic.
.br
addr1	the operand of the EM1-instruction.
.br
type1	the type of the operand.
'in +8
(MISSING, PROCNAME, GLOSYM, LOCSYM or CONST).
.in -8
All pseudo instructions are processed in part one
and code is generated if necessary.
.br
In accordance with the EM1 manual operands may be global symbols,
but only for a few instructions
correct code is generated
(in general this will be sufficient).
.br
If an array-descriptor is defined in ROM, the pointer to this descriptor
is saved to be used in the procedure ARRSPC.
.br
NEXTLINE is a global variable pointing to the instruction being translated.
.p2 15
FAKELT	is the structure of the entries in the fake EM1-stack;
the fields are:
.br
type	type of the item represented
'in +8
(CONS, LOCL, EXT, REG, STK, ADDRLOCL, ADDREXT)
.in -8
flags	indicating: INDirect,
'in +8
INTeger or double, type of CONVersion.
.in -8
offset	numeric address,
'in +8
(name address) offset or register index
.in -8
index	name pointer or register number
.br
FSP is a pointer to the top of the FAKE-stack.
.p1 "File a30.c"
This file contains procedures to 'drive' the code generator.
.p1 "File a40.c"
.p2 7
MAKE_CODE\ makes assembly-code. This routine calls the appropriate routine
or deals with the EM1 instruction itself.
.cd
PASS_4, ARRSPC, CIF_CID, GEN_CNV.
.pa
EM1-mnemonic and its operand.
.p1 "File a41.c"
This file contains procedures to do arithmetic.
.p2 5
ADD_SUB	for add and sub
.pa
EM1-mnemonic (add or sub)
.cd
MAKE_CODE, ARRSPC
.p2 5
GEN_MUL	for mul
.pa
none
.cd
MAKE_CODE
.p2 5
DIV_MOD	for div and mod
.pa
EM1-mnemonic (div or mod)
.cd
MAKE_CODE
.p2 5
GEN_ASH	for rol, ror, shl, and shr
.pa
EM1-mnemonic (rol ror shl or shr)
.cd
MAKE_CODE
.p2 5
ASHSPC	is called for shl and shr with operand 1
.pa
EM1-mnemonic (shl or shr)
.cd
GEN_ASH
.p2 5
GEN_FLT	for floating arithmetic (fad, fsb, fmu, fdv)
.pa
EM1-mnemonic (fad fsb fmu or fdv)
.cd
MAKE_CODE
.p1 "File a42.c"
a42.c contains the procedures for the boolean and comparison group.
.p2 5
AND_XOR	for and and xor with operand 2
.pa
EM1-mnemonic (and or xor)
.cd
MAKE_CODE
.p2 7
GEN_BOO	for and, ior, xor with operand 4, 6 etc
and for ans, ios and xos
.pa
1.\ EM1-operand (and(s) ior(s) or xor(s))
.br
2.\ Operand.
.cd
MAKE_CODE
.p2 5
GEN_CMI	performs the cmi and cmu
.pa
EM1-mnemonic (cmi or cmu)
.cd
MAKE_CODE
.p2 7
GEN_TST	performs the tests: tlt, tgt, tle, tge, teq, tne
and not (because not is the same as teq)
.pa
EM1-mnemonic (which test)
.cd
MAKE_CODE
.p2 7
GEN_CMF	performs the floating compare: cmf
.pa
none
.cd
MAKE_CODE
.p2 18
GEN_BRA	performs all the branches, with no test, single test and compare
instructions:
.br
brf and brb for unconditional branch;
.br
blt, bgt, ble, bge, bne and beq for compare and branch;
.br
zlt, zgt, zle, zge, zne and zeq for test and branch;
.br
and, ior and xor (with operand 2) followed by zeq or zne
are also handled by this routine.
.pa
1.\ EM1-instruction (which test).
.br
2.\ Value of branch-label.
.br
3.\ Number of items to test (0, 1 or 2)
.br
4.\ How to compare (bit, bis, xor or cmp)
.cd
MAKE_CODE
.p1 "File a43.c"
a43.c contains procedures for load and store indirect,
set group and array group.
.p2 5
GEN_LOI	performs the instruction loi.
.pa
Number of words to  to be loaded. (not bytes!)
.cd
MAKE_CODE
.p2 5
GEN_LIB	loads indirect one byte (lib, loi 1)
.pa
none
.cd
MAKE_CODE
.p2 5
GEN_STI	performs the instruction sti.
.pa
Number of words to to be stored. (not bytes!)
.cd
MAKE_CODE
.p2 5
GEN_SIB	stores indirect one byte (sib, sti 1)
.pa
none
.cd
MAKE_CODE
.p2 8
GEN_INN	generates code for a call to .inn
(inn and ins)
.pa
1.\ EM1-mnemonic (inn or ins)
.br
2.\ FAKE-stack pointer to first frame of array-descriptors.
.br
3.\ Operand of EM1-instruction
.cd
MAKE_CODE
.p2 7
GEN_ARR	generates code for calls to the appropriate runtime
array-instruction subroutine.
.pa
1.\ EM1-mnemonic (lar, sar or aar)
.br
2.\ FAKE-pointer to arraydescriptors.
.cd
MAKE_CODE
.p2 9
ARRSPC	perform the array-instruction. Code can be generated
compile-time because of the existence of read only array-descriptors.
.pa
1.\ EM1-mnemonic (lar(s) sar(s) or aar(s))
.br
2.\ Pointer to (compile-time) arraydescriptors
.cd
MAKE_CODE
.p1 "File a44.c"
a44.c contains the procedures for the conversion group, procedure call
group and some miscellaneous instructions.
.p2 5
GEN_MRK	generates code for a mrk instruction.
.pa
Operand of instruction
.cd
MAKE_CODE
.p2 5
GEN_RET	generates code for ret 1 and ret 2.
.pa
Operand of instruction
.cd
MAKE_CODE
.p2 7
GEN_BLM	generates code for blm and bls.
.pa
1.\ EM1-mnemonic (blm or bls)
.br
2.\ Operand of blm
.cd
MAKE_CODE
.p2 7
GEN_REG	generates code for lor and str.
.pa
1.\ EM1-mnemonic (lor or str)
.br
2.\ Operand of instruction
.cd
MAKE_CODE
.p2 6
CIF_CID	generates code (if necessary) for cif and cid
.pa
EM1-mnemonic (cif or cid)
.cd
MAKE_CODE
.p2 6
GEN_CNV	generates code for cdi, cdf, cfd and cfi
.pa
EM1-mnemonic (cdi cdf cfd or cfi)
.cd
MAKE_CODE
.p2 6
DUPSPC	generates code for dup 2.
.pa
none
.cd
MAKE_CODE
.p1 "File a45.c"
a45.c contains the procedure MOVE.
.p2 11
MOVE	procedure to move data from one fake-frame to another.
.pa
1.\ Source FAKE-frame to move.
.br
2.\ Destination FAKE-frame.
.cd
MAKE_CODE, DIV_MOD, GEN_FLT,
GEN_CMF, GEN_STI, GEN_INN,
GEN_RET, GEN_BLM, CIF_CID, GEN_CNV, DUPSPC,
SPLIT, CHECKINT, CHECKFLT, EMPTY_FAKE, REGS_TO_STK,
GETREG, MV_TO_REG.
.p1 "File a46.c"
a46.c and a47.c contain procedures to manipulate the fake-stack.
.p2 11
MAKE_INT	guarantees that there is a certain number of integer frames
on the fake-stack.
.pa
1.\ Number of integer frames wanted.
.br
2.\ Number of words to stack if stacking turns out to be necessary
.cd
MAKE_CODE, ADD_SUB, GEN_MUL, DIV_MOD, GEN_ASH, ASHSPC,
AND_XOR, GEN_CMI, GEN_TST, GEN_BRA,
GEN_LOI, GEN_LIB, GEN_STI, GEN_SIB, ARRSPC,
GEN_BLM, CIF_CID, DUPSPC.
.p2 7
MAKE_DBL	guarantees that there is a certain number of double frames
on the fake-stack.
.pa
Number of double frames wanted.
.cd
MAKE_CODE, GEN_FLT, GEN_CMF, GEN_STI, GEN_CNV.
.p2 5
SPLIT	splits one double into two integer frames.
.pa
Pointer to FAKE-frame to split.
.cd
MAKE_INT, MAKE_DBL, JOIN.
.p2 5
JOIN	joins two integer frames to one double
.pa
Pointer to lowest FAKE-frame that must be joined.
.cd
MAKE_DBL
.p2 11
TOSTACK	pushes a frame in the fake-stack onto the real stack
.pa
1.\ Flag indicating whether the frame above the frame pointed to is
to be stacked too.
.br
2.\ Pointer to FAKE-frame that is to be stacked.
.cd
MAKE_DBL, JOIN.
.p2 6
FILLUP	inserts a number of 'STK' frames at the bottom of fake-stack.
.pa
Number of 'STK' frames to insert.
.cd
MAKE_CODE, ADD_SUB, ASHSPC, AND_XOR, GEN_CMI, GEN_CMF, DUPSPC.
.p2 11
CHECKINT	guarantees that you have a certain 'clean' integer frame.
.pa
1.\ Pointer to FAKE-frame in order to check it.
.br
2.\ Condition to check on.
.br
3.\ Register number wanted (only used if a move must be performed)
.cd
MAKE_CODE, ADD_SUB, GEN_MUL, DIV_MOD, GEN_ASH, ASHSPC,
AND_XOR, GEN_CMI, GEN_TST, GEN_BRA,
GEN_LOI, GEN_SIB, ARRSPC, DUPSPC.
.p2 8
CHECKFLT	guarantees that you have a certain 'clean' double frame.
.pa
1.\ Pointer to FAKE-frame in order to check it.
.br
2.\ Condition to check on.
.cd
GEN_FLT, GEN_CMF.
.p2 8
CONGR	compares an entry in LINE and a FAKE-frame to see if
they refer to the same address.
.pa
1.\ Pointer to FAKE-frame.
.br
2.\ Pointer to LINE-frame.
.cd
ADD_SUB, ASHSPC, AND_XOR.
.p1 "File a47.c"
.p2 7
PSHFK	pushes a frame onto the fake-stack
.pa
Pointer to FAKE-frame.
.cd
MAKE_CODE, GEN_CMF, GEN_LOI, GEN_STI, GEN_INN, GEN_ARR,
CIF_CID, DUPSPC, MAKE_INT, MAKE_DBL, POPFK.
.p2 6
POPFK	pops a frame from the fake-stack
.pa
Number of frames to pop.
.cd
MAKE_CODE, GEN_BOO, GEN_INN, GEN_BLM, TO_REG0.
.p2
COPYF	copies one fake-frame to another
.pa
1.\ Pointer to source FAKE-frame.
.br
2.\ Pointer to destination FAKE-frame.
.cd
MAKE_CODE, ADD_SUB, GEN_MUL, DIV_MOD GEN_FLT,
GEN_CMI, GEN_TST, GEN_STI, DUPSPC, MOVE,
SPLIT, JOIN, FILLUP, PSHFK.
.p2 10
EMPTY_TO	searches the fake-stack for a frame
and pushes it together with all frames
above it onto the real stack
.pa
Pointer to FAKE-frame to test on.
.cd
MAKE_CODE, ADD_SUB, ASHSPC, AND_XOR, DUPSPC.
.p2 11
EMPTY_FAKE\ pushes a number of frames on the fake-stack onto the real stack
.pa
Number of words to be pushed onto the real stack.
.cd
MAKE_CODE, GEN_CMF, GEN_BRA, GEN_LOI, GEN_STI, GEN_SIB,
GEN_BLM, GEN_REG, GEN_CNV,
MAKE_INT, MAKE_DBL, TOSTACK,
PSHFK, EMPTY_TO, TO_REG0.
.p2 6
WORDS_ON_FAKE\ counts the number of words on the fake-stack (NOT the number
of frames !)
.pa
none
.cd
EMPTY_FAKE.
.p2 6
REGs_TO_STACK\ pushes all the 'REG' frames onto the real stack
.pa
Pointer to FAKE-frame. (All 'REG's from bottom up to and including
this frame must be stacked)
.cd
CIF_CID, EMPTY_FAKE, GETREG.
.p2 6
STKS_ON_FAKE\ counts the number of 'STK' frames on the fake-stack
.pa
Number of FAKE-frames to be counted
.cd
EMPTY_FAKE.
.p2 8
WRDSOF	returns the number of words (1 or 2) in a fake-frame
.pa
Pointer to FAKE-frame which is to be investigated
.cd
POPFK, EMPTY_FAKE, WORDS_ON_FAKE, STKS_ON_FAKE, SET_TO_STK.
.p2 6
CLR_FAKE_IF_ALL_STKs\ clears the fake if it contains 'STK' frames only
.pa
none
.cd
GEN_BRA, EMPTY_FAKE.
.p2 6
SET_TO_STK	sets all the fake-frames to STK, except the top n words
.pa
Number of FAKE-frames to be saved.
.cd
MAKE_CODE.
.p2 10
GETREG	gets a register (integer or double)
.pa
1.\ Pointer to FAKE-frame to be copied to.
.br
2.\ Requirements for the register (not number i, only an odd number etc.)
.cd
MAKE_CODE, DIV_MOD, GEN_FLT, GEN_CMI, GEN_TST, GEN_CMF,
GEN_LOI, GEN_LIB, GEN_STI, GEN_BLM, CIF_CID, GEN_CNV, DUPSPC,
CHECKINT, CHECKFLT, TO_REG0, MV_TO_REG.
.p2 8
REG_AVAIL	returns the number of an available register
(-1 if there is none)
.pa
1.\ Boolean: true for integer, false for floating register.
.br
2.\ Requirements for the register.
.cd
GEN_LIB, MOVE, SPLIT, GETREG.
.p2 5
CLEAREGS	releases all registers
.pa
none
.cd
PASS_4, MAKE_CODE, GEN_STI, GEN_SIB, GEN_BLM.
.p2 15
TO_REG0	generates code for putting things into R0 and pops a number of
words from the FAKE-stack.
TO_REG0 returns a pointer to the FAKE-frame on top of the stack before popping.
.pa
1. Number of FAKE-frames to pop
.br
2. Number of words to stack if stacking turns out to be necessary
.br
3. String used as source for the move to register 0.
(if no string is passed, the top of the FAKE-stack is used as source)
.cd
MAKE_CODE, GEN_BOO.
.p2 10
MV_TO_REG	moves a fake-frame to a register
.pa
1.\ Pointer to FAKE-frame to be moved.
.br
2.\ Number of the register to move to.
.cd
MAKE_CODE, ADD_SUB, DIV_MOD, GEN_ASH, ASHSPC, AND_XOR,
GEN_LOI, GEN_LIB, GEN_STI, GEN_SIB, GEN_ARR, ARRSPC,
GEN_BLM, CIF_CID, DUPSPC, TO_REG0.
.p2 8
FREE_REG	releases a register
(if the parameter is a pointer to a register-frame)
.pa
Pointer to FAKE-frame
.cd
ADD_SUB, GEN_MUL, DIV_MOD, GEN_ASH, GEN_FLT,
AND_XOR, GEN_CMI, GEN_CMF, GEN_BRA,
MOVE, SET_TO_STK, MV_TO_REG.
.p2 6
SET_REG	mark a register
(if the parameter is a pointer to a register-frame)
.pa
Pointer to FAKE-frame
.cd
COPYF.
.p2 6
IS_REG	tests a fake-frame for being a register
.pa
Pointer to FAKE-frame
.cd
DIV_MOD, GEN_CMF, MOVE, CHECKFLT, MV_TO_REG, FREE_REG, SET_REG.
.p1 "File a48.c"
a48.c contains the procedures to generate code.
.p2
GEN	generates an assembly line
.p2
PLABEL	generates a label from a string (i.e. "string:")
.p2
LOCNAME	makes a string for a local label (e.g "L83")
.p2
PRONAME	make a string for a procedure name (e.g. "_proname")
.p2
STR	generates a string with the correct addressing mode
.p2
ADRSTR	makes a string using the two fields offset and index
.p2
AUTINC,\ AUTDEC	generates a string with auto-increment/decrement
.p2
INDSTK	generates a string "offset(spx)"
.p2
IMM	generates a string "$number"
.p2
ADREXT	generates a string "$address+eb"
.p2
INDREG	generates a string "offset(rn)"
.p2
STATREG	generates a string "statd(rn)"
.p2
MKFLTCONS if possible, converts a frame in order to contain a floating
constant (e.g. $40200 for the real constant 1)
.p2
COPYSTR	copy one string to another
.p2
ITOA	generates a string for an integer (integer to ascii)
