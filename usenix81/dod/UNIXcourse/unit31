.bp
.ds F1 - % -
.ds Fd
.ds F3  ~
.ds Fl  Unit~III
.ds Fr  Module~II
.ds H1  ~
.ds Hl MP119
.ds Hr Introduction to UNIX
.PH "~~~~~~~~~~~~MODULE I -- Text Editing" 5 2 2 3
.PP
This module covers UNIT III objectives 1, 2, and, 3.
.PH "Objectives"
.sp
After completion of this module, you will be able to:
.sp
.L1 5 2 1
Use the command to gain access to the UNIX Text Editor.
.L1
Append text to a file.
.L1
Insert text into a file.
.L1
Reposition text within a file.
.L1
Modify text within a file.
.L1
Delete text from a file.
.L1
Create sub-files.
.L1
Edit more than one file simultaneously.
.L1
Display a line/lines of the edited file.
.L1
Use the command to terminate use of the editor.
.E1
.bp
.PH "~~~~~~~~~~~~~~~~The~Unix~Text~Editor"
.PP
I know there have been times when you must have wished
you had placed another piece of information into the file
you just created, or maybe you would just like to change
it around a little, or maybe even delete some of it.  Prior
to this unit, you were sort of handicapped and probably
a little frustrated because you couldn't do any of these
things. This module is going to teach you to do all this and
more, so let's begin.
.PH "ED Command"
.PP
The Unix Text Editor allows you to modify your text
files by using special commands; that is, the commands employed
only while using the editor. To obtain use of the editor, you
must issue the following command:
.sp
.ti 20
% ed <filename>
.sp
where "ed" gives you access to the editor, and "filename" is the
name of the file to be modified.  The system reads the specified
file into a buffer.  Think of the buffer as a work area or
the first draft of a report, where you are going to make all
the necessary changes before typing the final draft. While you
are using the editor, you may change and rechange the file as
much as you like. When you have the file as you want it, then
you are going to direct the system to write or place the contents of
the buffer (modified version of the file) back into the specified file.
.PP
The system lets you know when you have gained access
to the editor by displaying the number of characters read into
the buffer. (The number of characters contained in the file being
read into the buffer).
.sp
.in 20
Example: % ed junk
.sp
Response: 685
.sp
.in -20
.PP
This is the only information displayed.  To get the system
to perform any other action such as displaying the file, requires
using one of the editor commands discussed in the following sections.
.PH "The~Append~Command"
.PP
This command allows you to append (or add) text lines to the buffer.
.sp
.ti 10
Example:  Assume that the file being edited contains:
.sp
.in 20
Now is the time
.br
for all good men
.br
to come to the aid
.br
of their country.
.in -20
.sp
.ti 10
And you type:
.in 20
a
.br
Rise up, rise up young men!
.br
Uncle Sam needs you now
.br
\&.
.in -20
.sp
Where "a" is the append command, and the "." is used to tell the
editor that you have no more text to add to the buffer.
.sp
.in 20
The buffer now contains:
.sp
Now is the time
.br
for all good men
.br
to come to the aid
.br
of their country.
.br
Rise up, rise up young men!
.br
Uncle Sam needs you now.
.in -20
.sp
.in 11
.ti -11
Notes:~(1)~To add more text to the buffer, just issue the
"append" command again.
.br
.ti -11
~~~~~~~(2)~Everything you type between the "a" and the "."
will be added to the contents of the buffer
(other commands, errors, everything), so don't
forget to type the "." when you have finished
entering the text.
.ti -11
~~~~~~~(3)~The "." must be the only character on the line.
That is, you should type:
.sp
.ti +10
 . <return>
.in -11
.PH "The~Write~Command"
.PP
The "write" command is used to write the contents of
the buffer into the file being edited (destroying any
previous information in the file). No modifications are
actually made to the file until the "write" command is
issued.  Prior to issuing this command, the modifications
are made to the copy of the file which is contained in the
buffer.  The form of the command is:
.sp
.ti 28
w
.sp
The system responds by displaying the number of characters in the
file. This count includes spaces and the end of line character
generated when the return key is depressed.
.PP
Let's take a look at the commands you've learned so far in this module.
.sp
.in 25
% ed junk
.br
a
.br
<text>
.br
\&.
.br
w
.sp
.in 11
.ti -11
Notes:~(1)~The "write" command doesn't destroy the contents of the
buffer; thus, you may continue to modify the file after
issuing the "write" command.
.br
.ti -11
~~~~~~~(2)~You should issue the "write" command following each
change made to the file, rather than waiting until
you have made all the intended changes. This is
some insurance against losing all copies of the
modified file if the system goes down suddenly.
.in -11
.PH "Creating a File"
.PP
The editor can also be used to create a file. To do this,
the following sequence of commands are issued::
.sp
.in 25
% ed
.br
a
.br
<text>
.br
\&.
.br
w junk
.in -25
.sp
You will notice that the filename has been specified in the "w"
command instead of in the "ed" command. Thus, the file "junk" will
be created when the "w" command is executed.
.PP
Okay, what do you think will be the result of the following commands?
Put your answer in the space provided.
.sp
.in 25
% ed junk
.br
a
.br
<text>
.br
\&.
.br
w temp
.in -25
.ne 10
.sp 2
Answer: If your answer is: The file "temp" will be created containing the
concatenation of the file "junk" with "<text>"; very good. Note that
the file "junk" remains unchanged.
.PH "The~Quit~Command"
.PP
To terminate your session in the editor, issue the "quit"
command by typing:
.br
.ti 28
q
.sp
The system will respond by displaying the "%".  You are now
out of the editor.
.sp
.in 6
.ti -6
Note: Before issuing this command, be sure to issue the "write"
command.  The "quit" command erases the buffer containing
the modified copy of your file. If you should type "q" when
you have not written the file, the system will display a "?"
to remind you.
.in -6
.PH "Error Messages"
.PP
If you make an error in typing the editor commands,
the system will let you know displaying:
.sp
.ti 28
?
.sp
This really lets you know where you goofed doesn't it? Well
don't worry, with a little practice you won't have any trouble
determining where you went wrong. To correct, just retype the command.
.PH "Exercise"
Okay, you've learned enough commands to have your first
editing session; so get to it.
.L1 5 2 1
Using the UNIX Text Editor, create a file called "junk."
.L1
Leave the editor and display the file.
.L1
Using the editor, append a couple of lines of text
to "junk." (This text can be anything you want to add.)
.L1
Repeat #2
.E1
.PH "~~~~~~~~~~~~~~~~Displaying~the~file"
.PH "Printing the Contents of the Buffer"
.PP
To display the contents of the buffer (or parts of it)
on the terminal, use the "print" command, "p."
.PP
In issuing the "print" command you specify the lines where you want
printing to begin and end, separated by a comma and followed by a
"p," as follows:
.sp
.ti 25
1,5p
.sp
This particular command will display the first 5 lines of the buffer.
Suppose you want to display the entire file in the buffer.  How can
you do this?  Well, you are probably thinking, that's easy,
just use the same form as above, only specify the last line
in the file instead of the "5th." This is fine, provided
you know the number of lines in the buffer. However, you would be
in trouble if you didn't. Well, the designers of the Unix Text
Editor took this into consideration and provided a symbol which can
be used to point to the last line in the buffer, the dollar sign ($).
To use it, enter the following command:
.sp
.ti 25
1,$p
.sp
which will display all lines in the buffer.
.PH "Displaying a single line"
.PP
Any single line in the buffer can also be displayed by specifying
the line number followed by a "p"; thus,
.sp
.ti 25
2p
.sp
will display the 2nd line of the buffer.  What will be displayed
by the command "$p"?
.sp 2
You're correct if you said the last line in the buffer.
.PP
UNIX makes it even easier for you. You can get away with
just typing the line number -- omitting the "p."  So
you could type just the
.sp
.ti 25
2 or $
.sp
in the two previous commands.
.PP
That isn't all, look at what else you can do.  Suppose you want to
display the last two lines of the buffer, and you don't know the
number of lines contained in the buffer.  This could pose quite a
problem. However, Unix makes it quite simple. Just enter:
.sp
.ti 25
$-1,$p
.sp
and the problem is solved.
.sp
Which lines will be displayed when you issue the following command?
.sp
.ti 25
$-5,$-2p
.sp
Answer:  The 5th line from the last through the 2nd line from
the last -- thus, 4 lines.
.E1
.sp
.in 6
.ti -6
Note:~The beginning line specified must be less than the
ending line specified; eg., "3,1p" wouldn't work.
.PH "The Current Line"
.PP
The current line is the last line you displayed, changed, or
did anything else with. The editor maintains a record of the
line you most recently did something to, so that it can be
used instead of an explicit number. This feature, similar to
the "$," is quite beneficial in forming commands when you
don't know the line number. The symbol which denotes the
current line is the period (.), referred to as "dot." Let's
look at a few examples to determine just how it may be used.
.PP
Suppose you typed "1,3p" and then you typed ".,$p."
All lines from the current line (line 3) to the end of the
buffer will be displayed.  Why is line 3 the current line?
Because that was the last line displayed or referenced.
.PP
Dot is most useful when used in combinations like the
following:
.sp
.ti 25
+1 or .+1p
.sp
which will display the line following the current line.
.sp
.in 6
.ti -6
Note: The return key does the same thing.,
Now, you figure this one out.
.in -6
.sp
.PP
-1 or .-1p ---- will display which line? Put your answer in the space
provided.
.sp 2
Answer: The line before the current line. If that's what you answered,
you're getting the hang of it.
.sp
The command -3, .-1p will display the previous three lines.
.PP
Don't forget that all of these commands change the value of
dot.  To determine which line is the current line, simply type
.sp
.ti 28
\&.=
.sp
.PP
This causes Unix to display the number of the current line. For
example, you type "1,5p," then ".="; the system will display:
.sp
.ti 28
5
.sp
.in 6
.ti -6
Note: "p" can be preceded by 0, 1, or 2 line numbers.  If no
number is specified (just "p"), the current line is
displayed; if 1 number is specified, that line is
displayed; and if 2 numbers are specified, all lines
within that range are displayed.
.in -6
.PH "Exercise"
.PP
Experiment with the "p" command by typing all the
above comands on the file "junk", you created earlier.
(The commands are "p", "dot", dollar sign ($),
and the "minus" and "equal" signs.)
.PH "~~~~~~~~~~~~~~~~Modifying the file"
.PP
Since you are now proficient in displaying your
files, let's move on to bigger and better things.  You are
now going to learn how to change the information in your files.
.ne 10
.PH "The Substitute command"
.PP
This command is perhaps the most useful and versatile
of all the commands; it can be used to replace, insert, and
delete characters from the buffer.  You will now be able to
correct those typing errors you've been making.  The form of
the command is:
.sp
.ti 18
s/old string/new string/
.sp
where "old string" (any characters placed between the first
pair of slashes) is replaced by "new string" (any characters
placed between the second pair of slashes).
.sp
Example:~~Suppose you typed line 1 of our
previous sample file as:
.br
.ti 21
"Now is the tiem"
.sp
where "me" of time is transposed.  You can use
the following command to fix it up:
.br
.ti 21
s/tiem/time/
.sp
This will substitute the first occurrence of "tiem" of the
current line with "time".  We are assuming that line 1 is the
current line. If it isn't, you would use the command:
.sp
.ti 21
1s/tiem/time/
.PP
What does this do? It makes line 1 the current line.  The "1" is a
form of the "p" command isn't it? And the last line specified in
the "p" command becomes the current line doesn't it? Therefore, the
"1" in this command makes line 1 the current line. This form of the
substitute command allows you to be selective, that is, you can specify
which line you want to modify.
.PP
Several lines may be modified by using the following form:
"starting-line,ending line s/old string/new string/."
.sp
.ti 10
Example:~~~1,$s/programer/programmer/
.sp
will correct the first occurrence of "programer" on each line of text.
.sp
.in 12
.ti -12
Notes:~(1)~~Dot is set to the last line changed.
.sp
.ti -12
~~~~~~~(2)~~The rules  for forming line numbers in the "s" command and
all subsequent commands are the same as for the "p" command.
.sp
.ti -12
~~~~~~~(3)~~"Old string" doesn't have to be an entire word - only a
unique string of characters. For instance, if no other
word ended in "mer," then "old string" could have been
"mer" instead of "programer" in the previous example.
.sp
.ti -12
~~~~~~~(4)~~If no substitution took place, dot is not changed and
a "?" is displayed.
.ne 8
.sp
.ti -12
~~~~~~~(5)~~Unix doesn't require that a "/" be used to delimit
"old string" and "new string." Any character other
than a blank or a character in one of the strings
may be used.
.PH "Other Examples"
.L1 5 2 1
You can insert words. Suppose you typed "now the time"
instead of "now is the time." Then you could issue
.sp
.ti 25
s/the/is the/p
.sp
In this case "p" is used to display the corrected line.
.L1
You can delete characters/words from a line.  Suppose
you typed:
.sp
.ti 20
"Now is the is the time."
.sp
You could correct this by using:
.sp
.ti 25
s/is the//p
.sp
which means to replace the first occurrence of
"is the" with nothing.
.E1
.sp
.in 6
.ti -6
Note: There is no space between the second pair of
slashes. Question: what would be the result
if you left two spaces between the slashes?
The first "is the" would be replaced by two spaces.
.in -6
.PH Exercise
.L1 5 2 1
Create the following file using "ed."
.sp
.in 12
Now is the time for all good men
.br
to come to the aid of their
.br
their country now is the time
.in -12
.L1
Modify such that it reads:
.sp
.in 12
Don't delay, now is the time for
.br
all good men and women to come to
.br
the assistance of their fellowman.
.L1
Verify each line as it is corrected. Then, following
the last correction, display the entire modified file.
.E1
.PP
Now, you're really beginig to see how UNIX can work for you.
Let's move on.
.PH "Context Searching"
.PP
Another very important feature of "ed" is context
searching.  Context searching is simply another method of
specifying the desired line without using a number.  The form
of the command is:
.sp
.ti 15
/characters you want to find/
.PP
Suppose you want to change "their" to "the" of your previous file.
You're probably thinking, "No big deal, just 'type 3s/their/the/.'"
Well, this would be fine for a small file such as we have, but
what if the file contains several hundred lines of text, and you've
been adding, deleting, rearranging lines, and so on. You would
no longer know which line you were on. Consequently, you would
not know what number to specify.  However, you could use this
command:
.sp
.ti 25
/their/
.sp
which would locate the next occurrence of "their," display the
line for verification, and set dot to that line.  Now, all you
have to do is to issue the "s" command.  Both of these can be
issued simultaneously by:
.sp
.ti 18
/their/s/their/the/p
.sp
For example, this would yield:
.sp
.ti 15
to come to the aid of the country
.sp
.in 12
.ti -12
Notes:~(1)~~The system performs a "wrap around" search -- it
begins with current line and searches until it
encounters either the characters searched for or the
current line again.
.sp
.ti -12
~~~~~~~(2)~~If the character string isn't found, a "?" is
displayed.
.in -12
.bp
.PH "Other Examples"
.L1 5 2 1
Suppose you don't want the first occurrence of a character string.
Well, there is a simple remedy to this problem. Just type:
.sp
.ti 27
//
.sp
and the system will continue its search for another occurrence
of the most recently searched for string of characters.
.sp
Note: This notation can also be used in conjunction with the "s"
command as follows:
.sp
.ti 22
/their/s//the/p
.sp
Notice, there is no need to specify the "searched for string" again.
.L1
A context search expression is the same as a line number.
Therefore, it can be used any place a line number is used.
.sp
.L2
Suppose the buffer contained:
.sp
.in +10
Now is the time for all
.br
good men to come to the aid
.br
of their country.
.in -10
.sp
How can the 2nd line be displayed? Write your answer below.
.sp 3
Answer: By using either of the following expressions:
.sp
.I "~~~~~~~~~~Context Search~~~~~~~~~'P' Command"
.sp
.in +15
/now/+1~~~~~~~~~~~~~~~~~1+1p
.br
/men/~~~~~~~~~~~~~~~~~~~2p
.br
/their/-1~~~~~~~~~~~~~~~$-1p
.in -15
.sp
Well, why not use the "p" command as it appears to be easier
to form?  The "p" command is the preferred form if you know
the line numbers. However, this is highly unlikely if you're
using a large file.
.L2
To change "good" to "bad", you could use:
.sp
.in +15
/now/+1s/good/bad/
.br
.ti -5
or
.br
/good/s/good/bad/
.br
.ti -5
or
.br
/their/-1s/good/bad/
.in -15
.L2
To print all three lines, you could use:
.sp
.in +15
/now/,/now/+2p
.br
.ti -5
or
.br
/now/,/their/p
.in -15
.sp
Notice that the following form is adhered to:
.sp
.ti +15
starting-line, ending-linep
.E1
.E2
.PH "Backward Search"
.PP
To perform a backward context search, use:
.sp
.in 15
?characters you want to find?
.br
.ti -10
instead of
.br
/characters you want to find/
.in -15
.sp
This form would be used if it is suspected that the characters
searched for can be located faster doing a backward search
than doing a wrap around search.  This is an extremely significant
point when performing several searches on a large file.
.sp
.in 6
.ti -6
Note:~To locate another occurrence of the characters, use "??".
O.K., let's practice what was just covered. Do the following
exercises.
.PH "Exercise"
.PP
Use the original file created in the last section.  Modify
the file as indicated. However, use context search expressions to
replace the line numbers in the "s" and "p" commands.
.PP
If you managed without difficulty, continue on to the next section.
Otherwise, repeat the exercise.
.bp
.PH "The Delete Command"
.PP
The delete command is used to remove a line/lines from
the buffer.  The form of this command is very similar to the form
of the "p" command:
.sp
.ti 15
starting-line,ending-line d
.br
Thus:
.br
.ti 28
2,4d
.sp
will delete lines 2 thru 4.  Dot is set to the line following the
last deleted line, unless that line happens to be the last line
in the buffer.  In that case, dot is set to the last line.
.PP
You may also delete a single line.  Suppose you have 6
lines in the buffer, and you want to delete the 3rd line.  What
command would you issue and what is the value of dot after the
deletion? Write your answer below.
.sp
.PP
If your answer is: "3d" and "3," very good! You didn't
say dot would be set to 4 did you? Remember line 4 is now line 3.
.PH "The Change Command"
.PP
This command is used to change or replace one or more
lines in the buffer.  The form to use is:
.sp
.in 15
starting-line,ending-line c
.br
<type the lines of text>
.br
\&. (period)
.in -15
.PP
The form of this command is very similar to the "append"
command isn't it?
.sp
Example: Suppose the buffer contains:
.sp
.in 15
Now is the time
.br
for all good men
.br
to come to the aid of their country
.in -15
.sp
and you typed:
.sp
.in 15
1,2c
.br
Now is the time, now is the time!
.br
for all
.br
to come to the aid of their country.
\&.
.in -15
.sp
In this example, the system would delete the first set of lines and
replace them with what you typed betweem the "c" command and the ".":
this does not have to be done on a one for one basis. Several
lines may be used to replace a single line or vice versa.
.sp
.ne 20
.in 6
.ti -6
Note:~A single line number or no line number may be specified,
for example:
.sp
.in +18
3c
.br
<text>
.br
\&.
.in -18
.sp
will replace the 3rd line with "text."
Now, how about you trying one. The following command will
replace which line?  Answer in the space provided.
.sp
.in +18
c
.br
<text>
.br
\&.
.in -18
.sp 2
Answer: If you said dot or the current line, you are really on
your toes.
.in -6
.PH "The Insert Command"
.PP
You learned earlier how to insert characters and
words. You can also insert a line or a group of lines.  The form
of the command is:
.sp
.in 20
line-numberi
.br
<text you type>
.br
\&. (period)
.in -20
.sp
The system inserts whatever you type between the "i" and the "."
just before the specified line.
.sp
Example: We'll refer to the preceding example and instead of using
the change command, use the insert command.  Let's
see what happens. Recall that before we modified it
our expression was:
.sp
.in 15
Now is the time for
.br
all good men to come
.br
to the aid of their country
.in -15
Let's issue the "insert" command as follows:
.sp
.in 15
2i
.br
Now is the time, now is the time!
.br
for all
.br
\&.
.sp
.in -15
.ne 15
The buffer will now contain:
.sp
.in 15
Now is the time
.br
Now is the time, now is the time!
.br
for all
.br
for all good men
.br
to come to the aid of their country.
.in -15
.sp
Suppose you didn't know the line number, how could the
above be accomplished?
.sp
Solution: Use a context search expression to replace the line
number.
.sp
.nf
	 Example:  /for/i
		   Now is the time, now is the time!
		   for all
		   .(period)
.fi
.sp
If you had the above solution, move to the head of the class --
you're doing fine.
.sp
.in 6
.ti -6
Note: If a line-number isn't specified, the text is placed
before the current line.
.in -6
.sp
Ready to try a couple of examples at the terminal? Do the
following exercises.
.PH "Exercise"
.L1 5 2 1
Modify the following file:
.sp
.in +15
Now is the time
.br
for all good men
.br
to come to the aid of their country!
.in -15
.sp
Use the change and insert commands such that it reads:
.sp
.in +10
Attention! Attention all!
.br
Now is the time
.br
Not tomorrow
.br
But today!
.br
Come to the aid of your country!
.in -10
.L1
Display line two. Replace it with:
.sp
.ti +15
Your country needs you.
.E1
.ne 10
.PH "~~~~~~~~~~~~~~~ADVANCED~FEATURES"
.PH "The Append command"
.PP
In a previous section, you used the "append" command
to create a file and to add information to the end of a file.
The append command may also be used to add text or information at any
point within a file by specifying a line number.
.sp
.in 25
.ti -25
~~~~~~~~~~Example:~~~~~~~3a
.br
<text>
.br
\&.
.in -25
.sp
Will add "text" to the buffer just after the 3rd line.  This aspect
of the append command is almost identical to the insert command
except "insert" places the text before the specified line and append
places the text after the specified line.  Okay, let's look at another
.sp
.in 25
.ti -25
~~~~~~~~~~Example~~~~~~~~Oa
.br
<text>
.br
\&.
.in -25
.sp
See, you can even specify 0 as a line number.  Where do you think
the text will be placed?  Answer below:
.sp 3
Right you are, the text is placed before the text already
in the buffer.  Can the insert command be used to do exactly the
same thing?
.sp
Yes, of course, just specify a line number of 1 instead of 0.
.PH "The Write Commmand"
.PP
A line number can also be used in the "write" command. This lets you
write exactly the lines you want, not necessarily the entire buffer.
You can now extract certain lines from one file and create another
file consisting of the extracted lines.
.PP
But why would anyone want to do this?  Okay, let's consider the
following problem. You have a file consisting of several hundred
lines of text. However, you are only interested in lines 250 - 300.
Why bother wasting time printing the entire file and then scanning
the printout until you locate the portion that interests you?  Instead,
you could just use the following form of the "w" command and obtain a
copy of only the portion you want:
.sp
.ti 10
starting-line,ending-linew <filename>
.sp
.ti 15
Example:~~250,300w junk
.sp
"Junk" would now contain the 51 lines of text that were originally lines
250 - 300 of the file in the buffer.
.sp
.in 6
.ti -6
Note: A single line may also be extracted by specifying just
that line.
.in -6
.PH "The Move command"
.PP
The "move" command lets you move a group of lines from one
place to another in the buffer.  Refer to the modified file in the
preceding exercise.  Suppose you want the first two lines placed
at the end of the file.  This can be done by using the
following commands:
.sp
.in 15
$a
.br
come to the aid of your country
.br
attention! attention all!
.br
your country needs you.
.br
\&.
.br
1,2d
.in -15
.sp
However, the same thing can be accomplished with a single
command --- the "move" command.  It has the form:
.sp
.ti 10
starting-line,ending-line m'after this line'
.sp
.ti 20
Example:~~~~1,2m$
.sp
This does the same thing as if you had used both the "a" and "d" commands.
It is much easier though, isn't it? You will  notice that a third
line number must be specified -- this denotes the place where the moved
stuff is to be put.
.sp 2
.in 6
.ti -6
Note: Dot is set to the line number of the last line moved.
That is, dot is set to the number assigned to the
last line moved. In the above example, dot would be
set to $.
.in -6
.ne 15
.PH "Exercise"
.PP
Use the modified file in the previous exercise.  Move the
first two lines to the end of the buffer.  Use context search
expressions instead of line numbers. Write the proper command
to do these things in the space below:
.PP
Look at the answer below only if you find you can't do it
yourself; then try it on the terminal.
.sp 2
.ti 10
Answer: /attention/,/country/m/country!/
.sp 2
.in 6
.ti -6
Note: You could have used any string of characters on lines
1, 2, and 5 to form your context search expression, as
long as not more than one of the three expressions
appeared on the same line. Why? Because the system
begins its search with the line containing the
previous search expresssion.  Therefore, if more than
one of the expressions appears on the same line, it
will locate that line.
.in -6
.PH "The~Edit~Command"
.PP
"Edit" is becoming quite sophisticated now, isn't it?  Well,
hang tight 'cause you ain't seen nothing yet. You can even edit
or work on several files in the same editing session by use of
the "edit" command. This command is somewhat similar to the "ed"
command in that it places a specified file into the buffer.
Suppose you have two files "temp" and "junk," that need to be
modified. You can edit them both by:
.sp
.ti 15
% ed temp
.sp
.in 15
<issue commands to modify temp>
.sp
w temp
.sp
e junk
.sp
.PP
The "e" command will place the file "junk" into the buffer
and display the number of characters contained in "junk." You can
then issue the necessary commands to modify "junk." Before the
session ends, if you want to do something else to "temp" just type
"e temp."
.sp
.in 6
.ti -6
Note: Before issuing the "e" command, be sure to issue the
"w" command for the file currently contained in the
buffer as "e" destroys anything already in the buffer.
.in -6
.sp
Examples:
.sp
.in 4
.ti -4
(1)~Let's refer to the previous problem of extracting
a portion of a file. In that problem, you couldn't
even verify the newly created file "junk," because
the file was not in the buffer. By using the "e"
command you can now display/modify the file "junk."
.sp
.in +20
.ti -20
~~~~~~~~~~Example:~~~%~ed temp
.br
250,300w junk
.br
e junk
.sp
.in -20
The above commands create junk and place
its contents into the buffer.
.sp
Note: Before a file can be modified,it must
be in the buffer.
.sp
.ti -4
(2)~A file can also be created while editing another file
by using the "append" command.
.sp
.nf
	    Example:~~~%ed temp
			 |
			 |
			 |

			 w temp

			 e junk

			 a
			 <text>

			 .

			 w
.fi
.sp
In this case we've appended "<text>" under the filename "junk."
.in -4
.sp
.in 6
.ti -6
Note: "w" not accompanied by a filename implies the file
contained in the buffer. Also, in this situation the
editor will disaplay a "?" following the "e"
command. Ignore the "?" and continue with the "a" command.
.in -6
.PH "The File Command"
.PP
If you are editing several files simultaneously, you may forget which
file is currently occupying the buffer.  The "file" command is provided
to keep track of the file currently being edited. Just type:
.sp
.ti 28
f
.sp
and the editor will display the name of the file currently in the buffer.
.PH "The Read Command"
.PP
The "read" command is also used to place a file into the buffer.
However, unlike the "e" command, it does not destroy the text already there.
Suppose you want to concatenate the two files "junk" and "temp," before
editing. You can by typing:
.sp
.ti 20
% ed temp
.sp
.ti 22
r junk
.ne 10
.sp
This causes "junk" to be appended to the end of the copy of "temp" in
the buffer.
.PH "Line numbers with Read"
.PP
You can use line numbers with the "read" command to specify where the
file is to be placed in the buffer rather than have it placed at the
end of the text already there.
.sp
Examples:
.sp
.in 4
.ti -4
(1) Or junk: would place the contents of "junk" before the text already
in the buffer. Remember "o" is zero.
.sp
.ti -4
(2) 2r junk: would insert the contents of "junk" between the 2nd and the
3rd lines of text contained in the buffer.
.sp
.ti -4
(3) Suppose the buffer contains:
.in +10
now is the time
.br
for all good men
.br
to come to the aid
.br
of their country
.in -10
.sp
and you type:
.sp
.ti 20
3r
.sp
The buffer would now contain:
.sp
.in +10
now is the time
.br
for all good men
.br
to come to the aid
.br
now is the time
.br
for all good men
.br
to come to the aid
.br
of their country
.br
of their country
.in 0
.PP
Observe that if a filename isn't specified, the editor uses the file
in the buffer.  In this example, a copy of the current file is inserted
between the 3rd and the 4th lines of text in the buffer.
.PP
Now, do the following exercises to try some of the new stuff you've
learned.
.bp
.PH "Exercises"
.L1 5 2 1
Create the following file in the editor, call it "junk."
.sp
.in 15
now is the time
.br
for all good men
.br
to come to the aid
.br
of their fellowman
.in -15
.L1
Remain in the editor and create the following file; call it "junk2".
.sp
.in 15
Attention! Attention All!
.br
now is the time
.br
not tomorrow,
.br
but today!
.br
come to the aid of your country.
.in -15
.L1
Create a file called "junk3" which contains lines 2 - 4 of "junk2".
Display "junk3".
.L1
Combine "junk" and "junk3" by placing "junk" before "junk3". Place the
combined file in "junk4". Display "junk4".
.L1
Combine "junk" and "junk2" by placing "junk" after the 3rd line of
"junk2".  Place the combined file in "junk5", display "junk5".
.L1
Leave the editor, display all 5 files, then delete them.
.E1
.sp 2
You're beginning to see the power of UNIX. But, keep on, as we
have more good things in store for you.
.bp
.PH "The Global Command"
.PP
When you learned the "s" (substitute) command, you were somewhat
disadvantaged due to the fact that only the first occurrence of
a specified string of characters on each line was modified.
Now, by using the global or "g" command in conjunction with the "s" command
each occurrence of a specified string can be modified.
.sp
.ti 13
Example:   s/programer/programmer/
.sp
will modify the first occurrence of "programer" on the current line.
On the other hand:
.sp
.ti 18
s/programer/programmer/g
.sp
will modify each occurrence of "programer" on the current line.
.PP
To modify all occurrences of a specified string within the entire
file, you must reference each line, as follows:
.sp
.ti 16
1,$s/programer/programmer/g
.sp
The "g" command can be used with the context search command also.
.PH "Examples"
.sp
.in 5
.ti -5
1.~~~g/their/p
.sp
This command will locate all lines containing "their" and will
display the last line found. The following command
.sp
.ti 26
/their/p
.sp
will locate and display only the next occurrence of "their."
.sp
.in +6
.ti -6
Note:~Use of "g" obviates the need to repeatedly type "//" in order
to locate all occurrences of a certain string. To display
each line containing the string, append a "p" to the end of
the command.
.in -6
.sp 2
.ti -5
2.~~~Let's combine context searching with the "s" and "g" commands.
It's done as follows:
.sp
.ti 20
g/programer/s//progammer/g
.sp
Here is a question to check your understanding of what was just
covered.
.sp
How can the above command be modified such that the corrected lines
are displayed? Answer in the space provided.
.sp 3
That's correct, just place a "p" after the last "g."
.in -5
.sp 2
.in 6
.ti -6
Note:~As you have probably observed, the "1,$" preceding the "s"
command, and the context search command preceding the "s"
command seem to accomplish the same result. Your
observation is correct. However, if you append a "p" to
the commands, the results would now differ. For instance,
.sp
.ti +11
1,$s/programer/programmer/gp
.sp
will display only the last modified line, whereas,
.sp
.ti +11
\g/programer/s//programmer/gp
.sp
will display each modified line.
.in 0
.PH "The~v~command"
.PP
This command is the same as the "g" command except that the commands
following the "v" are executed on every line that does not contain the
specified characters. This command:
.sp
.ti 27
v//d
.sp
will delete all lines that do not contain a blank. Got that? On the
other hand,
.sp
.ti 24
v/as/s/o/a/g
.sp
will substitute an "o" for an "a" on all lines except those containing
"as."
.PH "Special~Characters"
.PP
Unix provides several special characters which are used to simplify
the forming of character string expressions used in the "g," "v," "s,"
and context search commands. These characters are:
.sp
.tl ''^ . $ [] * & \\''
.sp
and have special meanings to the editor.
.PP
Let's get on with it and see how sophisticated you can become in
forming character string expressions.
.PH "The Circumflex "
.PP
.tr #^
The~circumflex (#) signifies the beginning of a line. By using
this symbol, you can determine whether a string of characters is at
the beginning of a line. The following command:
.tr ##
.sp
.tl ''/^the/''
.sp
will locate the first line, from the current line, beginning with
"the". What will the following locate? Answer in the space below.
.sp
.tl ''g/^the/''
.sp 3
Answer: All lines beginning with "the". If that's your answer,
very good. Now form the command to change all lines beginning in
"the" to "The".
.sp 3
Is your answer  "g/\^the/s//The/g"? If it is, you're really with it.
Let's continue.
.PH "The~Dollar~Sign~($)"
.PP
This symbol denotes just the opposite of the circumflex. It means the
end of a line.  Therefore,
.sp
.ti 28
/?$/
.sp
will locate the first line, from the current line, that ends in a "?".
.PP
All right, are you ready for this?  What is the following command being
used to locate? Answer below.
.sp
.tl ''/^attention!$/''
.sp 2
Time's up, let's see if you got this one correct.  Did you say that it
will locate a line containing only "attention!"?  That's exactly what
it will do. Or, did you say it will locate a line beginning in
"attention!" and ending in "attention!"?   I can see how you could have
come to that conclusion. However, the following explanation will clear
up any confusion. The command
.sp
.tl ''/^attention!/''
.sp
will locate a line which begins with "attention!".  That's the only
stipulation. Other characters could follow on the line, or the rest of
the line could be blank.  Whereas,
.sp
.tl ''/^attention!$/''
.sp
indicates that "attention!", which is at the beginning of
the line, is also at the end of the line with no embedded characters.
.PP
Okay, now you're probably wondering how you can locate a line containing
the same string of characters at the beginning and at the end with other
embedded characters.
.PP
The "." and the "*" can help you with that. These are your next topics
of discussion.
.PH "The~I~Don't~Care~Character"
.PP
The period (.) is used to indicate that some character must be present
at this point in the character string being searched for, and that you
don't care what the charater is. Suppose you issued
.sp
.ti 25
g/t.e/
.sp
and the buffer contains:
.sp
.in 18
Attention!
.br
now is the time
.br
for all young men
.br
to come to the aid
.br
of their country.
.in -18
.PP
In this case the system will find a match on all lines except
the third. The string matches:
.sp
.in 18
tte~~~~~~~in Attention
.br
the~~~~~~~in the
.br
the~~~~~~~in their
.in -18
.sp
You're probably thinking that this could pose a problem if you want to
locate complete words that match "t.e."  Well, it doesn't. All you have
to do is type spaces surrounding the string, like this: g/ t.e /
.PH "The Repetition Character (*)"
.PP
This symbol is used as a shorthand method of forming  character string
expressions consisting of any number of occurrences of a single character
.sp
.ti 18
Example:~~~~~/a*/
.sp
will match a string consisting of any number of a's, including no a's.
The "*" is most useful when used in conjunction with the ".", e.g.:
.sp
.ti 25
/.*/
.sp
can be used to reference an entire line. Want another example?
the command
.sp
.ti 25
s/.*/stuff/
.sp
will replace the current line by "stuff." This command,
.sp
.ti 25
s/.*,//
.sp
will delete all characters in the line up to and including the last comma,
(Since ".*" finds the longest possible match, it goes up to the last
comma.) Now can you form the search command to locate a line containing
"Attention!" at the beginning and at the end with embedded characters?
Write it below.
.sp 3
.tr {^
If your answer is: ''/{Attention!.*Attention!$/''
you're doing fine. Otherwise go back to the beginning of this section,
"Special Characters."
.sp
Okay, let's continue with more good stuff.
.PH "Character~Classes '[ ]'
.PP
I know this symbol is familiar to you, It was introduced to you before
as a "wild card" character.  Even though the name has changed, the
purpose for using it hasn't. It is used as follows:
.sp
.ti 20
/[1234567]/
.PP
Now, do you recall?  The next line containing any one of the digits will
be located and displayed.
.sp
.in 6
.ti -6
Note:~Any characters you choose may be placed inside the
brackets. For instance, the circumflex and the dollar
sign may be  used with the "[]" as follows:
.sp
.tl ''g/\{[1234567]/''
.sp
The command :
.sp
.tl ''g/\{[1234567]/''
.sp
will locate which lines? Put your answer in the space provided.
.sp 3
Did you answer any line beginning with one of the seven digits?
If so, you're in good shape.
.PH "The~Line~Repeat~Character~(&)"
.PP
This character is also used as a shorthand method of forming character
string expressions.  It is similar to the (.*) except that it is used
on the right-hand side of the 'substitute' command and refers to the context
search expression on the left. Suppose you wanted to enclose a
line in parentheses, how would you do it?  One way would be to use the
(\^) and ($), such as: '''
.sp
.nf
			 s/\{/(/
			    or
			 s/$/)/
.fi
.tr {{
.sp
An easier way would be:
.nf
			s/.*/(&)/
.fi
.sp
which means to replace the current line by itself surrounded by parentheses.
.PP
Ready for more?  The "&" may be used several times in a line. Suppose
the current line is "Now is the time," and you issue the command:
.sp
.ti 23
s/.*/&? &!!/
.sp
the results will be:
.sp
.ti 13
Now is the time ? Now is the time!!
.sp
.PP
Neat isn't it?  The "&" doesn't have to refer to the whole line.
Suppose the buffer contains:
.sp
.ti 18
the end of the world
.sp
and you type the following command:
.sp
.ti 15
/world/s//& is drawing nigh/
.sp
This will produce::
.sp
.ti 15
the end of the world is drawing nigh
.ne 10
.PH "The~Backslash~Character "
.PP
If one of the special characters has to be used in a "s" command, you
can turn off its special meaning temporarily by preceding it with the
backslash (\\). Suppose the text on the current line is ".*\\", and you
want to replace these symbols with their names, then:
.sp
.tl ''s/\\.\\*\\\\/period asterisk backslash/''
.sp
will cause the system to recognize the '.*\\' as ordinary characters.
.sp
O.K., it's time to check your understanding. Do the following exercises.
.sp 2
.bp
.PH "Exercises"
.PP
Create the following file using "ed":
.nf
.sp
The UNIX Text Editor is really a blessing in disguise for
people like you and me, whose fingers always seem to end up
on the right keys at the wrong time:
.sp
1.~Now I painlessly produce error free reports.  My boss thinks
I'm a genius because almost as quickly as he changes his mind,
I'm giving the modified report back to him;
.sp
The other day he handed me a list of things to do.  I thought,
"Oh brther, there goes my lunch," until I remembered good
ole "ed."
.sp
2.~Now, I easily correct the many errors that just seem to
pop in my reports. I can locate any string of characters, even
those with special characters such, as *,&,[, etc., in a snap.
Even locating digits (12345) presents no problem, and
copying parts of a report is done in a breeze.
.sp
Thanks UNIX for ed.
.sp
.fi
Use the above file to do the following:
.sp
.L1 5 2 1
Change all sentences that begin in "the" to "The."
.L1
Change all sentences that end in ":" or ";" to a ".".
.L1
Delete all digits from the file.
.L1
Replace each "*" with "$."
.L1
Place a "$" at the beginning of each line.
.L1
Place a "*" at the end of each line not ending in a period.
.L1
Change the last line such that it reads, "Thanks Unix for ed!
It's just what I needed."
.E1
.bp
.PH "Answers"
.PP
If you are unable to perform the above exercises, review the solutions
(commands) below.  If you still have questions please contact the instructor.
.sp 2
.in 15
1.~g/^the /s//The/gp
.sp
2. g/[:;]$/s//./gp
.sp
3. g/[1234567890]/s///gp
.sp
4. g/\\*/s//$/gp
.sp
5. g/^^/s//$/gp
.sp
6. v/\\.$/s/.*'&*'gp
.sp
~~~Observe: Since the expression following
.br
~~~the "v" isn't on the lines located the
.br
~~~first string in the "s" command can't
.br
~~~be "//".
.sp
7. $s/\\./! It's just what I needed./p
.in -15
.sp 5
All right, you've finished Module I. The commands used in this module
are listed on the next page. Look them over carefully _____ then
go back and review the objectives for Module I. When you are ready,
go on to the Module Test.

.bp
.ti 15
.PH "Summary of Commands"
.sp
.L1 5 2 1
[line-number]a~~~~~~~~~~~~~~~~(append)
.L1
[start,end]c~~~~~~~~~~~~~~~~~~(change)
.L1
[start,end]d~~~~~~~~~~~~~~~~~~(delete)
.L1
e <filename>~~~~~~~~~~~~~~~~~~(edit)
.L1
f~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(file)
.L1
g/---/commands~~~~~~~~~~~~~~~~(global)
.L1
[line-number]i~~~~~~~~~~~~~~~~(insert)
.L1
<start,end>m<line-number>~~~~~(move)
.L1
[start,end]p~~~~~~~~~~~~~~~~~~(print)
.L1
s/string1/string2/~~~~~~~~~~~~(substitute)
.L1
[line-number]r [filename]~~~~~(read)
.L1
[line-number]w [filename]~~~~~(write)
.L1
/---/~~~~~~~~~~~~~~~~~~~~~~~~~(context search)
.L1
v/---/commands~~~~~~~~~~~~~~~~(global)
.L1
?---?~~~~~~~~~~~~~~~~~~~~~~~~~(reverse context
.br
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~search)
.L1
\&.=~~~~~~~~~~~~~~~~~~~~~~~~~~~~(dot value)
.L1
q~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(quit)
.E1
.sp
Note: The period ends the "a," "c," and "i" commands.
.bp
.PH "Module I Test"
.sp
.in 4
DIRECTIONS:  The "Summary of Commands" sheet is the only aid you
can use in taking this test.  Minimum passing score is 10 of 15
correct.
.in -4
.sp
.L1 5 2 1
The command used to access the Unix Text Editor is
.L1
The command used to leave the Unix Text Editor is
.L1
______________ is the command used to create a file or add lines of
text to a file in the buffer.
.sp
.L1
The command:
.sp
.in +20
\&.c
.br
<text>
.br
\&.
.in -20
.sp
will change which line of text in the buffer?
.L1
Write the command to insert lines of text before the 3rd line in the
buffer.
.L1
Write the command to place the contents of the buffer into a file named
"temp".
.L1
Write the command used to delete lines 5 thru 10 in the buffer.
.L1
Write the command to move lines 3 thru 8 to the end of the buffer.
.L1
Write the command to change and display all lines containing the
characters "shiling" to "shilling."
.L1
Write the  command to create the file "junk" from lines 20 thru 50
of the current file.
.L1
Write the command to insert the file "junk" following the 10th line
of the current file
.L1
You are editing two files, "temp" and "hold." Write the command to place
"hold" into the buffer.
.L1
What command is used to locate all lines not containing the specified
string of characters?
.L1
What is the purpose of the following commmand:
.sp
.ti 15
g/\\./s//,/gp
.L1
".=" is used to display what marker?
.E1
.sp 3
Correct your test by using the key found on the next page.  If you miss
more than 5 questions, please review this module before continuing
to module II. Contact your instructor if you need additional help.
.bp
.PH "Answers to Module I Test"
.sp
.L1 5 2 1
.I "ed"
is the command used to access the Unix Text Editor.
.L1
.I "q"
is the command used to leave he Unix Text Editor.
.L1
.I "a"
is the command used to create a file or add lines of text to
a file in the buffer.
.L1
.I "The current~line"
in the buffer will be changed by the command:
.in +15
  c
.br
  <text>
.br
  .
.in -15
.L1
.I "3i"
(which inserts the text that follows just before the 3rd line or
"2a," which inserts the text that follows just after the 2nd line) is the
command used to insert lines of text before the 3rd line in the buffer.
.L1
.I "w~temp"
is the command used to place the contents of the buffer
into a file named "temp."
.L1
.I "5,10d"
is the command used to delete lines 5 thru 10 in the buffer.
.L1
.I "3,8m$"
is the command used to move lines 3 thru 8 to the end of the
buffer.
.L1
.I "g/shiling/s//shilling/gp"
is the command to change and display all
lines containing the characters "shiling" to "shilling."
.L1
.I "20,50w junk"
is the command used to create the file "junk" from lines
20 thru 50 of the current file.
.L1
.I "10r junk"
is the command used to insert the file "junk" following the
10th line of the current file.
.L1
.I "e hold"
is the command used to place the file "hold" into the buffer.
.L1
.I "v"
is the command used to locate all lines not containing a specified
string of characters.
.L1
.I "To change all periods to commas and display the results"
is the purpose of the command: g/\\./s//,/gp.
.L1
.I "The current line number"
is displayed by .= .
.E1
