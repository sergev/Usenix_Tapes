.TH SFT 3X CIRES
.EQ
delim $$
.EN
.SH NAME
.PP
sft \- slow fourier transform
.SH SYNOPSIS
.PP
\fBcall sft(x,n,omn,dom,nfr,st,ct)
.PP
\fBinteger*2 n, nfr
.PP
\fBreal x(n), omn, dom, st(nfr), ct(nfr)\fR
.PP
f77 flag: \fB-lCm\fR
.SH DESCRIPTION
.PP
If the fourier transform of a series is required
at only a few frequencies,
it may be cheaper to compute it directly
than with a fast fourier transform (FFT).
Also, FFT algorithims give the fourier
transform at frequencies which are multiples
of $( N DELTA t ) sup -1$,
where $DELTA t $ is the sampling interval and $N$
is the series length, which must be a highly composite number.
A direct computation is useful for finding the transform
at other frequencies.
This program computes the fourier transform of a series
\fBx\fR directly,
using a recursive (Goertzal) algorithim,
modified for increased numerical stability.
The arguments are:
.IP \fBx\fR
array whose transform is to be found.
.IP \fBn\fR
length of \fBx\fR.
.IP \fBomn\fR
first frequency at which the transform is to be computed
($omega sub 0$),
normalized in units of $DELTA t sup -1$
(in these units, the Nyquist frequency is $half$).
.IP \fBdom\fR
frequency spacing ($DELTA omega$), in the same units as \fBomn\fR.
.IP \fBst\fR
array of sine transforms.
.IP \fBct\fR
array of cosine transforms.
.PP
The transform computed is such that the $l$-th elements of
\fBst\fR and \fBct\fR are given by
.sp 1
.EQ
bold ct (l) ~+~i bold st (l) ~~=~~ sum from k=0 to k=N-1~
bold x (k) e sup{ -2 pi ik ( omega sub 0 + (l-1) DELTA omega ) }
.EN
.SH AUTHOR
.PP
D. C. Agnew (CIRES)
.SH SPONSOR
.PP
D. C. Agnew (CIRES)
