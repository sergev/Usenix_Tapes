Info file emacs, produced by texinfo-format-buffer   -*-Text-*-
from file emacs.tex

This file documents the GNU Emacs editor.

Copyright (C) 1985, 1986 Richard M. Stallman.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU Emacs
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU Emacs General Public License" may be included in a translation
approved by the author instead of in the original English.


File: emacs  Node: Using Region, Prev: Setting Mark, Up: Mark, Next: Marking Objects

Operating on the Region
=======================

  Once you have created an active region, you can do many things to
the text in it:
   * Kill it with `C-w' (*Note Killing::).
   * Save it in a register with `C-x x' (*Note Registers::).
   * Save it in a buffer or a file (*Note Accumulating Text::).
   * Convert case with `C-x C-l' or `C-x C-u' (*Note Case::).
   * Evaluate it as Lisp code with `M-x eval-region' (*Note Lisp Eval::).
   * Fill it as text with `M-g' (*Note Filling::).
   * Print hardcopy with `M-x print-region' (*Note Hardcopy::).
   * Indent it with `C-x TAB' or `C-M-\' (*Note Indentation::).


File: emacs  Node: Marking Objects, Prev: Using Region, Up: Mark, Next: Mark Ring

Commands to Mark Textual Objects
================================

  There are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'     
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.
`C-M-@'     
     Set mark after end of next Lisp expression (`mark-sexp').
`M-h'     
     Put region around current paragraph (`mark-paragraph').
`C-M-h'     
     Put region around current Lisp defun (`mark-defun').
`C-x h'     
     Put region around entire buffer (`mark-whole-buffer').
`C-x C-p'     
     Put region around current page (`mark-page').

`M-@' (`mark-word') puts the mark at the end of the next word,
while `C-M-@' (`mark-sexp') puts it at the end of the next Lisp
expression.  These characters allow you to save a little typing or
redisplay, sometimes.

   Other commands set both point and mark, to delimit an object in the
buffer.  `M-h' (`mark-paragraph') moves point to the beginning of
the paragraph that surrounds or follows point, and puts the mark at the end
of that paragraph (*Note Paragraphs::).  `M-h' does all that's
necessary if you wish to indent, case-convert, or kill a whole paragraph.
`C-M-h' (`mark-defun') similarly puts point before and the mark
after the current or following defun (*Note Defuns::).  `C-x C-p'
(`mark-page') puts point before the current page (or the next or
previous, according to the argument), and mark at the end (*Note Pages::).
The mark goes after the terminating page delimiter (to include it), while
point goes after the preceding page delimiter (to exclude it).  Finally,
`C-x h' (`mark-whole-buffer') sets up the entire buffer as the
region, by putting point at the beginning and the mark at the end.


File: emacs  Node: Mark Ring, Prev: Marking Objects, Up: Mark

The Mark Ring
=============

  Aside from delimiting the region, the mark is also useful for remembering
a spot that you may want to go back to.  To make this feature more useful,
Emacs remembers 16 previous locations of the mark, in the "mark ring".
Most commands that set the mark push the old mark onto this ring.  To
return to a marked location, use `C-u C-SPC' (or `C-u C-@'); this is
the command `set-mark-command' given a numeric argument.  It moves
point to where the mark was, and restores the mark from the ring of former
marks.  So repeated use of this command moves point to all of the old marks
on the ring, one by one.  The marks you see go to the end of the ring,
so no marks are lost.

  Each buffer has its own mark ring.  All editing commands use the current
buffer's mark ring.  In particular, `C-u C-SPC' always stays in
the same buffer.

  Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This is to make it easier for you to move back
later.  Searches do this except when they do not actually move point.  You
can tell when a command sets the mark because `Mark Set' is printed in
the echo area.

  The variable `mark-ring-max' is the maximum number of entries to
keep in the mark ring.  If that many entries exist and another one is
pushed, the last one in the list is discarded.  Repeating `C-u
C-SPC' circulates through the limited number of entries that are
currently in the ring.

  The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.



File: emacs  Node: Killing, Prev: Mark, Up: Top, Next: Yanking

Deletion and Killing
====================

  Most commands which erase text from the buffer save it so that you can
get it back if you change your mind, or move or copy it to other parts of
the buffer.  These commands are known as "kill" commands.  The rest of
the commands that erase text do not save it; they are known as "delete"
commands.  (This distinction is made only for erasure of text in the
buffer.)

  The delete commands include `C-d' (`delete-char') and DEL
(`delete-backward-char'), which delete only one character at a time, and
those commands that delete only spaces or newlines.  Commands that can
destroy significant amounts of nontrivial data generally kill.  The
commands' names and individual descriptions use the words `kill' and
`delete' to say which they do.  If you do a kill or delete command by
mistake, you can use the `C-x u' (`undo') command to undo it (*Note
Undo::).


Deletion
--------

`C-d'     
     Delete next character (`delete-char').
`DEL'     
     Delete previous character (`delete-backward-char').
`M-\'     
     Delete spaces and tabs around point (`delete-horizontal-space').
`M-SPC'     
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').
`C-x C-o'     
     Delete blank lines around the current line (`delete-blank-lines').
`M-^'     
     Join two lines by deleting the intervening newline, and any indentation
     following it (`delete-indentation').

  The most basic delete commands are `C-d' (`delete-char') and
DEL (`delete-backward-char').  `C-d' deletes the character
after point, the one the cursor is "on top of".  Point doesn't move.
DEL deletes the character before the cursor, and moves point back.
Newlines can be deleted like any other characters in the buffer; deleting a
newline joins two lines.  Actually, `C-d' and DEL aren't always
delete commands; if given an argument, they kill instead, since they can
erase more than one character this way.

  The other delete commands are those which delete only formatting
characters: spaces, tabs and newlines.  `M-\' (`delete-horizontal-space')
deletes all the spaces and tab characters before and after point.
`M-SPC' (`just-one-space') does likewise but leaves a single
space after point, regardless of the number of spaces that existed
previously (even zero).

  `C-x C-o' (`delete-blank-lines') deletes all blank lines after
the current line, and if the current line is blank deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).  `M-^' (`delete-indentation') joins the current line and
the previous line, or the current line and the next line if given an
argument, by deleting a newline and all surrounding spaces, possibly
leaving a single space.  *Note M-^: Indentation.


Killing by Lines
----------------

`C-k'     
     Kill rest of line or one or more lines (`kill-line').

  The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving it blank.  If given on a
blank line, the blank line disappears.  As a consequence, if you go to the
front of a non-blank line and type `C-k' twice, the line disappears
completely.

  More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following the line, thus merging the next line into the current one.
Invisible spaces and tabs at the end of the line are ignored when deciding
which case applies, so if point appears to be at the end of the line, you
can be sure the newline will be killed.

  If `C-k' is given a positive argument, it kills that many lines and
the newlines that follow them (however, text on the current line before
point is spared).  With a negative argument, it kills back to a number of
line beginnings.  An argument of -2 means kill back to the second line
beginning.  If point is at the beginning of a line, that line beginning
doesn't count, so `C-u - 2 C-k' with point at the front of a line kills
the two previous lines.

  `C-k' with an argument of zero kills all the text before point on the
current line.


Other Kill Commands
-------------------

`C-w'     
     Kill region (from point to the mark) (`kill-region').
     *Note Words::.
`M-d'     
     Kill word (`kill-word').
`M-DEL'     
     Kill word backwards (`backward-kill-word').
`C-x DEL'     
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.
`M-k'     
     Kill to end of sentence (`kill-sentence').
`C-M-k'     
     Kill sexp (`kill-sexp').  *Note Lists::.
`M-z CHAR'     
     Kill up to next occurrence of CHAR (`zap-to-char').

  A kill command which is very general is `C-w' (`kill-region'),
which kills everything between point and the mark.  With this command, you
can kill any contiguous sequence of characters, if you first set the mark
at one end of them and go to the other end.

  A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (but not
including) the next occurrence of that character in the buffer.  If there
is no next occurrence, killing goes to the end of the buffer.  A numeric
argument acts as a repeat count.  A negative argument means to search
backward and kill text before point.

  Other syntactic units can be killed: words, with `M-DEL' and `M-d' (*Note
Words::); sexps, with `C-M-k' (*Note Lists::); and sentences, with `C-x
DEL' and `M-k' (*Note Sentences::).


File: emacs  Node: Yanking, Prev: Killing, Up: Top, Next: Accumulating Text

Yanking
=======

  "Yanking" is getting back text which was killed.  This is what some
systems call "pasting".  The usual way to move or copy text is to kill it
and then yank it one or more times.

`C-y'     
     Yank last killed text (`yank').
`M-y'     
     Replace re-inserted killed text with the previously killed text
     (`yank-pop').
`M-w'     
     Save region as last killed text without actually killing it
     (`copy-region-as-kill').
`C-M-w'     
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.


File: emacs  Node: Kill Ring, Prev: Yanking, Up: Yanking, Next: Appending Kills

The Kill Ring
-------------

  All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another buffer.
This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

  The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  *Note Mark::.

  `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This is only if the argument is specified with just a `C-u',
precisely.  Any other sort of argument, including `C-u' and digits, has
an effect described below (under "Yanking Earlier Kills").

  If you wish to copy a block of text, you might want to use `M-w'
(`copy-region-as-kill'), which copies the region into the kill ring
without removing it from the buffer.  This is approximately equivalent to
`C-w' followed by `C-y', except that `M-w' does not mark the
buffer as "modified" and does not temporarily change the screen.


File: emacs  Node: Appending Kills, Prev: Kill Ring, Up: Yanking, Next: Earlier Kills

Appending Kills
---------------

  Normally, each kill command pushes a new block onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' gets it all back as it was before
it was killed.  This means that you don't have to kill all the text in one
command; you can keep killing line after line, or word after word, until
you have killed it all, and you can still get it all back at once.  (Thus
we join television in leading people to kill thoughtlessly.)

  Commands that kill forward from point add onto the end of the previous
killed text.  Commands that kill backward from point add onto the
beginning.  This way, any sequence of mixed forward and backward kill
commands puts all the killed text into one entry without rearrangement.
Numeric arguments do not break the sequence of appending kills.  For
example, suppose the buffer contains

     This is the first
     line of sample text
     and here is the third.

with point at the beginning of the second line.  If you type `C-k C-u 2
M-DEL C-k', the first `C-k' kills the text `line of sample
text', `C-u 2 M-DEL' kills `the first' with the newline that
followed it, and the second `C-k' kills the newline after the second
line.  The result is that the buffer contains `This is and here is the
third.' and a single kill entry contains `the firstRETline of
sample textRET'---all the killed text, in its original order.

  If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command `C-M-w'
(`append-next-kill') in front of it.  The `C-M-w' tells the following
command, if it is a kill command, to append the text it kills to the last
killed text, instead of starting a new entry.  With `C-M-w', you can kill
several separated pieces of text and accumulate them to be yanked back in
one place.


File: emacs  Node: Earlier Kills, Prev: Appending Kills, Up: Yanking

Yanking Earlier Kills
---------------------

  To recover killed text that is no longer the most recent kill, you need
the `Meta-y' (`yank-pop') command.  `M-y' can be used only after a `C-y' or
another `M-y'.  It takes the text previously yanked and replaces it with
the text from an earlier kill.  So, to recover the text of the
next-to-the-last kill, you first use `C-y' to recover the last kill, and
then use `M-y' to replace it with the previous kill.

  You can think in terms of a "last yank" pointer which points at an item
in the kill ring.  Each time you kill, the "last yank" pointer moves to
the newly made item at the front of the ring.  `C-y' yanks the item
which the "last yank" pointer points to.  `M-y' moves the "last
yank" pointer to a different item, and the text in the buffer changes to
match.  Enough `M-y' commands can move the pointer to any item in the
ring, so you can get any item into the buffer.  Eventually the pointer
reaches the end of the ring; the next `M-y' moves it to the first item
again.

  Yanking moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

  `M-y' can take a numeric argument, which tells it how many items to
advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it moves
to the last entry and starts moving forward from there.

  Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring item, so editing it in the buffer does not change what's in
the ring.  As long as no new killing is done, the "last yank" pointer
remains at the same place in the kill ring, so repeating `C-y' will
yank another copy of the same old kill.

  If you know how many `M-y' commands it would take to find the
text you want, you can yank that text in one step using `C-y' with
a numeric argument.  `C-y' with an argument greater than one
restores the text the specified number of entries back in the kill
ring.  Thus, `C-u 2 C-y' gets the next to the last block of killed
text.  It is equivalent to `C-y M-y'.  `C-y' with a numeric
argument starts counting from the "last yank" pointer, and sets the
"last yank" pointer to the entry that it yanks.

  The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are
saved.


File: emacs  Node: Accumulating Text, Prev: Yanking, Up: Top, Next: Rectangles

Accumulating Text
=================

  Usually we copy or move text by killing it and yanking it, but there are
other ways that are useful for copying one block of text in many places, or
for copying many scattered blocks of text into one place.

  You can accumulate blocks of text from scattered locations either into a
buffer or into a file if you like.  These commands are described here.  You
can also use Emacs registers for storing and accumulating text.
*Note Registers::.

`C-x a'     
     Append region to contents of specified buffer (`append-to-buffer').
`M-x prepend-to-buffer'     
     Prepend region to contents of specified buffer.
`M-x copy-to-buffer'     
     Copy region into specified buffer, deleting that buffer's old contents.
`M-x insert-buffer'     
     Insert contents of specified buffer into current buffer at point.
`M-x append-to-file'     
     Append region to contents of specified file, at the end.

  To accumulate text into a buffer, use the command `C-x a BUFFERNAME'
(`append-to-buffer'), which inserts a copy of the region into the
buffer BUFFERNAME, at the location of point in that buffer.  If there
is no buffer with that name, one is created.  If you append text into a
buffer which has been used for editing, the copied text goes into the
middle of the text of the buffer, wherever point happens to be in it.

  Point in that buffer is left at the end of the copied text, so successive
uses of `C-x a' accumulate the text in the specified buffer in the same
order as they were copied.  Strictly speaking, `C-x a' does not always
append to the text already in the buffer; but if `C-x a' is the only
command used to alter a buffer, it does always append to the existing text
because point is always at the end.

  `M-x prepend-to-buffer' is just like `C-x a' except that point in
the other buffer is left before the copied text, so successive prependings
add text in reverse order.  `M-x copy-to-buffer' is similar except that
any existing text in the other buffer is deleted, so the buffer is left
containing just the text newly copied into it.

  You can retrieve the accumulated text from that buffer with `M-x
insert-buffer'; this too takes BUFFERNAME as an argument.  It inserts
a copy of the text in buffer BUFFERNAME into the selected buffer.
You could alternatively select the other buffer for editing, perhaps moving
text from it by killing or with `C-x a'.  *Note Buffers::, for
background information on buffers.

  Instead of accumulating text within Emacs, in a buffer, you can append
text directly into a file with `M-x append-to-file', which takes
FILE-NAME as an argument.  It adds the text of the region to the end
of the specified file.  The file is changed immediately on disk. This
command is normally used with files that are not being visited in
Emacs.  Using it on a file that Emacs is visiting can produce confusing
results, because the text inside Emacs for that file will not change
while the file itself changes.


File: emacs  Node: Rectangles, Prev: Accumulating Text, Up: Top, Next: Registers

Rectangles
==========

  The rectangle commands affect rectangular areas of the text: all the
characters between a certain pair of columns, in a certain range of lines.
Commands are provided to kill rectangles, yank killed rectangles, clear
them out, or delete them.  Rectangle commands are useful with text in
multicolumnar formats, such as perhaps code with comments at the right,
or for changing text into or out of such formats.

  When you must specify a rectangle for a command to work on, you do
it by putting the mark at one corner and point at the opposite corner.
The rectangle thus specified is called the "region-rectangle"
because it is controlled about the same way the region is controlled.
But remember that a given combination of point and mark values can be
interpreted either as specifying a region or as specifying a
rectangle; it is up to the command that uses them to choose the
interpretation.

`M-x delete-rectangle'     
     Delete the text of the region-rectangle, moving any following text on
     each line leftward to the left edge of the region-rectangle.
`M-x kill-rectangle'     
     Similar, but also save the contents of the region-rectangle as the
     "last killed rectangle".
`M-x yank-rectangle'     
     Yank the last killed rectangle with its upper left corner at point.
`M-x open-rectangle'     
     Insert blank space to fill the space of the region-rectangle.
     The previous contents of the region-rectangle are pushed rightward.
`M-x clear-rectangle'     
     Clear the region-rectangle by replacing its contents with spaces.

  The rectangle operations fall into two classes: commands deleting and
moving rectangles, and commands for blank rectangles.

  There are two ways to get rid of the text in a rectangle: you can discard
the text (delete it) or save it as the "last killed" rectangle.  The
commands for these two ways are `M-x delete-rectangle' and `M-x
kill-rectangle'.  In either case, the portion of each line that falls inside
the rectangle's boundaries is deleted, causing following text (if any) on
the line to move left.

  Note that "killing" a rectangle is not killing in the usual sense; the
rectangle is not stored in the kill ring, but in a special place that
can only record the most recent rectangle killed.  This is because yanking
a rectangle is so different from yanking linear text that different yank
commands have to be used and yank-popping is hard to make sense of.

  Inserting a rectangle is the opposite of deleting one.  All you need to
specify is where to put the upper left corner; that is done by putting
point there.  The rectangle's first line is inserted there, the rectangle's
second line is inserted at a point one line vertically down, and so on.
The number of lines affected is determined by the height of the saved
rectangle.

  To insert the last killed rectangle, type `M-x yank-rectangle'.
This can be used to convert single-column lists into double-column
lists; kill the second half of the list as a rectangle and then
yank it beside the first line of the list.

  There are two commands for working with blank rectangles: `M-x
clear-rectangle' to blank out existing text, and `M-x open-rectangle'
to insert a blank rectangle.  Clearing a rectangle is equivalent to
deleting it and then inserting as blank rectangle of the same size.

  Rectangles can also be copied into and out of registers.
*Note Rectangle Registers: RegRect.


File: emacs  Node: Registers, Prev: Rectangles, Up: Top, Next: Display

Registers
*********

  Emacs "registers" are places you can save text or positions for
later use.  Text saved in a register can be copied into the buffer
once or many times; a position saved in a register is used by moving
point to that position.  Rectangles can also be copied into and out of
registers (*Note Rectangles::).

  Each register has a name, which is a single character.  A register can
store either a piece of text or a position or a rectangle, but only one
thing at any given time.  Whatever you store in a register remains
there until you store something else in that register.

* Menu:

* RegPos::    Saving positions in registers.
* RegText::   Saving text in registers.
* RegRect::   Saving rectangles in registers.

`M-x view-register RET R'     
     Display a description of what register R contains.

  `M-x view-register' reads a register name as an argument and then
displays the contents of the specified register.


File: emacs  Node: RegPos, Prev: Registers, Up: Registers, Next: RegText

Saving Positions in Registers
=============================

  Saving a position records a spot in a buffer so that you can move
back there later.  Moving to a saved position reselects the buffer
and moves point to the spot.

`C-x / R'     
     Save location of point in register R (`point-to-register').
`C-x j R'     
     Jump to the location saved in register R (`register-to-point').

  To save the current location of point in a register, choose a name R and
type `C-x / R'.  The register R retains the location thus saved until you
store something else in that register.

  The command `C-x j R' moves point to the location recorded
in register R.  The register is not affected; it continues to
record the same location.  You can jump to the same position using the
same register any number of times.


File: emacs  Node: RegText, Prev: RegPos, Up: Registers, Next: RegRect

Saving Text in Registers
========================

  When you want to insert a copy of the same piece of text frequently, it
may be impractical to use the kill ring, since each subsequent kill moves
the piece of text further down on the ring.  It becomes hard to keep track
of what argument is needed to retrieve the same text with `C-y'.  An
alternative is to store the text in a register with `C-x x'
(`copy-to-register') and then retrieve it with `C-x g'
(`insert-register').

`C-x x R'     
     Copy region into register R (`copy-to-register').
`C-x g R'     
     Insert text contents of register R (`insert-register').

  `C-x x R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x x' deletes the
text from the buffer as well.

  `C-x g R' inserts in the buffer the text from register R.
Normally it leaves point before the text and places the mark after, but
with a numeric argument it puts point after the text and the mark before.


File: emacs  Node: RegRect, Prev: RegText, Up: Registers

Saving Rectangles in Registers
==============================

  A register can contain a rectangle instead of linear text.  The rectangle
is represented as a list of strings.  *Note Rectangles::, for basic
information on rectangles and how rectangles in the buffer are specified.

`C-x r R'     
     Copy the region-rectangle into register R (`copy-region-to-rectangle').
     With numeric argument, delete it as well.
`C-x g R'     
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

  The `C-x g' command inserts linear text if the register contains
that, or inserts a rectangle if the register contains one.


File: emacs  Node: Display, Prev: Registers, Up: Top, Next: Search

Controlling the Display
***********************

  Since only part of a large buffer fits in the window, Emacs tries to show
the part that is likely to be interesting.  The display control commands
allow you to specify which part of the text you want to see.

`C-l'     
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').
`C-v'     
     Scroll forward (a windowful or a specified number of lines) (`scroll-up').
`M-v'     
     Scroll backward (`scroll-down').
`ARG C-l'     
     Scroll so point is on line ARG (`recenter').
`C-x <'     
     Scroll text in current window to the left (`scroll-left').
`C-x >'     
     Scroll to the right (`scroll-right').
`C-x $'     
     Make deeply indented lines invisible (`set-selective-display').

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Display Vars::           Information on variables for customizing display.


File: emacs  Node: Scrolling, Prev: Display, Up: Display, Next: Horizontal Scrolling

Scrolling
=========

  If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous section of
the text.  The section shown always contains point.

  "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means that text
moves up, and new text appears at the bottom.  Scrolling backward moves
text down and new text appears at the top.

  Scrolling happens automatically if you move point past the bottom or top
of the window.  You can also explicitly request scrolling with the commands
in this section.


`C-l'     
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').
`C-v'     
     Scroll forward (a windowful or a specified number of lines) (`scroll-up').
`M-v'     
     Scroll backward (`scroll-down').
`ARG C-l'     
     Scroll so point is on line ARG (`recenter').

  The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire screen and redisplays all windows.  In
addition, the selected window is scrolled so that point is halfway down
from the top of the window.

  The scrolling commands `C-v' and `M-v' let you move all the text in the
window up or down a few lines.  `C-v' (`scroll-up') with an argument shows
you that many more lines at the bottom of the window, moving the text and
point up together as `C-l' might.  `C-v' with a negative argument shows you
more lines at the top of the window.  `Meta-v' (`scroll-down') is like
`C-v', but moves in the opposite direction.

  To read the buffer a windowful at a time, use `C-v' with no argument.
It takes the last two lines at the bottom of the window and puts them at
the top, followed by nearly a whole windowful of lines not previously
visible.  If point was in the text scrolled off the top, it moves to the
new top of the window.  `M-v' with no argument moves backward with
overlap similarly.  The number of lines of overlap across a `C-v' or
`M-v' is controlled by the variable `next-screen-context-lines'; by
default, it is two.

  Another way to do scrolling is with `C-l' with a numeric argument.
`C-l' does not clear the screen when given an argument; it only scrolls
the selected window.  With a positive argument N, it repositions text
to put point N lines down from the top.  An argument of zero puts
point on the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the screen.  `C-l' with a
negative argument puts point that many lines from the bottom of the window.
For example, `C-u - 1 C-l' puts point on the bottom line, and `C-u
- 5 C-l' puts it five lines from the bottom.  Just `C-u' as argument,
as in `C-u C-l', scrolls point to the center of the screen.

  Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually the scrolling is
done so as to put point vertically centered within the window.  However, if
the variable `scroll-step' has a nonzero value, an attempt is made to
scroll the buffer by that many lines; if that is enough to bring point back
into visibility, that is what is done.


File: emacs  Node: Horizontal Scrolling, Prev: Scrolling, Up: Display

Horizontal Scrolling
====================


`C-x <'     
     Scroll text in current window to the left (`scroll-left').
`C-x >'     
     Scroll to the right (`scroll-right').

  The text in a window can also be scrolled horizontally.  This means that
each line of text is shifted sideways in the window, and one or more
characters at the beginning of each line are not displayed at all.  When a
window has been scrolled horizontally in this way, text lines are truncated
rather than continued (*Note Continuation Lines::), with a `$' appearing
in the first column when there is text truncated to the left, and in the
last column when there is text truncated to the right.

  The command `C-x <' (`scroll-left') scrolls the selected window
to the left by N columns with argument N.  With no argument, it scrolls
by almost the full width of the window (two columns less, to be precise).
`C-x >' (`scroll-right') scrolls similarly to the right.
The window cannot be scrolled any farther to the right once it is
displaying normally (with each line starting at the window's left margin);
attempting to do so has no effect.


File: emacs  Node: Selective Display, Prev: Display, Up: Display, Next: Display Vars

Selective Display
=================

  Emacs has the ability to hide lines indented more than a certain number
of columns (you specify how many columns).  You can use this to get an
overview of a part of a program.

  To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  (*Note Arguments::, for how to give the argument.)  Then lines
with at least N columns of indentation disappear from the screen.  The only
indication of their presence is that three dots (`...') appear at the end
of each visible line that is followed by one or more invisible ones.

  The invisible lines are still present in the buffer, and most editing
commands see them as usual, so it is very easy to put point in the middle
of invisible text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the visible
line, before the newline that ends it, the cursor appears before the three
dots.

  The commands `C-n' and `C-p' move across the invisible lines as if they
were not there.

  To make everything visible again, type `C-x $' with no argument.


File: emacs  Node: Display Vars, Prev: Selective Display, Up: Display

Variables Controlling Display
=============================
 
  This section contains information for customization only.  Beginning
users should skip it.

  The variable `mode-line-inverse-video' controls whether the mode
line is displayed in inverse video (assuming the terminal supports it);
`nil' means don't do so.  *Note Mode Line::.

  If the variable `inverse-video' is non-`nil', Emacs attempts
to invert all the lines of the display from what they normally are.

  If the variable `visible-bell' is non-`nil', Emacs attempts to make the
whole screen blink when it would normally make an audible bell sound.  This
variable has no effect if your terminal does not have a way to make the
screen blink.

  When you reenter Emacs after suspending, Emacs normally clears the screen
and redraws the entire display.  On some terminals with more than one page
of memory, it is possible to arrange the termcap entry so that the
`ti' and `te' strings (output to the terminal when Emacs is
entered and exited, respectively) switch between pages of memory so as to
use one page for Emacs and another page for other output.  Then you might
want to set the variable `no-redraw-on-reenter' non-`nil' so that
Emacs will assume, when resumed, that the screen page it is using still
contains what Emacs last wrote there.

  The variable `echo-keystrokes' controls the echoing of multi-character
keys; its value is the number of seconds of pause required to cause echoing
to start, or zero meaning don't echo at all.  *Note Echo Area::.

  If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, all except newline and
tab.  Altering the value of `ctl-arrow' makes it local to the current
buffer; until that time, the default value is in effect.  The default is
initially `t'.  *Note Locals::.

  Normally, a tab character in the buffer is displayed as whitespace which
extends to the next display tab stop position, and display tab stops come
at intervals equal to eight spaces.  The number of spaces per tab is
controlled by the variable `tab-width', which is made local by
changing it, just like `ctl-arrow'.  Note that how the tab character
in the buffer is displayed has nothing to do with the definition of
TAB as a command.

  If you set the variable `selective-display-ellipses' to `nil',
the three dots do not appear at the end of a line that precedes invisible
lines.  Then there is no visible indication of the invisible lines.
This variable too becomes local automatically when set.


File: emacs  Node: Search, Prev: Display, Up: Top, Next: Fixit

Searching and Replacement
*************************

  Like other editors, Emacs has commands for searching for occurrences of
a string.  The principal search command is unusual in that it is
"incremental"; it begins to search before you have finished typing the
search string.  There are also nonincremental search commands more like
those of other editors.

  Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a fancy
replacement command called `query-replace' which asks interactively
which occurrences to replace.

* Menu:

* Incremental Search::     Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::            Search for sequence of words.
* Regexp Search::          Search for match for a regexp.
* Regexps::                Syntax of regular expressions.
* Search Case::            To ignore case while searching, or not.
* Replace::                Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.


File: emacs  Node: Incremental Search, Prev: Search, Up: Search, Next: Nonincremental Search

Incremental Search
==================

  An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) would be found.
When you have typed enough characters to identify the place you want, you
can stop.  Depending on what you will do next, you may or may not need to
terminate the search explicitly with an ESC first.

`C-s'     
     Incremental search forward (`isearch-forward').
`C-r'     
     Incremental search backward (`isearch-backward').

  `C-s' starts an incremental search.  `C-s' reads characters from the
keyboard and positions the cursor at the first occurrence of the characters
that you have typed.  If you type `C-s' and then `F', the cursor moves
right after the first `F'.  Type an `O', and see the cursor move to after
the first `FO'.  After another `O', the cursor is after the first `FOO'
after the place where you started the search.  Meanwhile, the search string
`FOO' has been echoed in the echo area.

  The echo area display ends with three dots when actual searching is going
on.  When search is waiting for more input, the three dots are removed.
(On slow terminals, the three dots are not displayed.)

  If you make a mistake in typing the search string, you can erase
characters with DEL.  Each DEL cancels the last character of search string.
This does not happen until Emacs is ready to read another input character;
first it must either find, or fail to find, the character you want to
erase.  If you do not want to wait for this to happen, use `C-g' as
described below.

  When you are satisfied with the place you have reached, you can type
ESC, which stops searching, leaving the cursor where the search
brought it.  Also, any command not specially meaningful in searches stops
the searching and is then executed.  Thus, typing `C-a' would exit the
search and then move to the beginning of the line.  ESC is necessary
only if the next command you want to type is a printing character,
DEL, ESC, or another control character that is special within
searches (`C-q', `C-w', `C-r', `C-s' or `C-y').

  Sometimes you search for `FOO' and find it, but not the one you
expected to find.  There was a second `FOO' that you forgot about,
before the one you were looking for.  In this event, type another `C-s'
to move to the next occurrence of the search string.  This can be done any
number of times.  If you overshoot, you can cancel some `C-s'
characters with DEL.

  After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again".

  If your string is not found at all, the echo area says `Failing
I-Search'.  The cursor is after the place where Emacs found as much of your
string as it could.  Thus, if you search for `FOOT', and there is no
`FOOT', you might see the cursor after the `FOO' in `FOOL'.
At this point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the place
you have found, you can type ESC or some other Emacs command to
"accept what the search offered".  Or you can type `C-g', which
removes from the search string the characters that could not be found (the
`T' in `FOOT'), leaving those that were found (the `FOO' in
`FOOT').  A second `C-g' at that point cancels the search
entirely, returning point to where it was when the search started.

  If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating
a failing reverse search with `C-r' starts again from the end.  This
is called "wrapping around".  `Wrapped' appears in the search
prompt once this has happened.

  The `C-g' "quit" character does special things during searches;
just what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search.  The cursor moves back to where you started the search.  If
`C-g' is typed when there are characters in the search string that have
not been found---because Emacs is still searching for them, or because it
has failed to find them---then the search string characters which have not
been found are discarded from the search string.  With them gone, the
search is now successful and waiting for more input, so a second `C-g'
will cancel the entire search.

  To search for a control character such as `C-s' or DEL or ESC,
you must quote it by typing `C-q' first.  This function of `C-q' is
analogous to its meaning as an Emacs command: it causes the following
character to be treated the way a graphic character would normally be
treated in the same context.

  You can change to searching backwards with `C-r'.  If a search fails
because the place you started was too late in the file, you should do this.
Repeated `C-r' keeps looking for more occurrences backwards.  A
`C-s' starts going forwards again.  `C-r' in a search can be cancelled
with DEL.

  If you know initially that you want to search backwards, you can
use `C-r' instead of `C-s' to start the search, because `C-r'
is also a key running a command (`isearch-backward') to search
backward.

  The characters `C-y' and `C-w' can be used in incremental search
to grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the word after point as part of the search string, advancing
point over that word.  Another `C-s' to repeat the search will then
search for a string including that word.  `C-y' is similar to `C-w'
but copies all the rest of the current line into the search string.

  All the characters special in incremental search can be changed by setting
the following variables:

`search-delete-char'     
     Character to delete from incremental search string (normally DEL).
`search-exit-char'     
     Character to exit incremental search (normally ESC).
`search-quote-char'     
     Character to quote special characters for incremental search (normally
     `C-q').
`search-repeat-char'     
     Character to repeat incremental search forwards (normally `C-s').
`search-reverse-char'     
     Character to repeat incremental search backwards (normally `C-r').
`search-yank-line-char'     
     Character to pull rest of line from buffer into search string
     (normally `C-y').
`search-yank-word-char'     
     Character to pull next word from buffer into search string (normally
     `C-w').


Slow Terminal Incremental Search
--------------------------------

  Incremental search on a slow terminal uses a modified style of display
that is designed to take less time.  Instead of redisplaying the buffer at
each place the search gets to, it creates a new single-line window and uses
that to display the line that the search has found.  The single-line window
comes into play as soon as point gets outside of the text that is already
on the screen.

  When the search is terminated, the single-line window is removed.  Only
at this time is the window in which the search was done redisplayed to show
its new value of point.

  The three dots at the end of the search string, normally used to indicate
that searching is going on, are not displayed in slow style display.

  The slow terminal style of display is used when the terminal baud rate is
less than or equal to the value of the variable `search-slow-speed',
initially 1200.

  The number of lines to use in slow terminal search display is controlled
by the variable `search-slow-window-lines'.  1 is its normal value.


File: emacs  Node: Nonincremental Search, Prev: Incremental Search, Up: Search, Next: Word Search

Nonincremental Search
=====================

  Emacs also has conventional nonincremental search commands, which require
you to type the entire search string before searching begins.

`C-s ESC STRING RET'     
     Search for STRING.
`C-r ESC STRING RET'     
     Search backward for STRING.

  To do a nonincremental search, first type `C-s ESC'.  This
enters the minibuffer to read the search string; terminate the string with
RET, and then the search is done.  If the string is not found the
search command gets an error.

  The way `C-s ESC' works is that the `C-s' invokes
incremental search, which is specially programmed to invoke nonincremental
search if the argument you give it is empty.  (Such an empty argument would
otherwise be useless.)  `C-r ESC' also works this way.

  Forward and backward nonincremental searches are implemented by the
commands `search-forward' and `search-backward'.  These commands
may be bound to keys in the usual manner.  The reason that incremental
search is programmed to invoke them as well is that `C-s ESC'
is the traditional sequence of characters used in Emacs to invoke
nonincremental search.

  However, nonincremental searches performed using `C-s ESC' do
not call `search-forward' right away.  The first thing done is to see
if the next character is `C-w', which requests a word search.

*Note Word Search::.


File: emacs  Node: Word Search, Prev: Nonincremental Search, Up: Search, Next: Regexp Search

Word Search
===========

  Word search searches for a sequence of words without regard to how the
words are separated.  More precisely, you type a string of many words,
using single spaces to separate them, and the string can be found even if
there are multiple spaces, newlines or other punctuation between the words.

  Word search is useful in editing documents formatted by text formatters.
If you edit while looking at the printed, formatted version, you can't tell
where the line breaks are in the source file.  With word search, you can
search without having to know them.

`C-s ESC C-w WORDS RET'     
     Search for WORDS, ignoring differences in punctuation.
`C-r ESC C-w WORDS RET'     
     Search backward for WORDS, ignoring differences in punctuation.

  Word search is a special case of nonincremental search and is invoked
with `C-s ESC C-w'.  This is followed by the search string, which
must always be terminated with RET.  Being nonincremental, this
search does not start until the argument is terminated.  It works by
constructing a regular expression and searching for that.  *Note Regexp Search::.

  A backward word search can be done by `C-r ESC C-w'.

  Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  These commands
may be bound to keys in the usual manner.  The reason that incremental
search is programmed to invoke them as well is that `C-s ESC C-w'
is the traditional Emacs sequence of keys for word search.


File: emacs  Node: Regexp Search, Prev: Word Search, Up: Search, Next: Regexps

Regular Expression Search
=========================

  A "regular expression" ("regexp", for short) is a pattern that
denotes a set of strings, possibly an infinite set.  Searching for matches
for a regexp is a very powerful operation that editors on Unix systems have
traditionally offered.  In GNU Emacs, you can search for the next match for
a regexp either incrementally or not.

  Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp').  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the regexp
longer, and the new regexp is searched for.  A reverse regexp search command
`isearch-backward-regexp' also exists but no key runs it.

  All of the control characters that do special things within an ordinary
incremental search have the same function in incremental regexp search.
Typing `C-s' or `C-r' immediately after starting the search
retrieves the last incremental search regexp used; that is to say,
incremental regexp and non-regexp searches have independent defaults.

  Note that adding characters to the regexp in an incremental regexp search
does not make the cursor move back and start again.  Perhaps it ought to; I
am not sure.  As it stands, if you have searched for `foo' and you
add `\|bar', the search will not check for a `bar' in the
buffer before the `foo'.

  Nonincremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke
these with `M-x', or bind them to keys.  Also, you can call
`re-search-forward' by way of incremental regexp search with
`C-M-s ESC'.


