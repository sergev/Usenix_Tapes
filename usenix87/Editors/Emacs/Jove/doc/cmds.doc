Alphabetical List of Commands and Variables

:entry "prefix-1" "Command"
This reads the  next  character  and  runs  a  command  based  on  the
character  typed.   If  you  wait  for more than a second or so before
typing the next character, the message "ESC" will be  printed  on  the
message line to remind you that JOVE is waiting for another character.

:entry "prefix-2" "Command"
This reads the  next  character  and  runs  a  command  based  on  the
character  typed.   If  you  wait  for more than a second or so before
typing another character, the message "C-X" will  be  printed  on  the
message line to remind you that JOVE is waiting for another character.

:entry "prefix-3" "Command"
This reads the  next  character  and  runs  a  command  based  on  the
character  typed.   If  you  wait  for more than a second or so before
typing the next character, the character that invoked Prefix-3 will be
printed  on  the  message  line to remind you that JOVE is waiting for
another one.

:entry "allow-^S-and-^Q" "Variable"
This variable, when set, tells JOVE that your terminal does  not  need
to  use  the  characters  C-S and C-Q for flow control, and that it is
okay to bind things to them.  This variable should  be  set  depending
upon what kind of terminal you have.

:entry "allow-bad-filenames" "Variable"
If set, this variable permits filenames to  contain  "bad"  characters
such as those from the set *&%!"`[]{}.  These files are harder to deal
with, because the characters mean something to the shell.  The default
value is "off".

:entry "append-region" "Command"
This appends the region to a specified file.  If  the  file  does  not
already exist it is created.

:entry "apropos" "Command"
This types out  all  the  commands,  variables  and  macros  with  the
specific  keyword  in  their  names.   For each command and macro that
contains the string, the key sequence that can be used to execute  the
command  or  macro  is  printed;  with variables, the current value is
printed.  So, to find all the commands that are  related  to  windows,
you type

     ESC X apropos window<Return>


:entry "auto-case-abbrev" "Variable"
When this  variable  is  on  (the  default),  word  abbreviations  are
adjusted  for  case  automatically.   For  example, if "jove" were the
abbreviation for "jonathan's own version of emacs", then typing "jove"
would  give you "jonathan's own version of emacs", typing "Jove" would
give you "Jonathan's own version of emacs", and  typing  "JOVE"  would
give  you  "Jonathan's  Own  Version of Emacs".  When this variable is
"off", upper and lower case are distinguished  when  looking  for  the
abbreviation,  i.e., in the example above, "JOVE" and "Jove" would not
be expanded unless they were defined separately.

:entry "auto-execute-command" "Command"
This tells JOVE to execute a command automatically when a  file  whose
name  matches  a  specified pattern is visited.  The first argument is
the command you want executed and the second is a  regular  expression
pattern that specifies the files that apply.  For example, if you want
to be in show-match-mode when you edit C source files (that is,  files
that end with ".c" or ".h") you can type

     ESC X auto-execute-command show-match-mode .*.[ch]$


:entry "auto-execute-macro" "Command"
This is like "auto-execute-command"  except  you  use  it  to  execute
macros automatically instead of built-in commands.

:entry "auto-fill-mode" "Command"
This turns on Auto Fill mode (or off if  it's  currently  on)  in  the
selected  buffer.   When  JOVE  is  in Auto Fill mode it automatically
breaks lines for you when you reach the right margin so you don't have
to  remember  to hit Return.  JOVE uses 78 as the right margin but you
can change that by setting  the  variable  "right-margin"  to  another
value.  See the "set" command to learn how to do this.

:entry "auto-indent-mode" "Command"
This turns on Auto Indent mode (or off if it's currently  on)  in  the
selected buffer.  When JOVE is in Auto Indent mode, Return indents the
new line to the same position as the line you were just on.   This  is
useful  for  lining up C code (or any other language (but what else is
there besides C?)).  This is out of date because of  the  new  command
called   "newline-and-indent"   but  it  remains  because  of  several
"requests" on the part of, uh, enthusiastic and excitable users,  that
it be left as it is.

:entry "backward-character" "Command"
This moves point backward over a single character.  If point is at the
beginning of the line it moves to the end of the previous line.

:entry "backward-paragraph" "Command"
This moves point backward to the beginning of the current or  previous
paragraph.   Paragraphs  are bounded by lines that begin with a Period
or Tab, or by blank lines; a change in indentation may also  signal  a
break  between paragraphs, except that JOVE allows the first line of a
paragraph to be indented differently from the other lines.

:entry "backward-s-expression" "Command"
This moves point backward  over  a  s-expression.   It  is  just  like
"forward-s-expression" with a negative argument.

:entry "backward-sentence" "Command"
This moves point backward to the beginning of the current or  previous
sentence.   JOVE  considers the end of a sentence to be the characters
".", "!" or "?" followed by a Return or by one or more spaces.

:entry "backward-word" "Command"
This moves point backward to the beginning of the current or  previous
word.

:entry "bad-filename-extensions" "Variable"
This contains a list of words separated by  spaces  which  are  to  be
considered  bad  filename  extensions,  and  so will not be counted in
filename completion.  The default is ".o" so if you  have  jove.c  and
jove.o  in  the  same  directory,  the  filename  completion  will not
complain of an ambiguity because it will ignore jove.o.

:entry "beginning-of-file" "Command"
This moves point backward  to  the  beginning  of  the  buffer.   This
sometimes prints the "Point Pushed" message.  If the top of the buffer
isn't on the screen JOVE will set the mark so you can go back to where
you were if you want.

:entry "beginning-of-line" "Command"
This moves point to the beginning of the current line.

:entry "beginning-of-window" "Command"
This moves point to the beginning of the current window.  The sequence
"ESC  ," is the same as "ESC <" (beginning of file) except without the
shift key on the "<", and can thus can easily be remembered.

:entry "bind-to-key" "Command"
This attaches a key to an internal JOVE command so that future hits on
that  key  invoke  that command.  For example, to make "C-W" erase the
previous word, you type "ESC X bind-to-key kill-previous-word C-W".

:entry "bind-macro-to-key" "Command"
This is like "bind-to-key" except you use it to attach keys  to  named
macros.

:entry "bind-macro-to-word-abbrev" "Command"
This command allows you to bind a macro to a previously  defined  word
abbreviation.   Whenever  you  type the abbreviation, it will first be
expanded as an abbreviation, and then  the  macro  will  be  executed.
Note  that  if  the  macro moves around, you should set the mark first
(C-@) and then exchange the point and mark last (C-X C-X).

:entry "buffer-position" "Command"
This displays the current file name, current line number, total number
of  lines, percentage of the way through the file, and the position of
the cursor in the current line.

:entry "c-mode" "Command"
This turns on C mode in the currently selected buffer.  This is one of
currently  four  possible  major  modes:   Fundamental, Text, C, Lisp.
When in C or Lisp mode, Tab, "}", and ")" behave a little  differently
from  usual:  They  are  indented to the "right" place for C (or Lisp)
programs.  In JOVE, the "right" place is simply  the  way  the  author
likes it (but I've got good taste).

:entry "case-character-capitalize" "Command"
This capitalizes the character after point, i.e., the  character  undo
the  cursor.   If a negative argument is supplied that many characters
"before" point are upper cased.

:entry "case-ignore-search" "Variable"
This variable, when set, tells JOVE to treat upper and lower  case  as
the  same  when  searching.   Thus  "jove" and "JOVE" would match, and
"JoVe" would match either.  The default  value  of  this  variable  is
"off".

:entry "case-region-lower" "Command"
This changes all the upper case letters in the region to  their  lower
case equivalent.

:entry "case-region-upper" "Command"
This changes all the lower case letters in the region to  their  upper
case equivalent.

:entry "case-word-capitalize" "Command"
This capitalizes the current word by making the current  letter  upper
case  and  making  the rest of the word lower case.  Point is moved to
the end of the word.  If point is not positioned on a word it is first
moved  forward  to  the  beginning  of  the  next word.  If a negative
argument is supplied that many words "before" point  are  capitalized.
This  is  useful  for correcting the word just typed without having to
move point to the beginning of the word yourself.

:entry "case-word-lower" "Command"
This lower-cases the current word and leaves point at the end  of  it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to  the  beginning
of  the next word.  If a negative argument is supplied that many words
"before" point are converted  to  lower  case.   This  is  useful  for
correcting  the  word  just  typed without having to move point to the
beginning of the word yourself.

:entry "case-word-upper" "Command"
This upper-cases the current word and leaves point at the end  of  it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to  the  beginning
of  the next word.  If a negative argument is supplied that many words
"before" point are converted  to  upper  case.   This  is  useful  for
correcting  the  word  just  typed without having to move point to the
beginning of the word yourself.

:entry "character-to-octal-insert" "Command"
This inserts a Back-slash followed by the  ascii  value  of  the  next
character typed.  For example, "C-G" inserts the string "\007".

:entry "cd" "Command"
This changes the current directory.

:entry "clear-and-redraw" "Command"
This clears the entire screen and redraws all the windows.   Use  this
when JOVE gets confused about what's on the screen, or when the screen
gets filled with garbage characters or output from another program.

:entry "comment-format" "Variable"
This variable tells JOVE how to format your comments when you run  the
command "fill-comment." Its format is this:

     <open pattern>%!<line header>%c<line trailer>%!<close pattern>

The %!, %c, and %! must appear  in  the  format;  everything  else  is
optional.   A  newline  (represented  by %n) may appear in the open or
close patterns.  %% is the representation for %.  The default  comment
format is for C comments.  See "fill-comment" for more.

:entry "compile-it" "Command"
This compiles your program by running the UNIX command "make"  into  a
buffer,  and automatically parsing the error messages that are created
(if any).  See the "parse-errors" and "parse-special-errors" commands.
To compile a C program without "make", use "C-U C-X C-E" and JOVE will
prompt for a command to run instead of make.  (And  then  the  command
you  type will become the default command.)  You can use this to parse
the output from the C compiler or the "grep" or "lint" programs.

:entry "continue-process" "Command"
This sends SIGCONT  to  the  current  interactive  process,  "if"  the
process is currently stopped.

:entry "copy-region" "Command"
This takes all the text in the region and copies it onto the kill ring
buffer.   This  is  just  like  running  "kill-region" followed by the
"yank" command.  See the "kill-region" and "yank" commands.

:entry "current-error" "Command"
This moves to the current error in the list of parsed errors.  See the
"next-error"   and   "previous-error"   commands   for  more  detailed
information.

:entry "date" "Command"
This prints the date on the message line.

:entry "define-mode-word-abbrev" "Command"
This defines a mode-specific abbreviation.

:entry "define-global-word-abbrev" "Command"
This defines a global abbreviation.

:entry "delete-blank-lines" "Command"
This deletes all the blank lines around point.  This  is  useful  when
you previously opened many lines with "C-O" and now wish to delete the
unused ones.

:entry "delete-buffer" "Command"
This deletes a buffer and frees up all the memory associated with  it.
Be  careful!  Once a buffer has been deleted it is gone forever.  JOVE
will ask you to confirm if you try  to  delete  a  buffer  that  needs
saving.   This  command  is  useful for when JOVE runs out of space to
store new buffers.

:entry "delete-macro" "Command"
This deletes a macro from the list of named macros.  It is an error to
delete  the  keyboard-macro.   Once  the  macro  is deleted it is gone
forever.  If you are about to save macros to a  file  and  decide  you
don't want to save a particular one, delete it.

:entry "delete-next-character" "Command"
This deletes the character that's  just  after  point  (that  is,  the
character  under  the  cursor).  If point is at the end of a line, the
line separator is deleted and the next line is joined with the current
one.

:entry "delete-other-windows" "Command"
This deletes all the other windows except the current one.   This  can
be thought of as going back into One Window mode.

:entry "delete-previous-character" "Command"
This deletes the character that's just  before  point  (that  is,  the
character  before  the  cursor).   If point is at the beginning of the
line, the line separator is deleted and that line is joined  with  the
previous one.

:entry "delete-white-space" "Command"
This deletes all the Tabs and Spaces around point.

:entry "delete-current-window" "Command"
This deletes the current window  and  moves  point  into  one  of  the
remaining  ones.   It  is an error to try to delete the only remaining
window.

:entry "describe-bindings" "Command"
This types out a list containing each bound key and the  command  that
gets  invoked  every  time that key is typed.  To make a wall chart of
JOVE commands, set "send-typeout-to-buffer"  to  "on"  and  JOVE  will
store  the  key  bindings in a buffer which you can save to a file and
then print.

:entry "describe-command" "Command"
This prints some info on a specified command.

:entry "describe-key" "Command"
This waits for you to type a key  and  then  tells  the  name  of  the
command  that  gets invoked every time that key is hit.  Once you have
the name of the command you can use the "describe-command" command  to
find out exactly what it does.

:entry "describe-variable" "Command"
This prints some info on a specified variable.

:entry "digit" "Command"
This reads a numeric argument.  When you  type  "ESC"  followed  by  a
number,  "digit"  keeps  reading  numbers  until  you  type some other
command.  Then that command is executes with the numeric argument  you
specified.

:entry "digit-1" "Command"
This pretends you typed "ESC 1".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-2" "Command"
This pretends you typed "ESC 2".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-3" "Command"
This pretends you typed "ESC 3".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-4" "Command"
This pretends you typed "ESC 4".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-5" "Command"
This pretends you typed "ESC 5".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-6" "Command"
This pretends you typed "ESC 6".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-7" "Command"
This pretends you typed "ESC 7".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-8" "Command"
This pretends you typed "ESC 8".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-9" "Command"
This pretends you typed "ESC 9".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "digit-0" "Command"
This pretends you typed "ESC 0".  This is useful  for  terminals  that
have  keypads  that  send  special  sequences for numbers typed on the
keypad as opposed to numbers typed from the keyboard.  This  can  save
having type "ESC" when you want to specify an argument.

:entry "dirs" "Command"
This prints out the directory stack.  See the  "cd",  "pushd",  "popd"
commands for more info.

:entry "disable-biff" "Variable"
When this is set, JOVE disables biff when you're editing  and  enables
it  again  when  you  get out of JOVE, or when you pause to the parent
shell or push to a new shell. (This means arrival of new mail will not
be  immediately  apparent but will not cause indiscriminate writing on
the display). The default is "off".

:entry "dstop-process" "Command"
Send the "dsusp" character  to  the  current  process.   This  is  the
character  that suspends a process on the next read from the terminal.
Most people have it set to C-Y.  This  only  works  if  you  have  the
interactive  process  feature,  and  if you are in a buffer bound to a
process.

:entry "edit-word-abbrevs" "Command"
This creates a buffer with a list of each abbreviation and the  phrase
it  expands  into,  and  enters a recursive edit to let you change the
abbreviations  or  add  some  more.   The  format  of  this  list   is
"abbreviation:phrase"  so  if you add some more you should follow that
format.  It's probably simplest just to  copy  some  already  existing
abbreviations  and edit them.  When you are done you type "C-X C-C" to
exit the recursive edit.

:entry "end-of-file" "Command"
This moves point forward to the end of  the  buffer.   This  sometimes
prints  the "Point Pushed" message.  If the end of the buffer isn't on
the screen JOVE will set the mark so you can go back to where you were
if you want.

:entry "end-of-line" "Command"
This moves point to the end of the current line.  If the line  is  too
long  to  fit  on  the screen JOVE will scroll the line to the left to
make the end of the line visible.  The line will  slide  back  to  its
normal  position  when  you  move  backward  past the leftmost visible
character or when you move off the line altogether.

:entry "end-of-window" "Command"
This moves point to the last character in the window.

:entry "eof-process" "Command"
Sends EOF to the current interactive  process.   This  only  works  on
versions  of  JOVE which run under 4.2-3 BSD VAX UNIX.  You can't send
EOF to processes on the 2.9 BSD PDP-11 UNIX.

:entry "erase-buffer" "Command"
This erases the contents  of  the  specified  buffer.   This  is  like
"delete-buffer"  except it only erases the contents of the buffer, not
the buffer itself.  If you try to erase a buffer that needs saving you
will be asked to confirm it.

:entry "error-window-size" "Variable"
This is the percentage of the screen to use for  the  error-window  on
the   screen.   When  you  execute  "compile-it,"  "error-window-size"
percent of the screen will go to the  error  window.   If  the  window
already  exists  and  is a different size, it is made to be this size.
The default value is 20%.

:entry "exchange-point-and-mark" "Command"
This moves point to mark and makes mark the old point.   This  is  for
quickly moving from one end of the region to another.

:entry "execute-named-command" "Command"
This is the way to execute a command that  isn't  bound  to  any  key.
When  you are prompted with ": " you can type the name of the command.
You don't  have  to  type  the  entire  name.   Once  the  command  is
unambiguous you can type Space and JOVE will fill in the rest for you.
If you are not sure of the name of the command, type "?" and JOVE will
print  a  list of all the commands that you could possibly match given
what you've already typed.  If  you  don't  have  any  idea  what  the
command's  name  is  but  you know it has something to do with windows
(for example), you can do "ESC X apropos window" and JOVE will print a
list  of  all  the  commands that are related to windows.  If you find
yourself constantly executing the same commands this way you  probably
want  to  bind them to keys so that you can execute them more quickly.
See the "bind-to-key" command.

:entry "execute-keyboard-macro" "Command"
This executes the keyboard macro.  If you supply  a  numeric  argument
the macro is executed that many times.

:entry "execute-macro" "Command"
This executes a specified macro.  If you supply a numeric argument the
macro is executed that many times.

:entry "exit-jove" "Command"
This exits JOVE.  If any buffers need saving JOVE will print a warning
message  and  ask  for confirmation.  If you leave without saving your
buffers all your work will be lost.  If you made a mistake and  really
do want to exit then you can.  If you are in a recursive editing level
"exit-jove" will return you from that.

:entry "file-creation-mode" "Variable"
This  variable  has  an  octal  value.   It  contains  the  mode  (see
"chmod(1)"  )  with  which  files  should  be created.  This mode gets
modified by your current umask setting (see "umask(1)" ).  The default
value is usually "0666" or "0644."

:entry "files-should-end-with-newline" "Variable"
This variable indicates that all files should always have a newline at
the  end.   This  is  often  necessary for line printers and the like.
When set, if JOVE is writing a file whose  last  character  is  not  a
newline, it will add one automatically.

:entry "fill-comment" "Command"
This command fills  in  your  C  comments  to  make  them  pretty  and
readable.   This  filling  is  done  according  the variable "comment-
format."

     /*
      * the default format makes comments like this.
      */

This can be changed by changing the format variable.  Other  languages
may  be  supported by changing the format variable appropriately.  The
formatter looks backwards from dot for an  open  comment  symbol.   If
found,  all  indentation  is  done  relative the position of the first
character of the open symbol.  If there is a  matching  close  symbol,
the  entire  comment is formatted.  If not, the region between dot and
the open symbol is reformatted.

:entry "fill-paragraph" "Command"
This rearranges words between lines so  that  all  the  lines  in  the
current  paragraph  extend  as  close to the right margin as possible,
ensuring that none of the lines will be greater than the right margin.
The  default  value  for "right-margin" is 78, but can be changed with
the "set" and "right-margin-here" commands.  JOVE  has  a  complicated
algorithm  for determining the beginning and end of the paragraph.  In
the normal case JOVE will give all the lines the same indent  as  they
currently have, but if you wish to force a new indent you can supply a
numeric argument to "fill-paragraph" (e.g., by typing C-U ESC  J)  and
JOVE  will  indent  each  line  to  the column specified by the "left-
margin" variable.  See also  the  "left-margin"  variable  and  "left-
margin-here" command.

:entry "fill-region" "Command"
This is like "fill-paragraph," except it operates on a region  instead
of just a paragraph.

:entry "filter-region" "Command"
This sends the text in the region to a UNIX command, and replaces  the
region  with  the  output  from that command.  For example, if you are
lazy and don't like to take the time  to  write  properly  indented  C
code, you can put the region around your C file and "filter-region" it
through "cb," the UNIX C beautifier.  If you have a file that contains
a  bunch  of  lines that need to be sorted you can do that from inside
JOVE too, by filtering the region through  the  "sort"  UNIX  command.
Before output from the command replaces the region JOVE stores the old
text in the kill ring, so if you are unhappy with the results you  can
easily get back the old text with "C-Y".

:entry "find-file" "Command"
This visits a file into its own buffer and then selects  that  buffer.
If  you've already visited this file in another buffer, that buffer is
selected.  If the file doesn't yet exist, JOVE will print "(New file)"
so that you know.

:entry "find-tag" "Command"
This finds the file that contains the specified tag.   JOVE  looks  up
tags  by default in the "tags" file in the current directory.  You can
change the default tag name by  setting  the  "tag-file"  variable  to
another  name.  If you specify a numeric argument to this command, you
will be prompted for a tag file.   This  is  a  good  way  to  specify
another  tag  file without changing the default.  If the tag cannot be
found the error is reported and point stays where it is.

:entry "find-tag-at-point" "Command"
This finds the file that contains the tag that point is currently  on.
See "find-tag."

:entry "first-non-blank" "Command"
This moves point back to the indent of the current line.

:entry "forward-character" "Command"
This moves forward over a single character.  If point is at the end of
the line it moves to the beginning of the next one.

:entry "forward-paragraph" "Command"
This moves point forward to the end of the current or next  paragraph.
Paragraphs are bounded by lines that begin with a Period or Tab, or by
blank lines; a change in indentation may also signal a  break  between
paragraphs,  except  that JOVE allows the first line of a paragraph to
be indented differently from the other lines.

:entry "forward-s-expression" "Command"
This  moves  point  forward  over  a  s-expression.   If   the   first
significant character after point is "(", this moves past the matching
")".  If the character begins an identifier, this moves just past  it.
This  is mode dependent, so this will move over atoms in LISP mode and
C identifiers in C mode.  JOVE also matches "{".

:entry "forward-sentence" "Command"
This moves point forward to the end of the current or  next  sentence.
JOVE  considers the end of a sentence to be the characters ".", "!" or
"?" followed by a Return, or one or more spaces.

:entry "forward-word" "Command"
This moves point forward to the end of the current or next word.

:entry "fundamental-mode" "Command"
This sets the major mode  to  Fundamental.   This  affects  what  JOVE
considers  as  characters  that  make up words.  For instance, Single-
quote is not part of a word in Fundamental mode, but is in Text mode.

:entry "goto-line" "Command"
If a numeric argument is supplied point moves to the beginning of that
line.  If no argument is supplied, point remains where it is.  This is
so you don't lose your place unintentionally, by accidentally  hitting
the "G" instead of "F".

:entry "grind-s-expr" "Command"
When  point  is  positioned  on  a  "(",  this  re-indents  that  LISP
expression.

:entry "grow-window" "Command"
This makes the current window one line bigger.  This only  works  when
there is more than one window and provided there is room to change the
size.

:entry "paren-flash" "Command"
This handles the C mode curly brace indentation, the Lisp  mode  paren
indentation,  and the Show Match mode paren/curly brace/square bracket
flashing.

:entry "handle-tab" "Command"
This handles indenting to the "right" place in C and  Lisp  mode,  and
just inserts itself in Text mode.

:entry "i-search-forward" "Command"
Incremental  search.   Like  search-forward  except  that  instead  of
prompting  for  a string and searching for that string all at once, it
accepts the string one character at a time.  After each character  you
type  as  part of the search string, it searches for the entire string
so far.  When you like what it found, type the Return  key  to  finish
the  search.  You can take back a character with Rubout and the search
will back up to the position before that  character  was  typed.   C-G
aborts the search.

:entry "i-search-reverse" "Command"
Incremental  search.   Like  search-reverse  except  that  instead  of
prompting  for  a string and searching for that string all at once, it
accepts the string one character at a time.  After each character  you
type  as  part of the search string, it searches for the entire string
so far.  When you like what it found, type the Return  key  to  finish
the  search.  You can take back a character with Rubout and the search
will back up to the position before that  character  was  typed.   C-G
aborts the search.

:entry "insert-file" "Command"
This inserts a specified file into the current buffer at point.  Point
is positioned at the beginning of the inserted file.

:entry "internal-tabstop" "Variable"
The number of  spaces  JOVE  should  print  when  it  displays  a  tab
character.  The default value is 8.

:entry "interrupt-character" "Variable"
This is set to the character that interrupts JOVE (with a  signal)  no
matter  what  JOVE  is  doing.  It's main use is for interrupting non-
interactive  processes,  but  it  also   has   uses   for   debugging.
Unfortunately there is no way to turn off the interrupt character.

:entry "interrupt-process" "Command"
This sends the interrupt character (usually C-C)  to  the  interactive
process in the current buffer.  This is only for versions of JOVE that
have the interactive processes feature.  This only works when you  are
inside a buffer that's attached to a process.

:entry "shell" "Command"
This starts up an interactive shell in a window.  JOVE uses  "*shell*"
as  the  name of the buffer in which the interacting takes place.  See
the manual for information on how to use interactive processes.

:entry "i-shell-command" "Command"
This is like "shell-command" except it lets  you  continue  with  your
editing  while the command is running.  This is really useful for long
running commands with sporadic output.  See the manual for information
on how to use interactive processes.

:entry "kill-next-word" "Command"
This kills the text from point to the end of the current or next word.

:entry "kill-previous-word" "Command"
This kills the text from point to the  beginning  of  the  current  or
previous word.

:entry "kill-process" "Command"
This command prompts for a buffer  name  or  buffer  number  (just  as
select-buffer  does)  and then sends the process in that buffer a kill
signal (9).

:entry "kill-region" "Command"
This deletes the text in the region and saves it  on  the  kill  ring.
Commands  that  delete  text but save it on the kill ring all have the
word "kill" in their names.  Type "C-Y" to yank back the  most  recent
kill.

:entry "kill-s-expression" "Command"
This kills the text from point to the end of the current  or  next  s-
expression.

:entry "kill-some-buffers" "Command"
This goes through all the existing buffers and asks whether or not  to
kill  them.  If you decide to kill a buffer, and it turns out that the
buffer is modified, JOVE will offer to save it first.  This is  useful
for  when JOVE runs out of memory to store lines (this only happens on
PDP-11's) and you have lots of buffers that you are no longer using.

:entry "kill-to-beginning-of-sentence" "Command"
This kills from point to the beginning  of  the  current  or  previous
sentence.

:entry "kill-to-end-of-line" "Command"
This kills from point to the end of the current line.  When  point  is
at the end of the line the line separator is deleted and the next line
is joined with current one.  If a numeric argument  is  supplied  that
many  lines  are  killed;  if the argument is negative that many lines
"before" point are killed; if the argument is zero the text from point
to the beginning of the line is killed.

:entry "kill-to-end-of-sentence" "Command"
This kills from point to the end of the current or next sentence.   If
a  negative  numeric  argument  is supplied it kills from point to the
beginning of the current or previous sentence.

:entry "left-margin" "Variable"
This is how far lines should be indented when auto-indent mode is  on,
or  when  the  "newline-and-indent"  command is run (usually by typing
LineFeed).  It is also used by fill-paragraph and auto-fill mode.   If
the  value  is  zero  (the default) then the left margin is determined
from the surrounding lines.

:entry "left-margin-here" "Command"
This sets the "left-margin" variable to the current position of point.
This is an easy way to say, "Make the left margin begin here," without
having to count the number of spaces over it actually is.

:entry "lisp-mode" "Command"
This turns on Lisp mode.  Lisp mode is one of four mutually  exclusive
major  modes:  Fundamental,  Text,  C,  and  Lisp.   In Lisp mode, the
characters Tab and ) are treated specially, similar to  the  way  they
are  treated  in  C  mode.   Also,  Auto  Indent mode is affected, and
handled specially.

:entry "list-buffers" "Command"
This types out  a  list  containing  various  information  about  each
buffer.  Right now that list looks like this:

      (* means the buffer needs saving)
      NO  Lines Type        Name           File
      --  ----- ----        ----           ----
      1   1     File        Main           [No file]
      2   1     Scratch   * Minibuf        [No file]
      3   519   File      * commands.doc   commands.doc

The first column lists the buffer's number.  When JOVE prompts  for  a
buffer  name  you  can either type in the full name, or you can simply
type the buffer's number.  The second column is the number of lines in
the  buffer.   The  third  says  what  type of buffer.  There are four
types: "File", "Scratch", "Process", "I-Process".  "File" is simply  a
buffer  that  holds  a  file;  "Scratch" is for buffers that JOVE uses
internally; "Process" is  one  that  holds  the  output  from  a  UNIX
command;  "I-Process"  is one that has an interactive process attached
to it.  The next column contains the name of the buffer.  And the last
column is the name of the file that's attached to the buffer.  In this
case, both Minibuf and commands.doc have  been  changed  but  not  yet
saved.   In  fact  Minibuf  won't be saved since it's an internal JOVE
buffer that I don't even care about.

:entry "list-processes" "Command"
This makes a list somewhat like "list-buffers" does, except  its  list
consists  of  the  current  interactive processes.  Right now the list
looks like this:

      Buffer           Status           Pid    Command
      ------           ------           ---    -------
      *shell*          Running          18415shell
      fgrep            Done             18512   fgrep -n Buffer *.c

The first column has the name of the buffer to which  the  process  is
attached.   The second has the status of the process; if a process has
exited normally the status is "Done"  as  in  fgrep;  if  the  process
exited  with  an  error the status is "Exit N" where N is the value of
the exit code; if the process was killed by some signal the status  is
the  name  of  the  signal  that  was  used;  otherwise the process is
running.  The last column is the name of the  command  that  is  being
run.

:entry "mailbox" "Variable"
Set this to the full pathname of your mailbox.  JOVE will look here to
decide  whether  or  not  you  have any unread mail.  This defaults to
/usr/spool/mail/$USER, where $USER is set to your login name.

:entry "mail-check-frequency" "Variable"
This is how often (in seconds) JOVE  should  check  your  mailbox  for
incoming mail.  See also the "mailbox" and "disable-biff" variables.

:entry "make-backup-files" "Variable"
If this variable is set, then whenever JOVE writes out a file, it will
move  the  previous  version  of  the  file  (if  there  was  one)  to
"#filename".  This is often convenient if you save a file by accident.
The  default  value  of  this  variable  is "off".  "Note:" this is an
optional part of JOVE, and your guru may not have it  enabled,  so  it
may not work.

:entry "make-buffer-unmodified" "Command"
This makes JOVE think the selected buffer hasn't been changed even  if
it  has.   Use  this when you accidentally change the buffer but don't
want it considered  changed.   Watch  the  mode  line  to  see  the  *
disappear when you use this command.

:entry "make-macro-interactive" "Command"
This command is meaningful only while  you  are  defining  a  keyboard
macro.   Ordinarily,  when  a command in a macro definition requires a
trailing text argument (file name, search string, etc.), the  argument
you  supply  becomes  part of the macro definition.  If you want to be
able to supply a different argument each time the macro is used,  then
while  you are defining it, you should give the make-macro-interactive
command just before typing the argument which will be used during  the
definition  process.   Note:  you  must  bind this command to a key in
order to use it; you can't say ESC X make-macro-interactive.

:entry "mark-threshold" "Variable"
This variable contains the number of lines point may  move  by  before
the  mark  is  set.  If, in a search or something, point moves by more
than this many lines, the mark is set so that you may  return  easily.
The  default  value  of  this  variable  is 22 (one screenful, on most
terminals).

:entry "marks-should-float" "Variable"
When this variable is "off", the position of a mark is remembered as a
line  number within the buffer and a character number within the line.
If you add or delete text before the mark, it will no longer point  to
the  text  you marked originally because that text is no longer at the
same line and character number.   When  this  variable  is  "on",  the
position  of  a  mark is adjusted to compensate for each insertion and
deletion.  This makes marks much more sensible to use, at the cost  of
slowing  down  insertion  and deletion somewhat.  The default value is
"on".

:entry "match-regular-expressions" "Variable"
When set, JOVE will match  regular  expressions  in  search  patterns.
This  makes  special the characters ., *, [, ], ^, and $, and the two-
character sequences \<, \>, \{, \} and \|.   See  the  "ed(1)"  manual
page,  the  tutorial "Advanced Editing in UNIX", and the section above
"Searching with Regular Expressions" for more information.

:entry "meta-key" "Variable"
You should set this variable to "on" if your terminal has a real  Meta
key.   If your terminal has such a key, then a key sequence like ESC Y
can be entered by holding down Meta and typing Y.

:entry "mode-line" "Variable"
The format of  the  mode  line  can  be  determined  by  setting  this
variable.   The  items  in  the  line  are specified using a printf(3)
format, with the special things being marked as "%x".  Digits  may  be
used between the 'x' may be:

          C    check for new mail, and displays "[New mail]" if there
               is any (see also the mail-check-interval and disable-biff
               variables)
          F    the current file name, with leading path stripped
          M    the current list of major and minor modes
          b    the current buffer name
          c    the fill character (-)
          d    the current directory
          e    end of string--this must be the last item in the string
          f    the current file name
          l    the current load average (updated automatically)
          mxy  x, when the buffer is modified or y, when not
          n    the current buffer number
          s    space, but only if previous character is not a space
          t    the current time (updated automatically)
          [ ]  the square brackets printed when in a recursive edit
          ( )  items enclosed in %( ... %) will only be printed on
               the bottom mode line, rather than copied when the
               window is split

In addition, any other character is simply copied into the mode  line.
Characters  may  be  escaped  with a backslash.  To get a feel for all
this, try typing "ESC X print mode-line" and compare the  result  with
your current mode line.

:entry "mode-line-should-standout" "Variable"
If set, the mode line will  be  printed  in  reverse  video,  if  your
terminal supports it.  The default for this variable is "off".

:entry "name-keyboard-macro" "Command"
This copies the keyboard macro and gives it  a  name  freeing  up  the
keyboard  macro  so  you  can  define some more.  Keyboard macros with
their own names can be bound to keys just like built in commands  can.
See the "read-macros-from-file" and "write-macros-to-file" commands.

:entry "newline" "Command"
This divides the current line at point moving  all  the  text  to  the
right  of point down onto the newly created line.  Point moves down to
the beginning of the new line.

:entry "newline-and-backup" "Command"
This divides the current line at point moving  all  the  text  to  the
right  of  point  down  onto  the  newly created line.  The difference
between this and "newline" is that point does not  move  down  to  the
beginning of the new line.

:entry "newline-and-indent" "Command"
This behaves the same was as Return does when  in  Auto  Indent  mode.
This  makes  Auto  Indent  mode obsolete but it remains in the name of
backward compatibility.

:entry "next-error" "Command"
This moves to the next error in the list of errors  that  were  parsed
with  "parse-errors" or "parse-special-errors." In one window the list
of errors is shown with the current one always at the top.  In another
window  is  the  file that contains the error.  Point is positioned in
this window on the line where the error occurred.

:entry "next-line" "Command"
This moves down to the next line.

:entry "next-page" "Command"
This displays the next page of the buffer by taking the bottom line of
the  window  and  redrawing  the  window with it at the top.  If there
isn't another page in the buffer JOVE rings the bell.   If  a  numeric
argument is supplied the screen is scrolled up that many lines; if the
argument is negative the screen is scrolled down.

:entry "next-window" "Command"
This moves into the next window.  Windows live in a circular  list  so
when  you're  in the bottom window and you try to move to the next one
you are moved to the top window.  It is an error to use  this  command
with only one window.

:entry "number-lines-in-window" "Command"
This displays the line numbers for  each  line  in  the  buffer  being
displayed.   The  number  isn't  actually  part of the text; it's just
printed before the actual buffer line is.  To turn this  off  you  run
the command again; it toggles.

:entry "over-write-mode" "Command"
This turns Over Write mode on (or off if it's  currently  on)  in  the
selected  buffer.   When  on,  this  mode  changes  the  way the self-
inserting  characters  work.   Instead  of  inserting  themselves  and
pushing  the rest of the line over to the right, they replace or over-
write the existing character.  Also,  Rubout  replaces  the  character
before  point  with  a  space instead of deleting it.  When Over Write
mode is on "OvrWt" is displayed on the mode line.

:entry "page-next-window" "Command"
This displays the next page in the next window.  This is  exactly  the
same as "C-X N C-V C-X P".

:entry "paren-flash-delay" "Variable"
How long, in tenths of  seconds,  JOVE  should  pause  on  a  matching
parenthesis in "Show" mode.  The default is 5.

:entry "parse-errors" "Command"
This takes the list of C compilation errors (or  output  from  another
program  in the same format) in the current buffer and parses them for
use with the "next-error"  and  "previous-error"  and  "current-error"
commands.   This  is  a  very  useful  tool and helps with compiling C
programs and when used in conjunction with  the  "grep"  UNIX  command
very  helpful  in  making  changes  to a bunch of files.  This command
understands errors produced by cc,  cpp,  and  lint;  plus  any  other
program with the same format (e.g., "grep -n").  JOVE visits each file
that has an error and remembers each line that contains an error.   It
doesn't matter if later you insert or delete some lines in the buffers
containing errors; JOVE remembers where they are  regardless.   "next-
error"  is  automatically executed after one of the parse commands, so
you end up at the first error.

:entry "parse-special-errors" "Command"
This parses errors in an unknown format.   Error  parsing  works  with
regular  expression  search strings with \('s around the the file name
and the line number.  So, you can use "parse-special-errors" to  parse
lines  that  are  in a slightly different format by typing in your own
search string.  If you don't know how to use regular  expressions  you
can't use this command.

:entry "parse-spelling-errors-in-buffer" "Command"
This parses a list of words in the current buffer and looks them up in
another buffer that you specify.  This will probably go away soon.

:entry "pause-jove" "Command"
This stops JOVE and returns control to the parent  shell.   This  only
works  for  users  using the C-shell, and on systems that have the job
control facility.  To return to JOVE you type "fg" to the C-shell.

:entry "physical-tabstop" "Variable"
How many spaces your terminal prints when it prints a tab character.

:entry "pop-mark" "Command"
This gets executed when you run "set-mark" with  a  numeric  argument.
JOVE remembers the last 16 marks and you use "pop-mark" to go backward
through the ring of marks.  If you execute "pop-mark" enough times you
will eventually get back to where you started.

:entry "popd" "Command"
This pops one entry off the directory stack.  Entries are pushed  with
the  "pushd"  command.  The names were stolen from the C-shell and the
behavior is the same.

:entry "previous-error" "Command"
This is the same as "next-error" except it goes to the previous error.
See "next-error" for documentation.

:entry "previous-line" "Command"
This moves up to the previous line.

:entry "previous-page" "Command"
This displays the previous page of the current buffer  by  taking  the
top line and redrawing the window with it at the bottom.  If a numeric
argument is supplied the screen is scrolled down that many  lines;  if
the argument is negative the screen is scrolled up.

:entry "previous-window" "Command"
This moves into the next window.  Windows live in a circular  list  so
when  you're in the top window and you try to move to the previous one
you are moved to the bottom window.   It  is  an  error  to  use  this
command with only one window.

:entry "print" "Command"
This prints the value of a JOVE variable.

:entry "print-message" "Command"
This command prompts for a message, and then prints it on  the  bottom
line where JOVE messages are printed.

:entry "process-bind-to-key" "Command"
This command is identical to bind-to-key, except that it only  affects
your  bindings  when  you are in a buffer attached to a process.  When
you enter the process buffer, any keys bound with  this  command  will
automatically take their new values.  When you switch to a non-process
buffer, the old  bindings  for  those  keys  will  be  restored.   For
example, you might want to execute

     process-bind-to-key stop-process ^Z
     process-bind-to-key interrupt-process ^C

Then, when you start up an interactive process and  switch  into  that
buffer,  C-Z will execute stop-process and C-C will execute interrupt-
process.  When you switch back to a non-process buffer,  C-Z  will  go
back to executing scroll-up (or whatever you have it bound to).

:entry "process-newline" "Command"
This this only gets executed when in a buffer that is attached  to  an
interactive-process.   JOVE  does  two  different  things depending on
where you are when you hit Return.  When you're at the end of  the  I-
Process  buffer  this  does  what Return normally does, except it also
makes the line available to the process.  When point is positioned  at
some other position that line is copied to the end of the buffer (with
the prompt stripped) and point is moved there with it, so you can then
edit  that line before sending it to the process.  This command "must"
be bound to the key you usually use to enter shell commands  (Return),
or else you won't be able to enter any.

:entry "process-prompt" "Variable"
What a prompt looks like from the shell and i-shell-command processes.
The  default  is "% ", the default C-shell prompt.  This is actually a
regular expression search string.  So you can set it to be  more  than
one  thing  at  once  using  the  \| operator.  For instance, for LISP
hackers, the prompt can be

     "% \|-> \|<[0-9]>: ".


:entry "push-shell" "Command"
This spawns a child shell and relinquishes control to it.  This  works
on any version of UNIX, but this isn't as good as "pause-jove" because
it takes time to start up the new  shell  and  you  get  a  brand  new
environment every time.  To return to JOVE you type "C-D".

:entry "pushd" "Command"
This pushes a directory onto the directory stack and cd's into it.  It
asks  for  the directory name but if you don't specify one it switches
the top two entries no the stack.  It purposely behaves  the  same  as
C-shell's "pushd."

:entry "pwd" "Command"
This prints the working directory.

:entry "quadruple-numeric-argument" "Command"
This multiplies the numeric  argument  by  4.   So,  "C-U  C-F"  means
forward 4 characters and "C-U C-U C-N" means down 16 lines.

:entry "query-replace-string" "Command"
This replaces the occurrences of a specified string with  a  specified
replacement  string.  When an occurrence is found point is moved to it
and then JOVE asks what to do.  The options are:

     Space    to replace this occurrence and go on to the next one.
     Period   to replace this occurrence and then stop.
     Rubout   to skip this occurrence and go on to the next one.
     C-R      to enter a recursive edit.  This lets you temporarily
              suspend the replace, do some editing, and then return
              to continue where you left off.  To continue with the
              Query Replace type "C-X C-C" as if you were trying to
              exit JOVE.  Normally you would but when you are in a
              recursive edit all it does is exit that recursive
              editing level.
     C-W      to delete the matched string and then enter a recursive
              edit.
     U        to undo the last replacement.
     P or !   to go ahead and replace the remaining occurrences without
              asking.
     Return   to stop the Query Replace.

The search for occurrences starts at point and goes to the end of  the
buffer,  so  to  replace in the entire buffer you must first go to the
beginning.

:entry "quit-process" "Command"
This is the same as typing "C-\" (the Quit character) to a normal UNIX
process,  except  it sends it to the current process in JOVE.  This is
only for versions of JOVE that have the interactive processes feature.
This  only  works  when  you  are inside a buffer that's attached to a
process.

:entry "quoted-insert" "Command"
This lets you insert characters that normally  would  be  executed  as
other JOVE commands.  For example, to insert "C-F" you type "C-Q C-F".

:entry "read-word-abbrev-file" "Command"
This reads a specified file that  contains  a  bunch  of  abbreviation
definitions, and makes those abbreviations available.  If the selected
buffer is not already in Word Abbrev mode this command puts it in that
mode.

:entry "read-macros-from-file" "Command"
This  reads  the  specified  file  that  contains  a  bunch  of  macro
definitions,  and  defines  all the macros that were currently defined
when the file was created.  See "write-macros-to-file" to see  how  to
save macros.

:entry "redraw-display" "Command"
This centers the line containing point in the window.  If that line is
already  in  the  middle the window is first cleared and then redrawn.
If a numeric argument is supplied, the  line  is  positioned  at  that
offset from the top of the window.  For example, "ESC 0 C-L" positions
the line containing point at the top of the window.

:entry "recursive-edit" "Command"
This enters a recursive editing level.  This isn't really very useful.
I  don't  know why it's available for public use.  I think I'll delete
it some day.

:entry "rename-buffer" "Command"
This lets you rename the current buffer.

:entry "replace-in-region" "Command"
This is the same as "replace-string" except that it is  restricted  to
occurrences between Point and Mark.

:entry "replace-string" "Command"
This replaces all occurrences of a specified string with  a  specified
replacement  string.   This is just like "query-replace-string" except
it replaces without asking.

:entry "right-margin" "Variable"
Where the right margin is for  "Auto  Fill"  mode  and  the  "justify-
paragraph" and "justify-region" commands.  The default is 78.

:entry "right-margin-here" "Command"
This sets the "right-margin"  variable  to  the  current  position  of
point.   This  is  an  easy  way  to say, "Make the right margin begin
here," without having to count the number of spaces over  it  actually
is.

:entry "save-file" "Command"
This saves the current buffer to the associated file.  This makes your
changes  permanent  so  you should be sure you really want to.  If the
buffer has not been modified "save-file" refuses to do the  save.   If
you  really  do  want  to  write  the file you can use "C-X C-W" which
executes "write-file."

:entry "scroll-down" "Command"
This scrolls the screen one line down.  If the line  containing  point
moves past the bottom of the window point is moved up to the center of
the window.  If a numeric argument is supplied  that  many  lines  are
scrolled;  if  the  argument  is  negative  the  screen is scrolled up
instead.

:entry "scroll-step" "Variable"
How many lines should be scrolled if  the  "previous-line"  or  "next-
line"  commands move you off the top or bottom of the screen.  You may
wish to decrease this variable if you are on a slow terminal.

:entry "scroll-up" "Command"
This scrolls the screen one line up.  If  the  line  containing  point
moves  past the top of the window point is moved down to the center of
the window.  If a numeric argument is supplied  that  many  lines  are
scrolled;  if  the  argument  is  negative the screen is scrolled down
instead.

:entry "search-exit-char" "Variable"
Set this to the character you want to use to exit incremental  search.
The  default  is  Newline, which makes i-search compatible with normal
string search.

:entry "search-forward" "Command"
This searches forward for a  specified  search  string  and  positions
point  at  the  end of the string if it's found.  If the string is not
found point remains unchanged.  This searches from point to the end of
the buffer, so any matches before point will be missed.

:entry "search-reverse" "Command"
This searches backward for a specified  search  string  and  positions
point  at the beginning if the string if it's found.  If the string is
not found point remains unchanged.  This searches from  point  to  the
beginning of the buffer, so any matches after point will be missed.

:entry "select-buffer" "Command"
This selects a new or already existing buffer making  it  the  current
one.   You  can type either the buffer name or number.  If you type in
the name you need only type the name until it is unambiguous, at which
point typing Escape or Space will complete it for you.  If you want to
create a new buffer you can type Return instead of Space,  and  a  new
empty buffer will be created.

:entry "self-insert" "Command"
This inserts the character that invoked it into the buffer  at  point.
Initially  all  but  a  few  of  the  printing characters are bound to
"self-insert."

:entry "send-typeout-to-buffer" "Variable"
When this is set JOVE will send output that  normally  overwrites  the
screen  (temporarily) to a buffer instead.  This affects commands like
"list-buffers," "list-processes," and other commands that use  command
completion.  The default value is "off".

:entry "set" "Command"
This gives a specified variable a new value.  Occasionally you'll  see
lines  like  "set  this variable to that value to do this".  Well, you
use the "set" command to do that.

:entry "set-mark" "Command"
This sets the mark at the current position in the buffer.   It  prints
the  message "Point pushed" on the message line.  It says that instead
of "Mark set" because when you set the mark the previous mark is still
remembered  on  a  ring of 16 marks.  So "Point pushed" means point is
pushed onto the ring of marks and becomes the value of "the mark".  To
go  through the ring of marks you type "C-U C-@", or execute the "pop-
mark" command.  If you type this enough times you  will  get  back  to
where you started.

:entry "shell" "Variable"
The shell to be used with all the shell  commands  command.   If  your
SHELL environment variable is set, it is used as the value of "shell;"
otherwise "/bin/csh" is the default.

:entry "shell-command" "Command"
This runs a UNIX command and places the output from that command in  a
buffer.   JOVE  creates  a buffer that matches the name of the command
you specify and then attaches that buffer to a window.  So,  when  you
have only one window running this command will cause JOVE to split the
window and attach the new buffer  to  that  window.   Otherwise,  JOVE
finds  the  most convenient of the available windows and uses that one
instead.  If the buffer already exists it  is  first  emptied,  except
that  if it's holding a file, not some output from a previous command,
JOVE prints an error message and refuses to execute the  command.   If
you  really  want to execute the command you should delete that buffer
(saving it first, if you like) or use  "shell-command-to-buffer,"  and
try again.

:entry "shell-command-to-buffer" "Command"
This is just like "shell-command"  except  it  lets  you  specify  the
buffer to use instead of JOVE.

:entry "shell-flags" "Variable"
This defines the flags that are passed to shell commands.  The default
is "-c".  See the "shell" variable to change the default shell.

:entry "show-match-mode" "Command"
This turns on Show Match mode (or off if it's  currently  on)  in  the
selected buffer.  This changes "}" and ")" so that when they are typed
the are inserted as usual, and then the cursor  flashes  back  to  the
matching  "{"  or  "("  (depending on what was typed) for about half a
second, and then goes back to just after the "}" or ")"  that  invoked
the  command.  This is useful for typing in complicated expressions in
a program.  You can change how long the cursor sits  on  the  matching
paren  by  setting  the  "paren-flash-delay"  variable  in tenths of a
second.  If the matching "{" or "(" isn't visible nothing happens.

:entry "shrink-window" "Command"
This makes the current window one line shorter, if possible.   Windows
must  be at least 2 lines high, one for the text and the other for the
mode line.

:entry "source" "Command"
This reads a bunch of JOVE commands from a file.  The  format  of  the
file  is the same as that in your initialization file (your ".joverc")
in your main directory.  There should be one command per line  and  it
should  be  as  though  you typed "ESC X" while in JOVE.  For example,
here's part of my initialization file:

     bind-to-key i-search-reverse ^R
     bind-to-key i-search-forward ^S
     bind-to-key pause-jove ^[S

What they do is make "C-R" call  the  "i-search-reverse"  command  and
"C-S" call "i-search-forward" and "ESC S" call "pause-jove."

:entry "spell-buffer" "Command"
This runs the current buffer through  the  UNIX  "spell"  program  and
places the output in buffer "Spell".  Then JOVE lets you edit the list
of words, expecting you to delete the ones that you don't care  about,
i.e.,  the  ones  you  know  are  spelled correctly.  Then the "parse-
spelling-errors-in-buffer" command  comes  along  and  finds  all  the
misspelled words and sets things up so the error commands work.

:entry "split-current-window" "Command"
This splits the current window into two  equal  parts  (providing  the
resulting  windows  would  be  big  enough)  and displays the selected
buffer in both windows.  Use "C-X 1" to go back to 1 window mode.

:entry "start-remembering" "Command"
This starts remembering your key strokes in the  Keyboard  macro.   To
stop remembering you type "C-X )".  Because of a bug in JOVE you can't
stop  remembering  by  typing   "ESC   X   stop-remembering";   "stop-
remembering"  must  be  bound  to "C-X )" in order to make things work
correctly.  To execute the remembered key strokes  you  type  "C-X  E"
which  runs  the  "execute-keyboard-macro" command.  Sometimes you may
want a macro to accept different input each time it runs.  To see  how
to do this, see the "make-macro-interactive" command.

:entry "stop-process" "Command"
This sends a stop  signal  (C-Z,  for  most  people)  to  the  current
process.   It  only works if you have the interactive process feature,
and you are in a buffer attached to a process.

:entry "stop-remembering" "Command"
This stop the definition of the keyboard macro.  Because of a  bug  in
JOVE,  this  must  be  bound  to "C-X )".  Anything else will not work
properly.

:entry "string-length" "Command"
This prints the number of characters in the string that point sits in.
Strings  are  surrounded  by double quotes.  JOVE knows that "\007" is
considered a single character, namely  "C-G",  and  also  knows  about
other  common  ones,  like "\r" (Return) and "\n" (LineFeed).  This is
mostly useful only for C programmers.

:entry "suspend-jove" "Command"
This is a synonym for "pause-jove."

:entry "sync-frequency" "Variable"
The temporary files used by JOVE are forced out to disk  every  "sync-
frequency"  modifications.  The default is 50, which really makes good
sense.  Unless your system is very unstable,  you  probably  shouldn't
fool with this.

:entry "tag-file" "Variable"
This  the  name  of  the  file  in  which  JOVE  should  look  up  tag
definitions.  The default value is "./tags".

:entry "tmp-file-pathname" "Variable"
This tells JOVE where to put the tmp files, which is where JOVE stores
buffers  internally.   The default is usually in /tmp, but if you want
to store them somewhere else, you can  set  this  variable.   If  your
system  crashes  a lot it might be a good idea to set this variable to
somewhere other than /tmp because the system removes all the files  in
/tmp  upon  reboot,  and  so  you  would not be able to recover editor
buffers using the "jove -r" command.

NOTE: In order for this to work correctly you must set  this  variable
BEFORE  JOVE  creates  the tmp file.  You can set this in your .joverc
(the closer to tbe beginning the better), or as soon as you  start  up
JOVE before you visit any files.

:entry "text-mode" "Command"
This sets the major mode to  Text.   Currently  the  other  modes  are
Fundamental, C and Lisp mode.

:entry "transpose-characters" "Command"
This switches the character before point with the one after point, and
then  moves  forward  one.   This doesn't work at the beginning of the
line, and at the end of the line it switches the two characters before
point.   Since  point is moved forward, so that the character that was
before point is still before point,  you  can  use  "C-T"  to  drag  a
character  down  the  length  of  a line.  This command pretty quickly
becomes very useful.

:entry "transpose-lines" "Command"
This switches the current line with the one above it, and  then  moves
down  one  so that the line that was above point is still above point.
This, like "transpose-characters," can be used to drag a line  down  a
page.

:entry "unbind-key" "Command"
Use this to unbind "any" key sequence.  You can  use  this  to  unbind
even  a  prefix  command,  since  this  command  does not use "key-map
completion".  For example,  "ESC  X  unbind-key  ESC  ["  unbinds  the
sequence  "ESC  [".  This is useful for "turning off" something set in
the system-wide ".joverc" file.

:entry "update-time-frequency" "Variable"
How often the mode line  is  updated  (and  thus  the  time  and  load
average, if you display them).  The default is 30 seconds.

:entry "use-i/d-char" "Variable"
If your terminal has insert/delete character capability you  can  tell
JOVE not to use it by setting this to "off".  In my opinion it is only
worth using insert/delete character at low baud  rates.   WARNING:  if
you  set  this  to  "on" when your terminal doesn't have insert/delete
character capability, you will get weird (perhaps fatal) results.

:entry "version" "Command"
Displays the version number of this JOVE.

:entry "visible-bell" "Variable"
Use the terminal's visible bell  instead  of  beeping.   This  is  set
automatically if your terminal has the capability.

:entry "visible-spaces-in-window" "Command"
This displays an underscore character instead of  each  space  in  the
window  and displays a greater-than followed by spaces for each tab in
the window.  The actual text in the buffer is not  changed;  only  the
screen  display  is  affected.   To  turn this off you run the command
again; it toggles.

:entry "visit-file" "Command"
This reads a specified file into the current buffer replacing the  old
text.   If the buffer needs saving JOVE will offer to save it for you.
Sometimes you use this to start over, say if you make lots of  changes
and  then change your mind.  If that's the case you don't want JOVE to
save your buffer and you answer "NO" to the question.

:entry "window-find" "Command"
This lets you select another buffer in another window three  different
ways.   This  waits  for  another  character  which  can be one of the
following:

     T    Finds a tag in the other window.
     F    Finds a file in the other window.
     B    Selects a buffer in the other window.

This is just a convenient short hand for "C-X 2" (or "C-X O" if  there
are  already  two  windows)  followed  by the appropriate sequence for
invoking each command.  With  this,  though,  there  isn't  the  extra
overhead  of  having  to  redisplay.   In  addition, you don't have to
decide whether to type "C-X 2" or "C-X O" since "C-X 4" does the right
thing.

:entry "word-abbrev-mode" "Command"
This turns on Word Abbrev mode (or off if it's currently  on)  in  the
selected  buffer.   Word  Abbrev  mode  lets  you  specify  a word (an
abbreviation) and a phrase  with  which  JOVE  should  substitute  the
abbreviation.   You  can  use this to define words to expand into long
phrases, e.g., "jove" can  expand  into  "Jonathan's  Own  Version  of
Emacs";  another  common use is defining words that you often misspell
in the same way, e.g., "thier" => "their" or "teh" => "the".  See  the
information on the "auto-case-abbrev" variable.

There are two kinds of abbreviations: mode specific  and  global.   If
you define a Mode specific abbreviation in C mode, it will expand only
in buffers that are in C mode.  This is  so  you  can  have  the  same
abbreviation  expand  to  different  things depending on your context.
Global abbreviations expand  regardless  of  the  major  mode  of  the
buffer.   The  way  it  works  is  this:  JOVE looks first in the mode
specific table, and then in the global table.  Whichever it  finds  it
in  first is the one that's used in the expansion.  If it doesn't find
the word it is left untouched.  JOVE tries to expand words as they are
typed,  when  you type a punctuation character or Space or Return.  If
you are in Auto Fill mode the expansion will be filled as if you typed
it yourself.

:entry "wrap-search" "Variable"
If set, searches will "wrap around" the ends of the buffer instead  of
stopping at the bottom or top.  The default is "off".

:entry "write-files-on-make" "Variable"
When set, all modified files will be written out before  calling  make
when the "compile-it" command is executed.  The default is "on".

:entry "write-word-abbrev-file" "Command"
This writes the currently defined abbreviations to a  specified  file.
They  can  be  read back in and automatically defined with "read-word-
abbrev-file."

:entry "write-file" "Command"
This saves the current buffer to a specified file, and then makes that
file  the  default  file  name for this buffer.  If you specify a file
that already exists you are asked to confirm over-writing it.

:entry "write-macros-to-file" "Command"
This writes the currently defined macros to  a  specified  file.   The
macros  can  be  read  back in with "read-macros-from-file" so you can
define macros and still use them in other instantiations of JOVE.

:entry "write-modified-files" "Command"
This saves all the buffers that need saving.  If you supply a  numeric
argument it asks for each buffer whether you really want to save it.

:entry "write-region" "Command"
This writes the text in the region to a specified file.  If  the  file
already exists you are asked to confirm over-writing it.

:entry "yank" "Command"
This undoes the last kill command.  That is,  it  inserts  the  killed
text  at point.  When you do multiple kill commands in a row, they are
merged so that yanking them back with "C-Y" yanks back all of them.

:entry "yank-pop" "Command"
This yanks back previous killed text.  JOVE has a kill ring  on  which
the  last 10 kills are stored.  "yank" yanks a copy of the text at the
front of the ring.  If you want one of the last ten kills you use "ESC
Y"  which  rotates  the  ring so another different entry is now at the
front.  You can use "ESC Y" only  immediately  following  a  "C-Y"  or
another  "ESC  Y".  If you supply a negative numeric argument the ring
is rotated the other way.  If you use this command enough times  in  a
row  you  will  eventually  get back to where you started.  Experiment
with this.  It's extremely useful.










