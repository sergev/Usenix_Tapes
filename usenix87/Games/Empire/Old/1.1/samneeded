#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	Makefile
#	COMMANDS/Makefile
#	EMPCRE/Makefile
#	EMPDIS/Makefile
#	EMPFIX/Makefile
#	EMPGLB/Makefile
#	EMPIRE/Makefile
#	EMPN/Makefile
#	EMPSUBS/Makefile
#	COMMANDS/spy.c
#	EMPCRE/empcre.c
#	EMPDIS/empdis.c
#	EMPIRE/empire.c
#	EMPSUBS/getrel.c
#	EMPSUBS/sread.c
#	EMPSUBS/xwrap.c
# This archive created: Thu Apr 30 22:39:44 1987
export PATH; PATH=/bin:$PATH
mv Makefile Makefile.orig
mv COMMANDS/Makefile COMMANDS/Makefile.orig
mv EMPCRE/Makefile EMPCRE/Makefile.orig
mv EMPDIS/Makefile EMPDIS/Makefile.orig
mv EMPFIX/Makefile EMPFIX/Makefile.orig
mv EMPGLB/Makefile EMPGLB/Makefile.orig
mv EMPIRE/Makefile EMPIRE/Makefile.orig
mv EMPN/Makefile EMPN/Makefile.orig
mv EMPSUBS/Makefile EMPSUBS/Makefile.orig
mv COMMANDS/spy.c COMMANDS/spy.c.orig
mv EMPCRE/empcre.c EMPCRE/empcre.c.orig
mv EMPDIS/empdis.c EMPDIS/empdis.c.orig
mv EMPIRE/empire.c EMPIRE/empire.c.orig
mv EMPSUBS/getrel.c EMPSUBS/getrel.c.orig
mv EMPSUBS/sread.c EMPSUBS/sread.c.orig
mv EMPSUBS/xwrap.c EMPSUBS/xwrap.c.orig
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
cat << \SHAR_EOF > 'Makefile'

DESTDIR=/usr/games

#If there are any directories between DESTDIR and DESTBIN, (if
#$(DESTBIN)<>$(DESTDIR)/BIN & likewise for $(DESTINFO) & $(DESTDATA)) then they
#must be created by the installer.

DESTBIN=/usr/games/lib/empire/BIN
DESTDAT=/usr/games/lib/empire/DATA
DESTINF=/usr/games/lib/empire/INFO

#Change the next two lines as appropriate.
OWNPID=games
OWNGRP=system
MAKE=make
LIBDIR=./_unix.O
BINDIR=./BIN
INFODIR=./INFO
EMPGLB=$(LIBDIR)/empglb.o
EMPDIS=$(LIBDIR)/empdis.o
EMPSUB=$(LIBDIR)/empsub.a
EMPCOM=$(LIBDIR)/empcom.a
EMPS=\
        $(BINDIR)/emp1 \
        $(BINDIR)/emp2 \
        $(BINDIR)/emp3 \
        $(BINDIR)/emp4 \
        $(BINDIR)/emp5 \
        $(BINDIR)/emp7 \
        empn

all:	BIN DATA _unix.O $(EMPGLB) $(EMPDIS) $(EMPSUB) $(EMPCOM) \
	empire empcre \
	$(BINDIR)/empfix empn
	@echo All done!

BIN:	
	mkdir BIN

DATA:
	mkdir DATA

_unix.O:
	mkdir _unix.O

$(EMPGLB):      FRC
	@echo EMPGLB:
	@cd EMPGLB; $(MAKE)

empglb.o:       $(EMPGLB)

$(EMPDIS):      FRC
	@echo EMPDIS:
	@cd EMPDIS; $(MAKE)

empdis.o:       $(EMPDIS)

$(EMPSUB):      FRC
	@echo EMPSUBS:
	@cd EMPSUBS; $(MAKE)

empsub.a:       $(EMPSUB)

$(EMPCOM):      FRC
	@echo COMMANDS:
	@cd COMMANDS; $(MAKE)

empcom.a:       $(EMPCOM)

empire:         FRC
	@echo EMPIRE:
	@cd EMPIRE; $(MAKE)

empcre:         FRC
	@echo EMPCRE:
	@cd EMPCRE; $(MAKE)

$(BINDIR)/empfix:       empfix

empfix:         FRC
	@echo EMPFIX:
	@cd EMPFIX; $(MAKE)

$(EMPS):        FRC
	@echo EMPN: $(@F);              # 4.2 change $(@F) to $@
	@cd EMPN; $(MAKE) $(@F);        # 4.2 change $(@F) to $@

emp1:   $(BINDIR)/emp1

emp2:   $(BINDIR)/emp2

emp3:   $(BINDIR)/emp3

emp4:   $(BINDIR)/emp4

emp5:   $(BINDIR)/emp5

emp7:   $(BINDIR)/emp7

.PRECIOUS:	$(EMPSUB) $(EMPCOM)

FRC:

install: 
	-mkdir $(DESTDIR)
	-mkdir $(DESTBIN)
	-mkdir $(DESTINF)
	-mkdir $(DESTDAT)
	-cp $(BINDIR)/* $(DESTBIN)
	-cp $(INFODIR)/* $(DESTINF)
	-cp empire empcre $(DESTDIR)
	-chown $(OWNPID) $(DESTBIN) $(DESTINF) $(DESTBIN) $(DESTDAT) $(DESTDIR)/empcre $(DESTDIR)/empire
	-chgrp $(OWNGRP) $(DESTBIN) $(DESTINF) $(DESTBIN) $(DESTDAT) $(DESTDIR)/empire $(DESTDIR)/empcre
	-chmod 4755 $(DESTDIR)/empire $(DESTDIR)/empcre
	-chmod 755 $(DESTBIN) $(DESTINF) $(DESTDAT) $(DESTDIR) $(DESTBIN)/*
	-chmod 644 $(DESTINF)/*
	
clean:
	-rm -r core $(LIBDIR)/*
	-for i in $(SUBDIRS); do (cd $$i; make clean);done
SHAR_EOF
fi # end of overwriting check
if test -f 'COMMANDS/Makefile'
then
	echo shar: will not over-write existing file "'COMMANDS/Makefile'"
else
cat << \SHAR_EOF > 'COMMANDS/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../_unix.O
LIB=$(INSDIR)/empcom.a
OBJS=\
        $(LIB)(acce.o) \
        $(LIB)(add.o) \
        $(LIB)(assa.o) \
        $(LIB)(atta.o) \
        $(LIB)(boar.o) \
        $(LIB)(buil.o) \
        $(LIB)(cens.o) \
        $(LIB)(chan.o) \
        $(LIB)(chec.o) \
        $(LIB)(coll.o) \
        $(LIB)(cont.o) \
        $(LIB)(coun.o) \
        $(LIB)(decl.o) \
        $(LIB)(defe.o) \
        $(LIB)(deli.o) \
        $(LIB)(desi.o) \
        $(LIB)(diss.o) \
        $(LIB)(enli.o) \
        $(LIB)(fire.o) \
        $(LIB)(flee.o) \
        $(LIB)(fly.o) \
        $(LIB)(fore.o) \
        $(LIB)(gran.o) \
        $(LIB)(info.o) \
        $(LIB)(ledg.o) \
        $(LIB)(lend.o) \
        $(LIB)(load.o) \
        $(LIB)(look.o) \
        $(LIB)(map.o) \
        $(LIB)(mine.o) \
        $(LIB)(move.o) \
        $(LIB)(nati.o) \
        $(LIB)(navi.o) \
        $(LIB)(news.o) \
        $(LIB)(offe.o) \
        $(LIB)(powe.o) \
        $(LIB)(rada.o) \
        $(LIB)(rea.o) \
        $(LIB)(real.o) \
        $(LIB)(repa.o) \
        $(LIB)(rout.o) \
        $(LIB)(set.o) \
        $(LIB)(shi.o) \
        $(LIB)(spy.o) \
        $(LIB)(tele.o) \
        $(LIB)(tend.o) \
        $(LIB)(torp.o) \
        $(LIB)(trad.o) \
        $(LIB)(trea.o) \
        $(LIB)(turn.o) \
        $(LIB)(upda.o) \
        $(LIB)(vers.o) \
        $(LIB)(vote.o) \
        $(LIB)(weat.o)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) -I$(HDRDIR) $(?:.o=.c)
	@if [ -s $(LIB) ];\
	then\
		ar r $(LIB) $?;\
	else\
		echo Creating $(LIB);\
		rm -f $(LIB);\
		ar cq $(LIB) $?;\
	fi
	ranlib $(LIB)
	@rm -f $?
	@echo $(LIB) is now up to date
.c.a:;

$(OBJS):        $(HDRDIR)/empdef.h

clobber:
	rm -f $(LIB)

.PRECIOUS:      $(LIB)
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPCRE/Makefile'
then
	echo shar: will not over-write existing file "'EMPCRE/Makefile'"
else
cat << \SHAR_EOF > 'EMPCRE/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=..
LIBDIR=../_unix.O
EMPGLB=$(LIBDIR)/empglb.o
EMPSUB=$(LIBDIR)/empsub.a

$(INSDIR)/empcre:	_unix.O _unix.O/empcre.o $(EMPGLB) $(EMPSUB)
	$(CC) -o $@ -F 4000 _unix.O/empcre.o $(EMPSUB) $(EMPGLB)

_unix.O:
	mkdir _unix.O

_unix.O/empcre.o:       $(HDRDIR)/empdef.h  empcre.c
	$(CC) $(CFLAGS) -I$(HDRDIR) empcre.c
	@mv empcre.o $@

clobber:
	rm -f $(INSDIR)/empcre
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPDIS/Makefile'
then
	echo shar: will not over-write existing file "'EMPDIS/Makefile'"
else
cat << \SHAR_EOF > 'EMPDIS/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../_unix.O
EMPDIS=$(INSDIR)/empdis.o

$(EMPDIS):      $(HDRDIR)/empdef.h  empdis.c
	$(CC) $(CFLAGS) -I$(HDRDIR) empdis.c
	mv empdis.o $@

clobber:
	rm -f $(EMPDIS)
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPFIX/Makefile'
then
	echo shar: will not over-write existing file "'EMPFIX/Makefile'"
else
cat << \SHAR_EOF > 'EMPFIX/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../BIN
LIBDIR=../_unix.O
EMPGLB=$(LIBDIR)/empglb.o
EMPSUB=$(LIBDIR)/empsub.a
LIB=_unix.O/fixlib.a
HDRDEP= \
        $(LIB)(nations.o) \
        $(LIB)(sectors.o) \
        $(LIB)(ships.o) \
        $(LIB)(treats.o) \
        $(LIB)(loans.o)

$(INSDIR)/empfix: _unix.O _unix.O/main.o _unix.O/fixlib.a $(EMPGLB) $(EMPSUB)
	$(CC) -o $(INSDIR)/empfix _unix.O/main.o _unix.O/fixlib.a $(EMPSUB) $(EMPGLB)

_unix.O:
	mkdir _unix.O

empfix: $(INSDIR)/empfix

_unix.O/main.o: $(HDRDIR)/empdef.h main.c
	$(CC) $(CFLAGS) -I$(HDRDIR) main.c
	@mv main.o _unix.O/main.o

$(LIB): \
	$(LIB)(bytefix.o) \
	$(LIB)(chfix.o) \
	$(LIB)(fixup.o) \
	$(LIB)(floatfi.o) \
	$(LIB)(loans.o) \
	$(LIB)(longfix.o) \
	$(LIB)(nations.o) \
	$(LIB)(sectors.o) \
	$(LIB)(ships.o) \
	$(LIB)(treats.o) \
	$(LIB)(wordfix.o)
	$(CC) $(CFLAGS) -I$(HDRDIR) $(?:.o=.c)
	@if [ -s $(LIB) ];\
	then\
		ar r $(LIB) $?;\
	else\
		ar cq $(LIB) $?;\
	fi
	ranlib $(LIB)
	@rm -f $?
.c.a:;

$(HDRDEP):      $(HDRDIR)/empdef.h

clobber:
	rm -f $(INSDIR)/empfix
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPGLB/Makefile'
then
	echo shar: will not over-write existing file "'EMPGLB/Makefile'"
else
cat << \SHAR_EOF > 'EMPGLB/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../_unix.O
EMPGLB=$(INSDIR)/empglb.o

$(EMPGLB):      $(HDRDIR)/empdef.h  empglb.c
	$(CC) $(CFLAGS) -I$(HDRDIR) empglb.c
	mv empglb.o $@

clobber:
	rm -f $(EMPGLB)
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPIRE/Makefile'
then
	echo shar: will not over-write existing file "'EMPIRE/Makefile'"
else
cat << \SHAR_EOF > 'EMPIRE/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=..
LIBDIR=../_unix.O
EMPGLB=$(LIBDIR)/empglb.o
EMPSUB=$(LIBDIR)/empsub.a

$(INSDIR)/empire:  _unix.O _unix.O/empire.o $(EMPGLB) $(EMPSUB)
	$(CC) -o $@ _unix.O/empire.o $(EMPSUB) $(EMPGLB)

_unix.O:
	mkdir _unix.O

_unix.O/empire.o:       $(HDRDIR)/empdef.h  empire.c
	$(CC) $(CFLAGS) -I$(HDRDIR) empire.c
	@mv empire.o $@

clobber:
	rm -f $(INSDIR)/empire
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPN/Makefile'
then
	echo shar: will not over-write existing file "'EMPN/Makefile'"
else
cat << \SHAR_EOF > 'EMPN/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../BIN
LIBDIR=../_unix.O
EMPDIS=$(LIBDIR)/empdis.o
EMPCOM=$(LIBDIR)/empcom.a
EMPSUB=$(LIBDIR)/empsub.a
EMPGLB=$(LIBDIR)/empglb.o

IMODS=\
        $(INSDIR)/emp1 \
        $(INSDIR)/emp2 \
        $(INSDIR)/emp3 \
        $(INSDIR)/emp4 \
        $(INSDIR)/emp5 \
        $(INSDIR)/emp7

empn:   $(IMODS)

emp1:   $(INSDIR)/emp1

emp2:   $(INSDIR)/emp2

emp3:   $(INSDIR)/emp3

emp4:   $(INSDIR)/emp4

emp5:   $(INSDIR)/emp5

emp7:   $(INSDIR)/emp7

$(INSDIR)/emp1:	_unix.O $(EMPDIS) _unix.O/emp1.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp1.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

$(INSDIR)/emp2:	_unix.O $(EMPDIS) _unix.O/emp2.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp2.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

$(INSDIR)/emp3:	_unix.O $(EMPDIS) _unix.O/emp3.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp3.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

$(INSDIR)/emp4:	_unix.O $(EMPDIS) _unix.O/emp4.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp4.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

$(INSDIR)/emp5:	_unix.O $(EMPDIS) _unix.O/emp5.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp5.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

$(INSDIR)/emp7:	_unix.O $(EMPDIS) _unix.O/emp7.o $(EMPCOM) $(EMPSUB) $(EMPGLB)
	$(CC) -o $@ -F 2000 $(EMPDIS) _unix.O/emp7.o ../_unix.O/pr.o $(EMPCOM) $(EMPSUB) $(EMPGLB) -lm

_unix.O:
	mkdir _unix.O

_unix.O/emp1.o: emp1.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp1.c
	@mv emp1.o $@

_unix.O/emp2.o: emp2.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp2.c
	@mv emp2.o $@

_unix.O/emp3.o: emp3.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp3.c
	@mv emp3.o $@

_unix.O/emp4.o: emp4.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp4.c
	@mv emp4.o $@

_unix.O/emp5.o: emp5.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp5.c
	@mv emp5.o $@

_unix.O/emp7.o: emp7.c $(HDRDIR)/empdef.h
	$(CC) $(CFLAGS) -I$(HDRDIR) emp7.c
	@mv emp7.o $@
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPSUBS/Makefile'
then
	echo shar: will not over-write existing file "'EMPSUBS/Makefile'"
else
cat << \SHAR_EOF > 'EMPSUBS/Makefile'
CFLAGS=-c -O
HDRDIR=../hdrs
INSDIR=../_unix.O
LIB=$(INSDIR)/empsub.a
HDRDEP=\
        $(LIB)(chkok.o) \
        $(LIB)(cleared.o) \
        $(LIB)(cname.o) \
        $(LIB)(cnumb.o) \
        $(LIB)(damage.o) \
        $(LIB)(erlog.o) \
        $(LIB)(getloan.o) \
        $(LIB)(getmysect.o) \
        $(LIB)(getmyship.o) \
        $(LIB)(getnat.o) \
        $(LIB)(getrel.o) \
        $(LIB)(getsect.o) \
        $(LIB)(getship.o) \
        $(LIB)(getsno.o) \
        $(LIB)(gettre.o) \
        $(LIB)(landgun.o) \
        $(LIB)(landorsea.o) \
        $(LIB)(mailbox.o) \
        $(LIB)(mtch.o) \
        $(LIB)(natarg.o) \
        $(LIB)(neigh.o) \
        $(LIB)(nreport.o) \
        $(LIB)(nxtsct.o) \
        $(LIB)(nxtshp.o) \
        $(LIB)(pr.o) \
        $(LIB)(prdate.o) \
        $(LIB)(sargs.o) \
        $(LIB)(sread.o) \
        $(LIB)(tfact.o) \
        $(LIB)(trechk.o) \
        $(LIB)(update.o) \
        $(LIB)(wethr.o) \
        $(LIB)(wu.o)

$(LIB): \
	$(LIB)(atoip.o) \
	$(LIB)(atopi.o) \
	$(LIB)(chkok.o) \
	$(LIB)(cleared.o) \
	$(LIB)(cname.o) \
	$(LIB)(cnumb.o) \
	$(LIB)(copy.o) \
	$(LIB)(damage.o) \
	$(LIB)(erlog.o) \
	$(LIB)(getbit.o) \
	$(LIB)(getele.o) \
	$(LIB)(getloan.o) \
	$(LIB)(getlogn.o) \
	$(LIB)(getmysect.o) \
	$(LIB)(getmyship.o) \
	$(LIB)(getnat.o) \
	$(LIB)(getrel.o) \
	$(LIB)(getsect.o) \
	$(LIB)(getship.o) \
	$(LIB)(getshno.o) \
	$(LIB)(getsno.o) \
	$(LIB)(getstar.o) \
	$(LIB)(getstri.o) \
	$(LIB)(gettre.o) \
	$(LIB)(idist.o) \
	$(LIB)(landgun.o) \
	$(LIB)(landorsea.o) \
	$(LIB)(mailbox.o) \
	$(LIB)(max127.o) \
	$(LIB)(mtch.o) \
	$(LIB)(myeuid.o) \
	$(LIB)(myruid.o) \
	$(LIB)(natarg.o) \
	$(LIB)(neigh.o) \
	$(LIB)(nreport.o) \
	$(LIB)(nxtsct.o) \
	$(LIB)(nxtshp.o) \
	$(LIB)(onearg.o) \
	$(LIB)(plur.o) \
	$(LIB)(pr.o) \
	$(LIB)(prdate.o) \
	$(LIB)(prmptrd.o) \
	$(LIB)(pslsin.o) \
	$(LIB)(resetuid.o) \
	$(LIB)(round.o) \
	$(LIB)(same.o) \
	$(LIB)(sargs.o) \
	$(LIB)(sigsave.o) \
	$(LIB)(sread.o) \
	$(LIB)(tfact.o) \
	$(LIB)(trechk.o) \
	$(LIB)(ttyn.o) \
	$(LIB)(update.o) \
	$(LIB)(wethr.o) \
	$(LIB)(wu.o) \
	$(LIB)(xwrap.o) \
	$(LIB)(xytoa.o)
	$(CC) $(CFLAGS) -I$(HDRDIR) $(?:.o=.c)
	@if [ -s $(LIB) ];\
	then\
		ar r $(LIB) $?;\
	else\
		echo Creating $(LIB);\
		rm -f $(LIB);\
		ar cq $(LIB) `lorder $? | tsort`;\
	fi
	ranlib $(LIB)
	$(CC) $(CFLAGS) -I$(HDRDIR) pr.c
	mv pr.o $(INSDIR)
	@rm -f $?
	@echo $(LIB) is now up to date
.c.a:;

$(HDRDEP):      $(HDRDIR)/empdef.h

clobber:
	rm -f $(LIB)

.PRECIOUS:      $(LIB)
SHAR_EOF
fi # end of overwriting check
if test -f 'COMMANDS/spy.c'
then
	echo shar: will not over-write existing file "'COMMANDS/spy.c'"
else
cat << \SHAR_EOF > 'COMMANDS/spy.c'
#define D_ICHRSTR
#define D_NEWSVERBS
#define D_TRTYCLAUSE
#define D_NATSTAT
#define D_SECTDES
#define D_DCHRSTR
#define D_UPDATE
#define D_SCTSTR
#define D_NSCSTR
#define D_FILES
#include        "empdef.h"

spy()
{
        register        i, j;
        char    chart[36][36], *cname(), *xytoa();
        int     slx, shx, sly, shy, spies, k, vnum;
        int     nsects, pkgs, xoff, yoff, temp;
        struct  nstr    nsct;

        if( snxtsct(&nsct, argp[1]) == -1 ) return(SYN_RETURN);
        slx = nsct.n_lx - nsct.n_ix;
        shx = nsct.n_hx + nsct.n_ix;
        sly = nsct.n_ly - nsct.n_iy;
        shy = nsct.n_hy + nsct.n_iy;
        if( (shx - slx) * nsct.n_ix >= 36 ) goto X204;
        if( (shy - sly) * nsct.n_iy < 36 ) goto X214;
X204:   
        printf("Too large an area (max range is 32)");
        return(SYN_RETURN);
X214:   
        xoff = (slx < shx) ? slx : shx;
        yoff = (sly < shy) ? sly : shy;
        j = sly;
        goto X370;
X276:   
        i = slx;
        goto X344;
X304:   
        chart[i-xoff][j-yoff] = 0;
        i += nsct.n_ix;
X344:   
        if( i != shx ) goto X304;
        j += nsct.n_iy;
X370:   
        if( j != shy ) goto X276;
        goto X646;
X410:   
        if( owner == 0 ) goto X646;
        chart[nsct.n_x-xoff][nsct.n_y-yoff] = -128;
        chart[nsct.n_x-xoff][nsct.n_y-yoff-1]++;
        chart[nsct.n_x-xoff][nsct.n_y-yoff+1]++;
        chart[nsct.n_x-xoff-1][nsct.n_y-yoff]++;
        chart[nsct.n_x-xoff+1][nsct.n_y-yoff]++;
X646:   
        if( nxtsct(&nsct, UP_NONE) >  0 ) goto X410;
        nsects = 0;
        j = sly;
        goto X2722;
X704:   
        i = slx;
        goto X2702;
X714:   
        spies = chart[i-xoff][j-yoff];
        if( spies >  0 ) goto X760;
        goto X2674;
X760:   
        getsect(i, j, UP_NONE);
        if( owner == 0 ) goto X1006;
        goto X2674;
X1006:  
        if( sect.sct_owned != 0 ) goto X1030;
        if( sect.sct_desig > S_RURAL ) goto X1030;
        goto X2674;
X1030:  
        vnum = sect.sct_owned;
        if( vnum == 0 ) goto X1076;
        if( trechk(cnum, vnum, TRTSPY) != -1 ) goto X1076;
        goto X2674;
X1076:  
/*	Done to make the microslop Xenix  c compiler happy */
        temp = rand();
        if( sect.sct_milit >  temp%((spies * 100) + 100) ) goto X1144;
        goto X1644;
X1144:  
        if( nstat != STAT_GOD ) goto X1160;
        goto X1644;
X1160:  
        k = getrel(vnum, cnum);
        if( k != ALLIED ) goto X1214;
        goto X1644;
X1214:  
        if( k == AT_WAR ) goto X1350;
        printf("Spy deported from %d,%d.\n", i, j);
        if( vnum != 0 ) goto X1260;
        goto X2674;
X1260:  
        sprintf(fmtbuf,"%s spy deported from %s\n", cname(cnum), xytoa(i, j, vnum));
        wu(0, vnum, fmtbuf);
        goto X2674;
X1350:  
        neigh(i, j, cnum, 0);
        getsect(nbrx, nbry, UP_ALL);
        if( sect.sct_milit == 0 ) goto X1430;
        sect.sct_milit--;
        goto X1434;
X1430:  
        sect.sct_civil--;
X1434:  
        putsect(nbrx, nbry);
        printf("BANG!! a spy from %d,%d was shot in %d,%d!\n", nbrx, nbry, i, j);
        if( vnum != 0 ) goto X1522;
        goto X2674;
X1522:  
        nreport(cnum, N_SPY_SHOT, vnum);
        sprintf(fmtbuf,"%s spy from %s shot in %s\n", cname(cnum), xytoa(nbrx, nbry, vnum), xytoa(i, j, vnum));
        wu(0, vnum, fmtbuf);
        goto X2674;
X1644:  
        if( nsects++ != 0 ) goto X1670;
        printf("  sect   #    eff  civ mil  shl  gun  ore  pln\n");
X1670:  
        if( curup - sect.sct_lstup <= 3 ) goto X1724;
        update(i, j, UP_ALL);
X1724:  
        printf("%3d,%-3d%3d ", i, j, sect.sct_owned);
        if( wethr(i, j, 0) >= 700 ) goto X2026;
        if( nstat == STAT_GOD ) goto X2026;
        printf("   No report due to bad weather.\n");
        goto X2674;
X2026:  
        pkgs = dchr[sect.sct_desig].d_pkg;
        k = 12;
        printf("%c %3d%% %4d", dchr[sect.sct_desig].d_mnem, round(sect.sct_effic, 10), round(sect.sct_civil, 10) * ichr[k].i_pkg[pkgs]);
        k = 13;
        printf(" %3d", round(sect.sct_milit, 10) * ichr[k].i_pkg[pkgs]);
        k = 14;
        printf(" %4d", round(sect.sct_shell, 10) * ichr[k].i_pkg[pkgs]);
        k = 15;
        printf(" %4d", round(sect.sct_guns, 5) * ichr[k].i_pkg[pkgs]);
        k = 17;
        printf(" %4d", round(sect.sct_ore, 10) * ichr[k].i_pkg[pkgs]);
        k = 16;
        printf(" %3d\n", round(sect.sct_plane, 3) * ichr[k].i_pkg[pkgs]);
X2674:  
        i += nsct.n_ix;
X2702:  
        if( i == shx ) goto X2714;
        goto X714;
X2714:  
        j += nsct.n_iy;
X2722:  
        if( j == shy ) goto X2734;
        goto X704;
X2734:  
        ntused = ntused + (nsects * .25) + .5;
        return(NORM_RETURN);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPCRE/empcre.c'
then
	echo shar: will not over-write existing file "'EMPCRE/empcre.c'"
else
cat << \SHAR_EOF > 'EMPCRE/empcre.c'
#define D_FILES
#define D_NATSTAT
#define D_NATSTR
#define D_SCTSTR
#define D_DCHRSTR
#define PERCENT_MOUNT	6
#define PERCENT_SEA		30
#include        "empdef.h"
#include        <stdio.h>

char    thispro;
struct  {
        int     f1;
        int     f2;
        int     f3;
} elev[4] = { 3, 8, 0, 1, 10, 0, 3, 42, 0, 0, 40, 0 };
int     testfla, tracefl, creamfl;
extern  double  up_offset;
char    powbuf[48];
struct  {
        int     x;
        int     y;
} volc[400], gold[400], river[400];


main(argc, argv)
int     argc;
char    *argv[];
{
        register int i, j, k;
        double  pslsin();
        char    *mailbox();
        int     nvolc, ngold, nriver, d, e, st, r;
        int     sep, type[23], elmax, elmin, elsc, elcnts[1024];
        int     rx, ry, nx, ny, dx, dy, temp;
        int     stripsiz,mountheight,seadepth,sum=0;
	int	dist, dfact;
        long    now, sectsiz;
        struct  sctstr  scts[128];

        sectsiz = sizeof(sect);
	for( i = 0; i < 128; i++ ) {
		scts[i].sct_owned = scts[i].sct_desig = scts[i].sct_effic = 0;
		scts[i].sct_miner = scts[i].sct_gmin = scts[i].sct_prdct = 0;
		scts[i].sct_mobil = scts[i].sct_chkpt = 0;
		scts[i].sct_dfend = scts[i].sct_contr = scts[i].sct_civil = 0;
		scts[i].sct_milit = scts[i].sct_shell = scts[i].sct_guns = 0;
		scts[i].sct_plane = scts[i].sct_ore = scts[i].sct_gold = 0;
		scts[i].sct_c_use = scts[i].sct_m_use = scts[i].sct_s_use = 0;
		scts[i].sct_g_use = scts[i].sct_p_use = scts[i].sct_o_use = 0;
		scts[i].sct_b_use = 0;
		scts[i].sct_p_stage = scts[i].sct_p_time = 0;
		scts[i].sct_lstup = 0;
	}
	for( i = 0; i < 1024; i++ ) elcnts[i] = 0;
	for( i = 0; i < 23; i++ ) type[i] = 0;
	for( i = 0; i < 48; i++ ) powbuf[i] = 0;
        time(&now);
        srand((unsigned int)now);
        while( --argc > 0 ) {
                if( argv[argc][0] == '-' ) {
                        if( argv[argc][1] == 's' &&
                            argv[argc][2] == '=' ) {
                                strcpy(sectfil, &argv[argc][3]);
                                testfla++;
                        } else if( argv[argc][1] == 't' ) {
                                tracefl++;
                        } else if( argv[argc][1] == 'c' ) {
                                creamfl++;
                        } else goto usage;
                } else if( argv[argc][0] >= '0'  &&
                    argv[argc][0] <= '9' ) {
                        srand((unsigned int)atoi(argv[argc]));
                } else {
usage:                  printf("Usage: %s [randnum] [-s=sectfil] [-trace] [-cream]\n", argv[0]);
                        exit(2);
                }
        }
        up_offset =  now/1800L - 1; /* minimum curup is 1 */
        if( !testfla ) {
                if( (natf = make( natfil )) < 0 ) exit(1);
                printf("Name for Country 0? ");
                fflush(stdout);
                nat.nat_cnam[read(0, nat.nat_cnam, 20)-1] = '\0';
                printf("Representative's name? ");
                fflush(stdout);
                nat.nat_pnam[sread(nat.nat_pnam, 20)-1] = '\0';
                nat.nat_stat = STAT_GOD;
                nat.nat_btu = 127;
                nat.nat_nuid = getuid();
                nat.nat_money = 12345;
                nat.nat_up_off = up_offset;
                write(natf, &nat, sizeof(nat));
                printf("\nAll praise to %s!\n", nat.nat_cnam);
                for( i=0; i<20; i++ ) {
                        nat.nat_cnam[i] = nat.nat_pnam[i] = '\0';
                }
                nat.nat_stat = nat.nat_btu = 0;
                for( i=1; i<maxnoc; i++ ) {
                        write(natf, &nat, sizeof(nat));
                }
                close(natf);
        }
        nvolc = ((long)w_xsize * (long)w_ysize)/166 + 2; 
        ngold = ((long)w_xsize * (long)w_ysize)/333 + 2;
        nriver = ((long)w_xsize * (long)w_ysize)/100 + 2; 
		if (((long)w_xsize+(long)w_ysize)>128) 
		{
			nvolc*=2;
			ngold*=3;
		} 
        printf("Volcanos\n");
        sep = w_xsize/4 +  w_ysize/4; 
        k = nvolc;
        while( --k >= 0 ) {
                j = 10;
vloop:          volc[k].x = (rand()>>2) % (w_xsize-1);
                volc[k].y = (rand()>>2) % (w_ysize-1);
                i = nvolc;
                while( --i > k ) {
                        if( sep <= cdst(&volc[i], &volc[k]) ) continue;
                        if( --j < 0 ) {
                                sep--;
                                j = 9;
                        }
                        goto vloop;
                }
                printf("V%d\t%2d,%d [sep = %d]\n", k, volc[k].x, volc[k].y, sep);
        }
        printf("gold strikes\n");
        k = ngold;
        while( --k >= 0 ) {
                gold[k].x = (rand()>>2) % (long)w_xsize;
                gold[k].y = (rand()>>2) % (long)w_ysize;
                printf("%2d,%2d\n", gold[k].x, gold[k].y);
        }
        if( (sectf = make(sectfil)) < 0 ) exit(1);
        close(sectf);
        printf("Determine sector types");
        sectf = open(sectfil, O_RDWR);
        stripsiz = (long)w_xsize * sectsiz;
        elmax = 0;
        elmin = 32767;
        for( j=0; j < (long)w_ysize; j++ ) {
                for( i=0; i < (long)w_xsize; i++ ) {
                        d = rand() % 10;
                        for( k=0; k<=nvolc; k++ ) {
						if (w_xsize+w_ysize>128)
						{
							d+=2000/(dst(i-volc[k].x,j-volc[k].y)+rand()%4+2);
						} else {
							d+=1500/(dst(i-volc[k].x,j-volc[k].y)+rand()%4+2);
						}
                        }
                        e = pslsin(d*166) * 45.;
                        scts[i].sct_miner = rand() % 11 + e + 45;
                        e = rand() % 3;
			dfact = ( (long)w_xsize > (long)w_ysize ) ? (long)w_xsize : (long)w_ysize; 
			dfact = dfact/16 + 1; 
                        for( k=0; k<=ngold; k++ ) {
				dist = dfact * dst(i-gold[k].x, j-gold[k].y);
				temp=(dist+rand()%5+5);
				if (w_xsize+w_ysize>128) temp*=w_xsize/64;
				e+=5000/temp;
                        }
			scts[i].sct_gmin = max127(e/14 + rand()%29);
                        scts[i].sct_lstup = d;
                        if( d > elmax ) elmax = d;
                        if( d < elmin ) elmin = d;
                }
                write( sectf, scts, stripsiz );
                printf("...");
                fflush(stdout);
        }
        printf("\n");
        i = elmax;
        i -= elmin;
        elsc = i/1024 + 1;
        lseek(sectf, 0L, 0);
        for( j=0; j < (long)w_ysize; j++ ) {
                read(sectf, scts, stripsiz);
                for( i=0; i < (long)w_xsize; i++ ) {
                        k = (scts[i].sct_lstup - elmin)/elsc;
                        elcnts[k]++;
                }
        }
		for (k=1023 ; k>0 ; k--)
		{
			sum=sum+elcnts[k];
			if (((((sum/(long)w_xsize)*100)/(long)w_ysize))>PERCENT_MOUNT)
			{
				mountheight=k;
				sum=0;
				break;
			}
		}
		for (k=0 ; k<1024 ; k++)
		{
			sum=sum+elcnts[k];
			if (((((sum/(long)w_xsize)*100)/(long)w_ysize))>PERCENT_SEA)
			{
				seadepth=k;
				break;
			}
		}
        lseek(sectf, 0L, 0);
        for( j=0; j < (long)w_ysize; j++ ) {
                read(sectf, scts, stripsiz);
                for( i=0; i < (long)w_xsize; i++ ) {
					k=(scts[i].sct_lstup-elmin)/elsc;
					if (k>mountheight)
					{
						scts[i].sct_desig=1;
						scts[i].sct_miner = scts[i].sct_gmin=0;
						type[1]++;
					}
					else if (k<seadepth)
					{
						scts[i].sct_desig=0;
						scts[i].sct_miner = scts[i].sct_gmin=0;
						type[0]++;
					}
					else 
					{
						scts[i].sct_desig=3;
						type[3]++;
					}



/*                        d = scts[i].sct_lstup;
                        for( k=0; elev[k].f3 > 0; k++ ) {
                                if( d > elev[k].f3 ) break;
                        }
                        st = elev[k].f1;
                        if( st == 1 || st == 0 ) {
                                scts[i].sct_miner = scts[i].sct_gmin = 0;
                        }
                        scts[i].sct_desig = st;
                        type[st]++; */



                        if( tracefl ) {
                                printf("%c", " ^s-"[st]);
                        }
                }		
                lseek(sectf, (long)(-stripsiz), 1);
                write(sectf, scts, stripsiz);
                if( tracefl ) printf("\n");
        }
        printf("\nRivers\n");
        k = nriver;
        while( --k >= 0 ) {
rloop:          river[k].x = (rand()>>2) % (long)(w_xsize);
                river[k].y = (rand()>>2) % (long)(w_ysize);
                i = nvolc;
                while( --i >= 0 ) {
                        if( cdst(&river[k], &volc[i]) <  5 ) break;
                }
                if( i < 0 ) goto rloop;
                printf("R%d\t%2d,%d\n", k, river[k].x, river[k].y);
        }
        for( k=nriver; k >= 0; k-- ) {
                nx = river[k].x;
                ny = river[k].y;
                e = 9999;
                i = 0;
makeriv:        getsect(rx=nx, ry=ny);
                type[sect.sct_desig]--;
                type[0]++;
                sect.sct_desig = 0;
                putsect(rx, ry);
                i++;
                for( dx = -1; dx <= 1; dx++ ) {
                        for( dy = -1; dy <= 1; dy++ ) {
                                if( dy != 0 || dx != 0 ) {
                                        getsect(rx+dx, ry+dy);
                                        if( sect.sct_lstup  <= e ) {
                                                if( sect.sct_desig == 0 ) continue;
                                                e = sect.sct_lstup;
                                                nx = rx + dx;
                                                ny = ry + dy;
                                        }
                                }
                        }
                }
                if( nx != rx || ny != ry ) goto makeriv;
                printf("River %d is %d long\n", k, i);
        }
        lseek(sectf, 0L, 0);
        for( j=0; j < (long)w_ysize; j++ ) {
                for( i=0; i < (long)w_xsize; i++ ) {
                        read(sectf, &sect, sizeof(sect));
                        sect.sct_lstup = 0;
                        lseek(sectf, -sectsiz, 1);
                        write(sectf, &sect, sizeof(sect));
                }
        }
        lseek(sectf, 0L, 0);
        read(sectf, &sect, sizeof(sect));
        sect.sct_desig = 2;
        sect.sct_effic = 99;
        sect.sct_civil = 127;
        lseek(sectf, 0L, 0);
        write(sectf, &sect, sizeof(sect));
        close(sectf);
        d = (long)w_xsize * (long)w_ysize;
        for( k=0; k < 23; k++ ) {
                if( type[k] <= 0 ) continue;
                printf("%3d %-16.16s (%.1f%%)\n", type[k],
                        dchr[k].d_name, (type[k] * 100.)/d );
        }
        if( testfla ) exit(1);
        close(make(shipfil));
        powf = make(powfil);
        write(powf, powbuf, sizeof(long));
        for( i=maxnoc; i >= 0; i-- ) {
                close(creat(mailbox(i), 0600));
                write(powf, powbuf, sizeof(powbuf));
        }
        close(powf);
        close(make(treatfil));
        close(make(loanfil));
        close(make(newsfil));
}

make(file)
char    *file;
{
        register        fh;

        if( !creamfl ) {
                if( (fh = open(file, O_RDONLY)) >= 0 ) {
                        printf("%s already exists.  Remove it to do creation\n", file);
                        exit(1);
                }
        }
        if( (fh = creat(file, 0600)) < 0 ) {
                printf("Creation of %s failed.\n", file);
        }
        return(fh);
}

cdst(p0, p1)
short   p0[], p1[];
{
        return(dst(p0[0]-p1[0], p0[1]-p1[1]));
}

dst(x, y)
int     x, y;
{
        register        int     dx, dy;

        dx = xwrap(x);
        dy = ywrap(y);
        if( dx < 0 ) dx = -dx;
        if( dy < 0 ) dy = -dy;
        if( dx <= dy ) return(dy + (dx>>1));
        return(dx + (dy>>1));
}

getsect(i, j)
int     i, j;
{
        register        k;
        long    addr,tempx,tempy;

		tempx=(long)w_xsize;
		tempy=(long)w_ysize;
        k = ((tempy + j + capy)%tempy) * tempx + (tempx + i + capx)%tempx;
        addr = (long)k * sizeof(sect);
        lseek(sectf, addr, 0);
        if( read(sectf, &sect, sizeof(sect)) >= sizeof(sect) ) return;
        printf("Ooops, couldn't read sector %d,%d\n", i, j);
        exit(3);
}

putsect(i, j)
int     i, j;
{
        register        k;
        long    addr,tempx,tempy;

		tempx=(long)w_xsize;
		tempy=(long)w_ysize;
        k = ((tempy + j + capy)%tempy) * tempx + (tempx + i + capx)%tempx;

        addr = (long)k * sizeof(sect);
        lseek(sectf, addr, 0);
        write(sectf, &sect, sizeof(sect));
        return;
}
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPDIS/empdis.c'
then
	echo shar: will not over-write existing file "'EMPDIS/empdis.c'"
else
cat << \SHAR_EOF > 'EMPDIS/empdis.c'
#define D_SCTSTR
#define D_SECTDES
#define D_NATSTAT
#define D_NATSTR
#define D_COMSTR
#define D_UPDATE
#define D_FILES
#include "empdef.h"

#ifdef  BSD
#include        <sys/time.h>
#else
#include        <time.h>
#endif  		/* BSD */

#include        <stdio.h>

extern  int     thisprog;
extern int acce(), add(), assa(), atta(), boar(), buil(), cens(), chan(),
           chec(), coll(), cont(), coun(), decl(), defe(), deli(), desi(), diss(),
           enli(), fire(), flee(), fly(), fore(), gran(), head(), info(),
           ledg(), lend(), load(), look(), map(), mine(), move(), nati(),
           navi(), news(), offe(), powe(), rada(), rea(), real(), repa(),
           rout(), set(), shi(), spy(), tele(), tend(), torp(), trad(),
           trea(), turn(), upda(), vers(), vote(), weat();

struct comstr coms[] = {
"accept (loan)",        5,      2,      acce,   STAT_NORMAL,
"add [a new country]",  7,      0,      add,                    STAT_GOD,
"assault (sect) [from ship]",   3,      2,      assa,   STAT_NORMAL,
"attack (sect) [from sect]",    3,      2,      atta,   STAT_NORMAL,
"board (ship) [from ship]",     3,      2,      boar,   STAT_NORMAL,
"build [ships in] (sects) <type>",      4,      2,      buil,   STAT_NORMAL,
"bye [log-off]",        9,      0,      (int (*)())100, STAT_DEAD,
"census [on] (sects)",  1,      0,      cens,   STAT_NOCAP,
"change country/representative/user",   2,      0,      chan,   STAT_NOCAP,
"checkpoint (sects)",   2,      2,      chec,   STAT_NORMAL,
"collect [on] (loan)",  5,      2,      coll,   STAT_NORMAL,
"command list [brief]", 10,     0,      (int (*)())3,   STAT_DEAD,
"contract [in] (sector)",       5,      2,      cont,   STAT_NORMAL,
"country roster",       1,      0,      coun,   STAT_VISITOR,
"declare ally/neutral/war (cno/cname)", 2,      2,      decl,   STAT_NOCAP,
"defend (sects)",       2,      2,      defe,   STAT_NORMAL,
"deliver (item) (sects) <thresh/->",    1,      1,      deli,   STAT_NOCAP,
"designate (sects)",    1,      1,      desi,   STAT_NOCAP,
"dissolve [government]",        7,      0,      diss,   STAT_NOCAP,
"enlist [in] (sects)",  2,      2,      enli,   STAT_NORMAL,
"execute [commands from] file", 10,     0,      (int (*)())5,   STAT_NOCAP,
"fire [on] (sect/ship)",        3,      2,      fire,   STAT_NORMAL,
"fixup [nations, sectors, etc]",        98,     0,      (int (*)())100, STAT_GOD,
"fleetadd (fleet) (ships/fleet)",       4,      1,      flee,   STAT_NORMAL,
"fly [mission from] (sect/ship)",       7,      2,      fly,    STAT_NORMAL,
"forecast [weather in] (sects)",        1,      1,      fore,   STAT_NOCAP,
"grant (sects) [to country]",   2,      1,      gran,   STAT_NOCAP,
"headlines <days> [from \"news\"]",     2,      0,      head,   STAT_VISITOR,
"info [on] (topic)",    1,      0,      info,   STAT_VISITOR,
"ledger [loan report]", 5,      0,      ledg,   STAT_NOCAP,
"lend [money to] (cno/cname)",  5,      2,      lend,   STAT_NOCAP,
"list of commands",     10,     0,      (int (*)())3,   STAT_DEAD,
"load (ships/fleet)",   4,      2,      load,   STAT_NORMAL,
"lookout [from] (ships/fleet/sects)",   4,      2,      look,   STAT_NOCAP,
"map [from] (sect)",    1,      1,      map,    STAT_NOCAP,
"mine [from] (ship)",   4,      2,      mine,   STAT_NORMAL,
"move c/m/s/g/p/o/b",   1,      2,      move,   STAT_NORMAL,
"nation [report]",      1,      0,      nati,   STAT_NOCAP,
"navigate (ships/fleet)",       4,      2,      navi,   STAT_NORMAL,
"newspaper <days>",     2,      0,      news,   STAT_VISITOR,
"offer [treaty to] (cno/cname)",        2,      2,      offe,   STAT_NOCAP,
"power report", 2,      0,      powe,   STAT_VISITOR,
"radar [from] (ships/fleet/sect)",      4,      2,      rada,   STAT_NOCAP,
"read telegrams",       1,      0,      rea,    STAT_NOCAP,
"realm (number) <(sects)>",     1,      0,      real,   STAT_NOCAP,
"repay (loan)", 5,      2,      repa,   STAT_NORMAL,
"route [delivery] (item) (sects)",      1,      1,      rout,   STAT_NOCAP,
"set [price] (ships/fleet/sects) (item)",       5,      2,      set,    STAT_NOCAP,
"shell [spawn a subshell]",     99,     0,      (int (*)())100, STAT_NOCAP,
"ship report [on] (ships/fleet/sects)", 4,      1,      shi,    STAT_NOCAP,
"spy [on] (sects)",     2,      1,      spy,    STAT_NOCAP,
"telegram [to] (cno/cname) <file>",     1,      0,      tele,   STAT_NOCAP,
"tend (ship)",  4,      2,      tend,   STAT_NORMAL,
"torpedo (ship)",       3,      2,      torp,   STAT_NORMAL,
"trade [report] <land | naval>",        5,      2,      trad,   STAT_NOCAP,
"treaty report",        2,      1,      trea,   STAT_NOCAP,
"turn [the game] (on|off)",     7,      0,      turn,   STAT_GOD,
"unload (ship/fleet)",  4,      2,      load,   STAT_NORMAL,
"update (sects) <quiet | verbose>",     1,      1,      upda,   STAT_NOCAP,
"version [identification]",     7,      0,      vers,   STAT_VISITOR,
"vote [on] (treaty)",   2,      2,      vote,   STAT_NORMAL,
"weather [map for] (sects)",    1,      0,      weat,   STAT_NOCAP,
0,      0,      0,      0,      0,
};

main(argc, argv)
int     argc;
char    **argv;
{
        register        n;
        int port, bye();
        struct  tm      *nowtime;
        long now;
        double timu, init_na();
        char    *copy();

/*
        setbuf(stdout, (char *)NULL);
*/
        argv[0] = (char *)-1;
        if( (cnum = argv[1][0] - '0' - 1) < 0 ) goto X44;
        if( cnum <= maxcno ) goto X64;
X44:    
        printf("Sorry, Empire problems\n");
        exit(2);
X64:    
        if( (redirin = argv[3][0] - '0' - 1) >= 0 ) goto X114;
        exit(-1);
X114:   
        init_fi();
        if( getnat(0) != -1 ) goto X144;
        exit(3);
X144:   
        up_offset = nat.nat_up_off;
        time(&now);
        curup = now/1800. - up_offset;
        n = now & 077777;
        srand((unsigned)n);
        timu = init_na();
        port = ttyn();
        ntused = 0;
        dolcost = 0.;
        proto = 0;
X270:   
        signal(1, bye);
        signal(3, bye);
/* The command just completed; switch stdout back to its origin if necessary */
        if( proto == 0 ) goto X366;
        fflush(stdout); /* because we're using printf */
        close(1);
        dup(savfd1);
        close(savfd1);
        proto = 0;
X366:   
        if( getnat(cnum) != -1 ) goto X414;
        exit(-1);
X414:   
        if( dolcost == 0. ) goto X606;
        if( dolcost <= 100. ) goto X472;
        printf("That just cost you $%.2f\n", dolcost);
X472:   
        if( dolcost >= -100. ) goto X540;
        printf("You just made $%.2f\n", -dolcost);
X540:   
        nat.nat_money -= dolcost;
        putnat(cnum);
        dolcost = 0.;
X606:   
        time(&now);
        nowtime = (struct tm *)localtime(&now);
        ncomstat = nstat;
        if( (nowtime->tm_yday & 0177) == nat.nat_dayno ) goto X742;
        nat.nat_dayno = nowtime->tm_yday & 0177;
        nminused = nat.nat_minused = 0;
        putnat(cnum);
        lasttime = now;
X742:   
        n = (now - lasttime)/60.;
        lasttime += n * 60.;
        nminused += n;
        if( nminused < m_m_p_d ) goto X1030;
        if( nstat == STAT_NORMAL ) goto X1040;
X1030:  
        ncomstat = nstat;
        goto X1052;
X1040:  
        ncomstat = nstat - 1;
X1052:  
        wait((int *) 0);
        if( argc <= 0 ) goto X1130;
        if( argv[2][0] == '\0' ) goto X1130;
        argc = 0;
        copy(argv[2], combuf);
        goto X1650;

X1130:  
        ntime -= ntused;
        ntused = 0;
        if( (n = open(downfil, O_RDONLY)) < 0 ) goto X1240;
        close(n);
        if( nstat == STAT_GOD ) goto X1230;
        execl(emprog[0], "\0177", "empire", 0);
        goto X1240;

X1230:  
        printf("The game is down\n");
X1240:  
        if( port == nat.nat_playing ) goto X1306;
        if( nat.nat_playing == 0 ) {
                printf("Welcome back to the shell (so many levels!)\n");
        } else {
                printf("Oooops! you're on the wrong port!\n");
        }
        exit(-1);
X1306:  
        if( nat.nat_tgms == 0 ) goto X1422;
        if( nat.nat_tgms != 1 ) goto X1332;
        printf("You have a new telegram waiting ...\n");
        goto X1406;

X1332:  
        if( nat.nat_tgms >= 21 || nat.nat_tgms < 0 ) goto X1376;
        printf("You have %s new telegrams waiting ...\n", numnames[nat.nat_tgms]);
        goto X1406;

X1376:  
        printf("You have several new telegrams waiting ...\n");
X1406:  
        nat.nat_tgms = 0;
        putnat(cnum);
X1422:  
        nat.nat_btu = ntime;
        nstat = nat.nat_stat;
        if( nstat != STAT_NOCAP ) goto X1456;
        printf("You lost your capital... better designate one\n");
X1456:  
        if( putnat(cnum) != -1 ) goto X1504;
        exit(-1);
X1504:  
        n = getcomm(combuf);
        if( n != -1 ) goto X1572;
        if( redirin != 0 ) goto X1540;
        bye();
        goto X1572;

X1540:  
        close(0);
        dup(redirin);
        close(redirin);
        redirin = 0;
X1572:  
        if( n >= 1 ) goto X1604;
        goto X270;

X1604:  
        if( n != -1 ) goto X1616;
        goto X270;

X1616:  
        if( redirin == 0 ) goto X1650;
        printf("%s\n", combuf);
X1650:  
        if( parse(combuf) == -1 ) goto X1706;
        if( dispatc() <  0 ) goto X1706;
        goto X270;
X1706:  
        printf("Try \"command list\" or \"info commands\"\n");
        goto X270;
}

getcomm(combuf)
char *combuf;
{
        register char *cp;
        register int i;
        char buf[128], prompt[64];

        if( redirin == 0 ) {
                cp = "Command";
        } else {
                cp = "Execute";
        }
        sprintf(fmtbuf,"\n[%d:%d] %s : ", nminused, ntime, cp);
        copy(fmtbuf, prompt);
        do {
                if ((i = prmptrd(prompt, buf, 80)) <= 0)
                        return (-1);
        } while (i < 2);
        cp = copy(buf, combuf);
        return (cp - combuf);
}

init_fi()
{

        sectf = open(sectfil, O_RDWR);
        natf = open(natfil, O_RDWR);
        newsf = open(newsfil, O_RDWR);
        shipf = open(shipfil, O_RDWR);
        trtf = open(treatfil, O_RDWR);
        loanf = open(loanfil, O_RDWR);
}

double
init_na()
{
        register int i;
        long now, previous;
        double timu, q;

        if (getnat(cnum) == -1)
                exit(-1);

        capx = nat.nat_xcap;
        capy = nat.nat_ycap;
        if (getsect(0, 0, UP_OWN) == -1)
                exit(-1);

/*
        Update nation btus, tlevel, and rlevel only
        if 0,0 is owned and is a capital. 
        Have to do another getnat because getsect calls update which
        can change nat struct.
*/
        time(&now);
        getnat(cnum);
        if( owner == 0 ||
          ( sect.sct_desig != S_CAPIT &&
            sect.sct_desig != S_SANCT )) {
                if( nat.nat_stat == STAT_NORMAL ) {
                        printf("Your capital is missing!\n");
                        nat.nat_stat = STAT_NOCAP;
                }
                timu = 0.;
                nat.nat_date = now;
        } else if( sect.sct_desig == S_CAPIT || cnum == 0 ) {
                if( sect.sct_lstup == 0 ) {
                        sect.sct_lstup = curup;
                }
                putsect(0, 0);
                q = ((sect.sct_civil * sect.sct_effic) / 4.5e6) + 1.e-7;
                previous = nat.nat_date;
                i = (now - previous) * q;
                nat.nat_date = (i / q) + previous + .99;
                timu = i;
                q = 1. - ((nat.nat_date - previous) / 8.64e6);
                if( q < 0 ) q = 0;
                nat.nat_t_level = q * nat.nat_t_level;
                nat.nat_r_level = q * nat.nat_r_level;
                nat.nat_btu = (i + nat.nat_btu > 256.) ? 256 : i + nat.nat_btu;
        } else if( sect.sct_desig == S_SANCT ) {
                nat.nat_date = now;
        }
        putnat(cnum);
        ntime = nat.nat_btu;
        nstat = nat.nat_stat;
        i = 0;
        do {
                nrealm[i].b_xl = nat.nat_b[i].b_xl;
                nrealm[i].b_xh = nat.nat_b[i].b_xh;
                nrealm[i].b_yl = nat.nat_b[i].b_yl;
                nrealm[i].b_yh = nat.nat_b[i].b_yh;
        } while( ++i < 4 );
        nminused = nat.nat_minused & 0377;
        lasttime = now;
        if( nat.nat_money < 0 ) broke = 1;
        for( i = 0; i < maxnoc; i++ ) {
                if( i == cnum ) continue;
                if( getnat(i) == -1 ) continue;
                capxof[i] = nat.nat_xcap - capx;
                capyof[i] = nat.nat_ycap - capy;
        }
        return(timu);
}

dispatc()
{
        register int    n, comprog, (*comaddr)();
        char    *cp;
        int     retcode, cost, fmtlen;

        if( (n = comtch(argp[0])) < 0 ) {
                if( n == -2 ) {
                        printf("\"%s\" is ambiguous -- ", combuf);
                } else {
                        printf("\"%s\" is not a legal command ", combuf);
                        if( nstat != ncomstat ) printf("now ");
                        printf("\n\t");
                }
                return(-1);
        }
        comprog = coms[n].c_prog;
        comaddr = coms[n].c_addr;
        cost = coms[n].c_cost;
        if( ntime < cost && cost > 0 ) {
                printf("You don't have the BTU's, bozo\n");
                return(0);
        }
        if( comprog == thisprog  ) {
                ntused += cost;
/* If stdout has been redirected, output command  */
                if( proto != 0 ) {
                        printf("\n%s\n", combuf);
                }
                if( (retcode = (*comaddr)()) == 2 ) {
                        ntused -= cost;
                }
                return(0);
        }
        switch( comaddr ) {
        case 2:
        case 4:
        default:
                call(comprog);
                break;
        case 1:
                printf("Unimplemented command\n");
                break;
        case 3:
                explain();
                break;
        case 5:
                redirin = dup(0);
                close(0);
                if( (n = open(argp[1], O_RDONLY)) == 0 ) break;
                perror(argp[1]);
                dup(redirin);
                close(redirin);
                redirin = 0;
                break;
        }
        return(0);
}

parse(cmndp)
char    *cmndp;
{
        register char   *cp, *bp, *ap;
        int     i, nargs;
        static char     argbuf[128];

        cp = cmndp;
        ap = argbuf;
        condarg = "";
        nargs = 0;
        goto X222;
X36:    
        cp++;
        goto X222;
X42:    
        argp[i++] = 0;
        goto X260;
X62:    
        if( 16 <= nargs ) goto X252;
        argp[nargs++] = ap;
        if( *cp != '"' ) goto X126;
        i = *cp++;
        goto X134;
X126:   
        i = ' ';
X134:   
        bp = ap;
        goto X152;
X140:   
        if( i == *cp ) goto X156;
        *ap++ = *cp++;
X152:   
        if( *cp != '\0' ) goto X140;
X156:   
        *ap++ = 0;
        if( *bp != '>' ) goto X200;
        redirec(bp + 1);
        goto X216;
X200:   
        if( *bp != '?' ) goto X222;
        condarg = bp + 1;
X216:   
        nargs--;
X222:   
        if( *cp == ' ' ) goto X36;
        if( *cp == '\0' ) goto X252;
        if( *cp != '|' ) goto X62;
        pipe_to(cp + 1);
X252:   
        i = nargs;
X260:   
        if( 16 >  i ) goto X42;
        return(nargs - 1);
}

pipe_to(string)
char    *string;
{
        register char   *cp;
        int     pfh[2];

        cp = string;
        goto X20;
X16:    
        cp++;
X20:    
        if( *cp == ' ' ) goto X16;
        if( *cp == '\0' ) {
                printf("Incorrect pipe syntax, see `info syntax'\n");
                return;
        }
        if( pipe(pfh) <  0 ) {
                printf("pipe failed...\n");
                return;
        }
        switch( fork() ) {
        case 0:
                close(0);
                dup(pfh[0]);
                close(pfh[1]);
                execl("/bin/sh", "sh", "-c", cp, 0);
                printf("Oops! pipe execl failed\n");
                exit(3);
        case -1:
                printf("pipe fork() failed...\n");
        default:
/*
        Close the reader, then attach the output pipe to stdout.
        Save the current stdout for when the command terminates.
*/
                close(pfh[0]);
                proto = pfh[1];
                savfd1 = dup(1);
                close(1);
                dup(proto);
                close(proto);
        }
}

redirec(file)
char    *file;
{
        register        char    *cp;

/* There should be more complete analysis here of various error conditions */
        cp = file;
        if( *cp != '>' ) goto X146;
        if( (proto = open(++cp, O_WRONLY)) >= 0 ) goto X124;
        if( fork() != 0 ) goto X100;
        resetui();
        if( access(cp, 0) != 0 ) {
                umask(0);
                close(creat(cp, 0622)); /* create it if it didn't exist */
        } else {
                chmod(cp, 0622); /* allow writing if disallowed before */
        }
        exit(0);
X100:   
        wait((int *) 0);
        proto = open(cp, O_WRONLY);
X124:   
        lseek(proto, 0L, 2);
        goto X266;
X146:   
        if( fork() != 0 ) goto X242;
        resetui();
        unlink(cp);
        umask(0);
        close(creat(cp, 0622));
        exit(0);
X242:   
        wait((int *) 0);
        proto = open(cp, O_WRONLY);
X266:   
/*
        Save current stdout for when the command terminates.
        Attach current stdout to the newly opened file.
*/
        if( proto >= 0 ) {
                savfd1 = dup(1);
                close(1);
                dup(proto);
                close(proto);
                return;
        }
        sprintf(fmtbuf,"Can't open '%s'", cp);
        perror(fmtbuf);
        proto = 0;
        return(0);
}

call(prog)
int     prog;
{
        register        i;
        char    *argv[4], cnumbuf[2], redirbuf[2];
        int     cp;
        long    now;
        static int      cnum1, redirin1;
        double  timu;

        if( getnat(cnum) == -1 ) {
                printf("Nation file trouble...\n");
                exit(-1);
        }
        sigsave();
        if( prog == 9 ) {
                nat.nat_playing = 0;
        }
        time(&now);
        timu = ntime - ntused;
        if( timu >= -32767. ) goto X146;
        timu = -32767.;
X146:   
        if( timu <= 256. ) goto X166;
        timu = 256.;
X166:   
        if( timu >= 0 ) goto X212;
        nat.nat_btu = timu - .5;
        goto X216;
X212:   
        nat.nat_btu = timu;
X216:   
        i = ((now - lasttime + 30.) / 60.) + nminused;
        nat.nat_minused = (i < 256) ? i : 255;
        putnat(cnum);
/*
        We're going to switch modules, so switch stdout back to the
        original connection if it was redirected to a pipe or a file.
        The command will get re-parsed, and the redirection will happen
        again in the new module.
*/
        if( proto ) {
                close(1);
                dup(savfd1);
                close(savfd1);
                proto = 0;
        }
        i = 3;
        do {
                if( i == redirin ) continue;
                close(i);
        } while( ++i < 15 );
        cnum1 = cnum + 1;
        cnumbuf[0] = '0' + cnum1;
        cnumbuf[1] = '\0';
        redirin1 = redirin + 1;
        redirbuf[0] = '0' + redirin1;
        redirbuf[1] = '\0';
        if( prog <= 0 ) goto X532;
        if( 7 <  prog ) goto X532;
        execl(emprog[prog], "Empire", cnumbuf, combuf, redirbuf, "\0377", 0);
        printf("We got a prog missing\007! (#%d,%s)\n", prog, combuf);
        perror(emprog[prog]);
        call(9);
        return;
X532:   
        if( 9 != prog ) goto X556;
        printf("Bye-bye\n");
        exit(0);
X556:   
        if( 98 == prog ) goto X576;
        if( 99 != prog ) return;
X576:   
        if( fork( ) != 0 ) goto X740;
        if( 99 != prog ) goto X672;
        printf("Toodles...type '^D' to return to Empire\n");
        fflush(stdout);
        resetui();
        execl("/bin/sh", "sh", shllrg1, 0);
        goto X720;
X672:   
        execl(empfix, "empfix", "\0377", 0);
X720:   
        printf("Exec failed\n");
        exit(3);
X740:   
        if( wait((int *) 0) != -1 ) goto X740;
        printf("Welcome back to Empire.\n");
        cnumbuf[0] = '0' + cnum1;
        cnumbuf[1] = '\0';
        redirbuf[0] = '0' + redirin1;
        redirbuf[1] = '\0';
        argv[0] = emprog[thisprog];
        argv[1] = cnumbuf;
        argv[2] = "";
        argv[3] = redirbuf;
        main(4, argv);
        exit(3);
}

bye()
{
        return(call(9));
}

explain()
{
        register char   flipflop, *cform;
        register        i;

        printf("\t\tCurrent EMPIRE Command List\n");
        printf("\t\t------- ------ ------- ----\n");
        if( nstat > 0 ) {
                printf("Initial number is cost in B.T.U. units.\n");
                printf("Text enclosed in brackets is comment");
                printf(" rather than part of the command.\n");
                if( nstat > 1 ) {
                        printf("Items in parentheses have the following meanings:\n");
                        printf("  (cname) :: country name\n");
                        printf("  (cno) :: country number\n");
                        printf("  (fleet) :: fleet designation, or area\n");
                        printf("  (item) :: commodity such as \"ore\", \"guns\", etc\n");
                        printf("  (loan) :: loan number\n");
                        printf("  (sect) :: sector coordinates in the form:   x,y\n");
                        printf("  (sects) :: sector(s) in the form:");
                        printf("   lox:hix,loy:hiy/d ?cond&cond&...  \n");
                        printf("  (ship) :: one ship number\n");
                        printf("  (ships) :: ship number(s) separated with '/'\n");
                }
        }
X222:   
        flipflop = 0;
        for( i=0; (cform = coms[i].c_form) != 0; i++ ) {
                if( ncomstat <  coms[i].c_permit ) continue;
                flipflop ^= 1;
                if( flipflop != 0 ) {
                        printf("%d %-34.34s", coms[i].c_cost, cform);
                } else {
                        printf("%d %s\n", coms[i].c_cost, cform);
                }
        }
        if( flipflop != 0 ) {
                printf("\n");
        }
        printf("For further info on command syntax see \"info syntax\".\n");
        return;
}
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPIRE/empire.c'
then
	echo shar: will not over-write existing file "'EMPIRE/empire.c'"
else
cat << \SHAR_EOF > 'EMPIRE/empire.c'
#define D_FILES
#define D_TELSTR
#define D_NATSTR
#define D_NATSTAT
#define D_SCTSTR
#include        "empdef.h"
#include        <stdio.h>

char    cjunk[80], pjunk[80];
int     uid, port;

main(argc, argv)
int     argc;
char    **argv;
{
        register        i;
        int     legit, notgod, logport;
	char	buf[514];
        char    *copy(), *cname();

        if( argc > 1 ) copy(argv[1], cjunk);
        if( argc > 2 ) copy(argv[2], pjunk);
        argv[argc-1][0] = (char)-1;
        argv[argc-1][1] = '\0';
        i = 15;
        while( --i > 2 ) close(i);
        notgod = (uid = myruid()) == privuid ? 0 : 1;
        port = ttyn(2);
        telf = open(downfil, O_RDONLY);
        if( telf >= 0 ) {
                read(telf, &tgm, (sizeof tgm));
                printf("Empire down for repairs as of %s", ctime(&tgm.tel_date));
		read(telf, buf, tgm.tel_length);
		printf("%s\n", buf);
                if( notgod != 0 ) exit(1);
                close(telf);
        }
        telf = open(upfil, O_RDONLY);
        if( telf >= 0 ) {
                read(telf, &tgm, (sizeof tgm));
		read(telf, buf, tgm.tel_length);
		printf("%s\n", buf);
                close(telf);
        }
        if( argc < 2 ) {
                prmptrd("What nation do you represent? ", cjunk, 25);
        }
        if( cjunk[0] == '\0' ) exit(1);
        if( argc < 3 ) {
                printf("Your representative's name? ");
                fflush(stdout);
                pjunk[sread(pjunk, 24)-1] = '\0';
                printf("\n");
        }
        if( (natf = open(natfil, O_RDWR)) <= 0 ) {
                printf("Can't open nation file.\n");
                exit(3);
        }
        legit = 0;
        for( cnum=0; cnum < maxnoc; cnum++ ) {
                if( read(natf, &nat, (sizeof nat)) != (sizeof nat) ) break;
                if( cnum == 0 ) {
                        up_offset = nat.nat_up_off;
                }
                if( same(cjunk, nat.nat_cnam) == 0 ) continue;
                legit = 1;
                if( notgod != 0 &&
                    nat.nat_playing != 0 &&
                    port != nat.nat_playing ) {
                        logport = nat.nat_playing;
                        legit = 2;
                }
                if( nat.nat_stat == STAT_DEAD ) legit = 5;
                if( notgod != 0 &&
                    nat.nat_nuid != uid &&
                    nat.nat_stat != STAT_NEW &&
                    nat.nat_stat != STAT_VISITOR &&
                    nat.nat_nuid != 0 ) legit = 3;
                if( same(pjunk, nat.nat_pnam ) == 0 &&
                    nat.nat_stat != STAT_VISITOR ) legit = 4;
                if( legit == 1 ) ok();
        }
        switch( legit ) {
        case 0:
                printf("We have no '%s' in our records ...\n", cjunk);
                printf("If you wish to observe or apply see %s.\n", privname);
                exit(1);
        case 2:
                printf("You are already logged in on tty%c.\n", logport);
                exit(1);
        case 3:
                printf("Sorry, I don't recognize you, #%d\n", uid);
                exit(1);
        case 4:
                printf("You are not empowered to represent %s\n", cjunk);
                exit(1);
        case 5:
                printf("%s is a dead country.\n", cjunk);
                exit(1);
        }
}

ok()
{
        char    cnumbuf[2];

        if( nat.nat_stat == STAT_NEW ) new();
        nat.nat_playing = port;
        if( nat.nat_stat == STAT_VISITOR ) {
                printf("Type \"info\" or \"list\" for help.");
                printf("  Enjoy your visit.\n");
        } else {
                printf("\t-=O=-\n");
        }
        lseek(natf, (long)cnum * (sizeof nat), 0);
        write(natf, &nat, (sizeof nat));
        if( nat.nat_money <= 1000 ) {
                if( nat.nat_stat != STAT_VISITOR ) {
                        if( nat.nat_money > 0 ) {
                                printf("Your cash reserves stand at $%ld\n", nat.nat_money );
                        } else {
                                printf("You are broke!\n");
                                printf("  Mines & industries are on strike.\n");
                        }
                }
        }
        close(natf);
        cnum = cnum + 1;
        cnumbuf[0] = (char)cnum + '0';
        cnumbuf[1] = '\0';
        execl(emprog[1], "Empire", cnumbuf, "", "1", "\0377", 0);
        printf("Sorry, but the game is hiding... (%s missing)\n", emprog[1]);
        exit();
}

new()
{
        register        i, s;
        long    addr;
        struct  sctstr  s1, s2;

        if( (sectf = open(sectfil, O_RDWR)) < 0 ) {
                printf("Can't open sector file");
                exit(3);
        }
        time(&nat.nat_date);
        srand((unsigned)nat.nat_date);
        i = 0;
        do {
                s = rand();
                s %=((long)w_xsize*((long)w_ysize) - 1);
                addr = (long)s * (sizeof sect);
                lseek(sectf, addr, 0);
                read(sectf, &s1, (sizeof sect));
                read(sectf, &s2, (sizeof sect));
                if( s1.sct_owned != 0 ||
                    s1.sct_desig < 3  ||
                    s2.sct_owned != 0 ||
                    s2.sct_desig < 3 ) continue;
                s1.sct_owned = s2.sct_owned = cnum;
                s1.sct_desig = s2.sct_desig = 2;
                s1.sct_effic = s2.sct_effic = 20;
                s1.sct_ore = s2.sct_ore = s1.sct_milit = s2.sct_milit = s1.sct_civil = s2.sct_civil = 127;
                s1.sct_mobil = s2.sct_mobil = 100;
                s1.sct_lstup = s2.sct_lstup = nat.nat_date/1800. - up_offset;
                lseek(sectf, addr, 0);
                write(sectf, &s1, (sizeof sect));
                write(sectf, &s2, (sizeof sect));
                close(sectf);
                printf("You have been accepted as nation #%d!\n", cnum);
                nat.nat_stat = STAT_NORMAL;
                nat.nat_btu = 75 ;
                nat.nat_nuid = uid;
                nat.nat_tgms = 0;
                nat.nat_xcap = s % ((long)w_xsize);
                nat.nat_ycap = s / ((long)w_xsize);
                i = 0;
                do {
                        nat.nat_b[i].b_xl = 0;
                        nat.nat_b[i].b_xh = 1;
                        nat.nat_b[i].b_yh = 0;
                        nat.nat_b[i].b_yl = 0;
                } while( ++i < 4 );
                nat.nat_money = 5000;
                printf("Your country consists of 2 sectors");
                printf(" (sanctuaries at 0,0 & 1,0),\n");
                printf("containing 254 civilians, 254 military troops");
                printf(" and 254 tons of ore.\n");
                printf("Your country also has $%ld in \"cash\".\n", nat.nat_money);
                printf("For playing information type:\n");
                printf("\"command list\" and/or \"info\"");
                printf(" and/or \"info overview\"\n");
                printf("in response to the \"[75] Command : \" prompt\n");
                printf("\n\t\tGood Luck!\n");
                return;
        } while( ++i < 1000 );
        printf("The world is already too full...  sorry\n");
        exit(1);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPSUBS/getrel.c'
then
	echo shar: will not over-write existing file "'EMPSUBS/getrel.c'"
else
cat << \SHAR_EOF > 'EMPSUBS/getrel.c'
#define D_NATSTR
#include        "empdef.h"

getrel(c1, c2)
int     c1, c2;
{
        register        word, shift;

        if( getnat(c1) == -1 ) return(-1);
        word = c2;
        word >>= 3;
        shift = 14 - ((c2 % 8) << 1);
        return((nat.nat_relate[word]>>shift) & 03);
}

putrel(c1, c2, rel)
int     c1, c2, rel;
{
        register        word, shift;

        if( getnat(c1) == -1 ) return(-1);
        word = c2;
        word >>= 3;
        shift = 14 - ((c2 % 8) << 1);
        nat.nat_relate[word] &= ~(3<<shift);
        nat.nat_relate[word] |= rel<<shift;
        putnat(c1);
        return(0);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'EMPSUBS/sread.c'
then
	echo shar: will not over-write existing file "'EMPSUBS/sread.c'"
else
cat << \SHAR_EOF > 'EMPSUBS/sread.c'
/*
        There are two versions of sread.c in here.  One for 4.2 BSD, and
        one for other (SysV) systems.
*/
#include        "empdef.h"

#define BSD /* Jon */	/* HACKed to get the right version for Xenix 1.3.5 */

#ifdef BSD
#include        <sgtty.h>

sread(buf, maxl)
char    *buf;
int     maxl;
{
        register        int     i;
        struct  sgttyb  ttyb;
        unsigned short  flags;

        ioctl(0, TIOCGETP, &ttyb);
        flags = ttyb.sg_flags;
        ttyb.sg_flags &= ~ECHO;
        ioctl(0, TIOCSETN, &ttyb);
        i = read(0, buf, maxl);
        ttyb.sg_flags = flags;
        ioctl(0, TIOCSETN, &ttyb);
        return(i);
}
#else
#include        <termio.h>

sread(buf, maxl)
char    *buf;
int     maxl;
{
        register        int     i;
        struct  termio  ttyb;
        unsigned short  flags;

        ioctl(0, TCGETA, &ttyb);
        flags = ttyb.c_lflag;
        ttyb.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);
        ioctl(0, TCSETAF, &ttyb);
        i = read(0, buf, maxl);
        ttyb.c_lflag = flags;
        ioctl(0, TCSETAF, &ttyb);
        return(i);
}
#endif  		/* BSD */
#undef BSD

SHAR_EOF
fi # end of overwriting check
if test -f 'EMPSUBS/xwrap.c'
then
	echo shar: will not over-write existing file "'EMPSUBS/xwrap.c'"
else
cat << \SHAR_EOF > 'EMPSUBS/xwrap.c'
extern  int     w_xsize, w_ysize;

xwrap(x)
int     x;
{
        register int    q, wxh;

        wxh = w_xsize;
        wxh >>= 1;
        q = x;
        q += wxh;
        while( q <= 0 ) q += w_xsize;
        return(((q-1)%((long)w_xsize)) + 1 - wxh );
}

ywrap(y)
int     y;
{
        register int    q, wyh;

        wyh = w_ysize;
        wyh >>= 1;
        q = y;
        q += wyh;
        while( q <= 0 ) q += w_ysize;
        return(((q-1)%((long)w_ysize)) + 1 - wyh);
}
SHAR_EOF
fi # end of overwriting check
# end of shell archive
exit 0
