..  Run this file through nroff (no macro packages needed)
..  To get page boundaries, pipe the output of nroff though pr.
.hy
.na
.ll 72
.de p
.sp
..
.de h
.in 0
.sp 2
.ne 4
.nr h +1
\\nh)\ \ \\$1
.p
..
.de i
.in +4
.fi
..
.de o
.sp
.in -4
.nf
..
.h "INTRODUCTION"
This file describes the contents of the lib directory.
.p
The rlib library is intended to simplify the task of writing
news reading programs.  Previously, there was no specific support
for writing news reading programs, and in order to take advantage
of existing software, programmers had to dig the routines out of the
netnews software themselves.  This library attempt collects a
number of routines, in some cases modified to make them more general
or to simplify the caller interface, into a central location where
all users can share them.  It is hoped that this library will unlimately
evolve into a collection of routines used not just by the news
reading software but by all the netnews software.
.p
There are certain limitations to this library.  Because this code
was designed and selected for its usefulness for use with vnews,
it may not always do things in ways appropriate for other programs.
On the other hand, certain functions that might be useful were
not included because they had too much vnews specific code in them.
In particular, writers of news reading programs will probably want
to copy the article selection routines out of vnews/artseq.c and
modify them to work for their particular application.  This does
not attempt to provide complete documentation on all the routines;
so you may have to consult the code for details.
.p
.h "BASIC INFORMATION"
The library source resides in a directory called
"lib".  In general, you should set
.br
	LIB = ../lib
.br
in your makefiles.  That way, your makefiles will run unchanged if
they are placed in a directory parallel to the lib directory.
You should compile your programs with -I$(LIB) so that they can
access header files in lib, and link with $(LIB)/rpathinit.o and
$(LIB)/rlib.a.  The file rpathinit.o contains the pathinit routine;
and rlib.a is an archive containing all the rest of the routines.
.p
To use many of these routines you must provide an error exit routine
called xerror; a typical version is:
.nf
	xerror(msg, a1, a2, a3, a4)  char *msg; {
		printf(msg, a1, a2, a3, a4);
		putchar('\\n');
		exit(2);
	}

.fi
There is a global variable called bfr which is a character array
of LBUFLEN (currently 1024) bytes.  Various routines in the library
use this for scratch space; you can use it as well.  Be careful not to
rely on the value of bfr if you call another routine that might modify
it.
The following library routines are guarenteed not to use bfr:  afree,
ainit, bcopy, bzero, ckmalloc, clrunread, findgroup, getaddr, getopt,
g_num, hfgets, hfree, hinit, inunread, launder, lcase, makehimask,
nextgrp, ngmatch, nstrip, prefix, prevgrp, rename, replyname, rmnf,
savestr, scopyn, setunread, and titmat.
For convenience, a declaration of bfr appears in libextern.h.
.h "HEADER FILES"
This section lists the various header files.  In some cases, you
will have to see the descriptions of the routines that use the
files for more details.
.i
.o
artfile.h
.i
This include defines for accessing the artfile.
.o
arthead.h
.i
This header file defines the arthead structure used to hold
and in-core copy of an article header.
.o
config.h
.i
This file specifies the version of UNIX you are running under.
(UNIX is a trademark of AT&T Bell Laboratories.)  It defines
index and rindex to be strchr and strrchr, if necessary.
It also defines BSDREL and USGREL.  The values of these for various
versions of UNIX are:
.nf
	VERSION		USGREL	BSDREL
	Version 6	6	6
	System III	30	6
	System V	50	6
	System V rel 2	52	6
	Version 7	6	7
	4.1 BSD		6	41
	4.2 BSD		6	42
.fi
.o
defs.h
.i
This file includes lots of news related defines.  It includes the file
newsdefs.h, which is generated by the setup program, and also has a
few defines of it's own.
Some of the useful defines are:
.nf
    Name	Default	  Description
    MAXGROUPS	300	  The maximum number of newsgroups
    BUFLEN	128/256	  The size of a general purpose char array
    LBUFLEN	1024	  The size of a big buffer
    DATELEN	48	  The maximum size of a date
    FPATHLEN	64	  The maximum length of a file name
    NAMELEN	64	  The maximum size of a message ID or address
    PATHLEN	512	  The maximum size of a Path: entry
.fi
.o
libextern.h
.i
Declares various global variables defined in the library.  Bfr is
declared here, as are the various variables set up by pathinit and
getuser.
.o
newsrc.h
.i
Defines for the .newsrc accessing routines.
.o
ng.h
.i
Defines for accessing the newgroups file.
.o
roptions.h
.i
Defines for the roptions routine.
.o
stroff.h
.i
This defines one macro called stroff(element, structure).  It returns
the offset of the specified element into the given structure.
.in -4
.p
The rest of this file details the various routines available.
.h PATHS
To avoid the necessity of hard coding paths, machine names, and so forth
in your program, these routines are provided.  Declarations for all the
variables set by these routines appear in libextern.h.
.i
.o
pathinit()
.i
This routine fills in the following character arrays:
.nf
.in +4
SPOOL:  The netnews spool directory.
LIB:  /usr/lib/news or equivelant.
FULLSYSNAME:  System name as known by neighbors.
DOMAIN:  Concatenated to FULLSYSNAME to form domain name.
XINEWS:  Path of inews program.
MAILPARSER:  Path of sendmail or recmail program.
.in -4
.fi
A number of other library routines assume that pathinit has been
called.
.o
isadmin()
.i
Returns nonzero if user is the netnews administrator or the
superuser.
.o
getpaths()
pgetpaths()
.i
Sets username to the user's login name and userhome to the user's
home directory.  The latter version always goes to the /etc/passwd
file and thus cannot be subverted by modifying the environment.
.h "NEWSGROUPS"
For convenience, each newsgroups is assigned a small integer which
uniquely identifies it.  These numbers will vary from machine to
machine and therefore can only be used locally.  The file
/usr/lib/news/groupfile maintains this mapping.  For reliability, a
backup copy is kept in /usr/lib/news/groupfile.bak.
.p
To access this file, #include\ "ng.h" and use the following routines.
.i
.o
gfopen()
gfclose()
.i
These routines open and close the newsgroup file.  The routine gfopen
also sets the global variable maxng to the largest newsgroup number
in use.
.o
ALL_GROUPS(g) { statement... }    (struct ngrec g)
.i
This macro sets up a loop through all the newsgroups.  The entries
in the ngrec structure are
.nf
      char  g_name[MAXNGNAME];	/* newsgroup name */
      short g_num;		/* newsgroup number */
      short g_flags;		/* various flags */
.fi
The only flag currently in use is G_MOD, which indicates a
moderated or fa.all group.
.h "ARTFILE"
Artfile keeps track of all the
articles in the system.
To use these routines, #include "artfile.h".
Artfile.h contains two typedefs.  An ARTNO is the number of an article
within a newsgroup.  This is currently defined to be int, but will be
changed to "long" when article numbers reach 32000.
A DPTR is the address of an article record in artfile.  The value
of a DPTR is only valid within a given program; therefore if you
want to pass the identity of an article to another program, you
should pass the message-ID of the article.  There is a special
value DNULL used to indicate a null DPTR.

There is one artrec structure for each article on the system.
The artrec structure contains the following entries of interest:
      long  a_subtime;		/* when article was posted */
      long  a_rectime;		/* when article was received */
      long  a_exptime;		/* when article expires (0 if not specified) */
      DPTR  a_parent;		/* article this is a followup to */
      DPTR  a_children;		/* linked list of followups */
      DPTR  a_childchain;	/* link for followup chain */
      short a_flags;		/* various flags */
      char  a_ngroups;		/* number of newsgroups article posted to */
      struct artgroup {
            short a_ngnum;	/* newsgroup number */
            short a_artno;	/* article number */
            DPTR  a_ngchain;	/* next article in this newsgroup */
      } a_group[MAXNG];		/* list of groups article posted to */
      char *a_ident;		/* message id */
      char *a_title;		/* article subject line */
      char *a_from;		/* author of article (real name omitted) */
      char *a_file;		/* file containing article */
      char  a_nkwords;		/* number of keywords on article */
      char *a_kword[A_MAXKW];	/* keywords */

.fi
A_flags&A_NOFILE will be true if this article does not appear in the
spool directory.  Currently, this can occur if a followup is received
before the original article.  In that case, a dummy entry will be made
for the original article until it arrives.  Later, this may also
indicate that the article has been cancelled or expired.
.p
Currently, keywords are not stored in artfile.  However, most of the
code is in place so that this can be changed if keywords are needed.
.i
.o
afopen()
.i
Open artfile.  A corresponding close routine could be written if there
is a need.
.o
ainit(a)  struct artrec *a;
afree(a)  struct artrec *a;
.i
Ainit initializes and artrec structure and afree frees up the storage
associated with it.  Both of these routines are currently no-ops
but that may change in the future.
.o
lookart(msgid, a)  char *msgid; struct artrec *a;
.i
Get the record for the article.  Returns the address of the record,
or DNULL on failure.
.o
readrec(dp, a)  DPTR dp; struct artrec *a;
.i
Read an article record given its address.
.o
BKWD_GROUP(ngnum, artno, dp, a) { statements... }
.i
This macro sets up a "for" loop to fetch all the articles in the
newsgroup numbered ngnum.  For each article, artno is set to the
article number within the group, a is set to the article record, and
dp is set to the address of the article record.  The highest
numbered records are produced first.
This means you will normally have to sort the articles before you
display them.
On the other hand, this order has the advantage that you can stop
scanning the newsgroup when you reach
the lowest numbered article marked unread in the .newsrc file.
.h ".NEWSRC PROCESSING ROUTINES"
These routines maintain an in-core copy of the .newsrc file and the
the groupfile.  You should #include "newsrc.h" which defines the
ngentry structure.  (There is one such structure for each group.)
.i
.o
openrc()
.i
Open the .newsrc file, creating it if necessary.  A file pointer is
returned.  Getuser must be called before this routine is used.
.o
readinrc(fp)  FILE *fp;
.i
Read in the .newsrc and groupfile files.  fp is the file pointer
returned by openrc, or NULL in which case only the groupfile
is read.  This routine should be called before any of the following
routines are used.
To use this routine, you must provide a routine called "wewant",
which takes the name of a newsgroup, and returns true if the
newsgroup should be appended to the .newsrc file.  Wewant generally
tests whether the user asked for the group in the -n option.
.o
writeoutrc()
.i
Write out an updated version of the .newsrc file.  This routine
is a no-op if readinrc was not called, or was called with a NULL
argument
.o
nextgrp(ngp)  struct ngentry *ngp;
.i
Returns the next group in the .newsrc file, or the first group if
ngp is NULL.
.o
prevgrp(ngp)
.i
Returns the previous group in the .newsrc file.
.o
setupgrp(ngp, max)  struct ngentry *ngp; ARTNO max;
.i
Make the specified group the current group.  Max is the maximum article
number apprearing in the group, which will be the first article number
generated by the BKWD_GROUP macro.  The global variable minartno is set
to the smallest unread article and maxartno is set to max.
.o
isunread(artno)
setunread(artno)
clrunread(artno)
.i
These routines test, set, or clear the "unread article" indication for
a given article.  The group of the article is the group specified in the
last call to setupgrp.
.o
findgroup(name)
.i
Return the address of the ngentry strucure for the group.
.o
numtong(num)
.i
Takes a newsgroup number and returns the address of the ngentry
for the newsgroup.  Currently this routine does not check its argument
for validity.
.o
g_num(ngp)
.i
Return the number of the group.
.h "ARTICLE HEADERS"
The netnews code includes some routines for dealing with article
headers, but they currently require about 5K to store a headers
and still don't allocate enough space to store the "References:"
line.  These routines use dynamicly allocated memory.
To use them, #include "arthead.h".
.i
.o
hinit(hp)  struct arthead *hp;
hfree(hp)  struct arthead *hp;
.i
These routines initialize and free the storage associated with an
arthead structure.  Hinit does not have to be called for static
or global variables since they are initialize to zero automaticly.
.o
gethead(hp, fp)
.i
This routine reads in a news header.  It returns fp on success and
NULL on failure.
.o
hxchg(hp1, hp2)
.i
This routine exchanges the value of two arthead structures.  There is
no way to copy an arthead structure, but an exchange operation will
serve for most purposes.
.o
hfgets(buf, buflen, fp)
.i
Reads a USENET header line.  This routine is like fgets except that
1) it handles continuation lines, and 2) it always reads in the
entire line, even if it doesn't fit.  The part that doesn't fit is
discarded.
.h "DATE CONVERSION"
.i
.o
cgtdate(datestr)
.i
This routine converts a date string to UNIX internal format.
Because this routine is so big (a little over 10K), there
is also a program called /usr/lib/news/cgtdate which invokes
this routine on its argument and writes the converted value
(in decimal) to the standard output.
.o
getadate(datestr)
.i
This routine converts a date in RFC 822 format to UNIX internal
format.
.h "MISCELLANEOUS NETNEWS ORIENTED ROUTINES"
.i
.o
cancel(ofp, hp, notauthor)
.i
The article whose header has been read into hp is cancelled.  If
the notauthor flag is set, the article will be cancelled locally
only rather than net-wide.  Ofp is a file pointer that is used
to write an error message on if the attempt to fork fails.
.o
dirname(group, buf)
.i
Generates the name of the directory containing the newsgroup
in buf and returns buf.
.o
getaddr(name, result)  char *name;  char result[NAMELEN];
.i
Given the contents of a "From:" line to the right of the colon,
place the machine address in "result".  (E. g.  generate "user@x"
from "user@x (Real Name)".
.o
launder(newsgroups)
.i
This routine should be called when generating followups.  It does
the net.general to net.followup conversion.
.o
makehimask(sublist, newsgroup)
.i
Unless the newsgroup is specificly asked for in the subscription list,
append !newsgroup to the subscription list.  Used to keep people from
seeing groups like control unless they really want to.
.o
ngmatch(nglist, sublist)  char *nglist, *sublist;
.i
Returns nonzero if one of the newsgroups in nglist is matched by
an entry in the subscription list.  Unlike the 2.10 netnews routine
or the same name, neither argument needs a trailing comma.
.o
replyname(hp, buf)
.i
Generates the name of the person to send replies to this article to.
.o
roptions(argv, rcfp)
.i
This routines does the readnews option processing.  Argv is the
arguments to the program.  Rcfp is refers to the .newsrc file; it
is used to read the "options " line at the top of the .newsrc file.
To access the options set by roptions, #include "roptions.h".
.o
rmnf(s)
.i
Remove any trailing " - (nf)" from the string.  Returns nonzero if
removed.
.o
titmat(titles, curtitle)
.i
See if curtitle contains one of the strings listed in titles.
The global variable "titles" is set by the roptions routine.
.o
tomsgid(id)
.i
The argument should be a message ID or an article ID.  If it
appears to be the latter, it is converted to a message ID.
.h "STRING AND MEMORY UTILITY ROUTINES"
The remaining routines are not very netnews specific.
.i
.o
bcopy(from, to, n)
.i
Copy n bytes.
.o
bzero(block, n)
.i
Clear n bytes of memory.
.o
ckmalloc(nbytes)
.i
Invokes malloc and calles xerror if the malloc fails.  All the
routines in rlib call ckmalloc instead of malloc.
.o
lcase(s)
.i
Convert the string to all lower case.
.o
nstrip(s)  char *s;
.i
Strip off trailing newlines, tabs, and spaces.  Returns nonzero if a
newline was present.
.o
prefix(s, pfx)
.i
Return nonzero if pfx is a prefix of s.
.o
savestr(s)  char *s;
.i
Return a copy of s in a block of memory obtained from ckmalloc.
.o
scopyn(from, to, n)
.i
Copy a character string, truncating the string if necessary for make
it fit.  "n" is the size of the destination.  Unlike strncpy, this
routine always terminates the result with a nul.
.o
sindex(s1, s2)
.i
Return a pointer to the first occurance of the string s2 within s1,
or NULL if not found.
.o
strpbrk(s1, s2)
.i
Return a pointer to the first character of s1 that also occurs in s2,
or NULL if no such character exists.
.o
strspn(s1, s2)
strcspn(s1, s2)
.i
Return the length of the longest prefix of s1 sonsisting of characters
in (for strspn), or not in (for strcspn), s2.
.o
strtok(s1, s2)
.i
The System III strtok routine.
.h "OTHER UTILITY ROUTINES"
.i
.o
ckfopen(file, mode)
.i
Calls fopen, and invokes xerror if the fopen fails.
.o
opendir(name)
closedir(dirp)
readdir(dirp)
rewinddir(dirp)
.i
The Berkeley directory access routines.
Opendir opens a directory and returns a (DIR *) pointer, or NULL on failure.
Readdir reads the next directory entry and returns a ponter to a struct direct,
or NULL on eof.
Closedir closes a directory.
Rewinddir goes back to the beginning of a directory and clears any buffered
information.
.o
getopt(argc, argv, optlist)
.i
The System III command argument parsing routine.
.o
rename(from, to)
.i
Rename a file, deleting any existing file named "to".
.h SYNOPSYS
This section gives an alphabetical listing of all the routines
in the library:
.sp
.nf
void addrc(ngp)  struct ngentry *ngp;
void afopen()
void afree(a)  struct artrec *a;
void ainit(a)  struct artrec *a;
void bcopy(from, to, n)  char *from, *to; int n;
char bfr[LBUFLEN];
void bzero(mem, n)  char *mem; int n;
int  cancel(ofp, hp, notauthor)  FILE *ofp; struct arthead *hp; int notauthor;
time_t cgtdate(datestr)  char *datestr;
FILE *ckfopen(filename, mode)  char *filename, *mode;
char *ckmalloc(nbytes)  int nbytes;
void closedir(dirp)  DIR *dirp;
void clrunread(artno)  ARTNO artno;
char *dirname(group, buf)  char *group, *buf;
struct ngentry *findgroup(name)  char *name;
long getadate(datestr)  char *datestr;
char *getaddr(full, mach)  char *full, mach[NAMELEN];
FILE *gethead(hp, fp)  struct arthead *hp; FILE *fp;
int getopt(argc, argv, optstr)  int argc; char **argv; char *optstr;
void getuser();
void gfclose();
void gfopen();
int g_num(ngp)  struct ngentry *ngp;
char *hfgets(buf, buflen, fp)  char *buf; int buflen; FILE *fp;
void hfree(hp)  struct arthead *hp;
void hinit(hp)  struct arthead *hp;
void hxchg(hp1, hp2)   struct arthead *hp1, *hp2;
char *index(str, c)  char *str; char c;
int isadmin();
int isre(title)  char *title;
int isunread(artno)  ARTNO artno;
void launder(newsgroups) char *newsgroups;
void lcase(str)  char *str;
DPTR lookart(msgid, a)  char *msgid; struct artrec *a;
void makehimask(sublist, group)  char *sublist, *group;
struct ngentry *nextgrp(curgrp)  struct ngentry *curgrp;
void pathinit();
int ngmatch(nglist, sublist)  char *nglist, *sublist;
int nstrip(str)  char *str;
DIR *opendir(name)  char *name;
FILE *openrc()
void pgetuser()
int prefix(str, pfx)  char *str, *pfx;
struct ngentry *prevgrp(curgrp)  struct ngentry *curgrp;
struct direct *readdir(dirp)  DIR *dirp;
void readrec(dp, a)  DPTR dp; struct artrec *a;
void readinrc(rcfp)  FILE *rcfp;
int rename(from, to)  char *from, *to;
char *replyname(hp, buf)  struct arthead *hp; char buf[PATHLEN];
void rewinddir(dirp)  DIR *dirp;
int rmnf(title)  char *title;
void roptions(argv, rcfp)  char **argv; FILE *rcfp;
char *savestr(str)  char *str;
void scopyn(from, to, tosize)  char *from, *to; int tosize;
void setunread(artno)  ARTNO artno;
void setupgrp(ngp, max)  struct ngentry *ngp; ARTNO max;
char *sindex(s1, s2)  char *s1, *s2;
char *strcspn(s1, s2)  char *s1, *s2;
char *strpbrk(s1, s2)  char *s1, *s2;
char *strspn(s1, s2)  char *s1, *s2;
char *strtok(s1, s2)  char *s1, *s2;
int titmat(titles, title)  char **titles, *title;
void tomsgid(id)  char *id;
void writeoutrc();
.fi
