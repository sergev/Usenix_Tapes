:::::::: :fix :::::::
No differences encountered
:::::::: Makefile :::::::
*** ../orig.u/Makefile	Wed May 15 17:11:54 1985
--- Makefile	Fri Jun  7 11:46:36 1985
***************
*** 3,9
  TESTDIR	= .
  INS	= cp
  INSDIR	= /usr/5bin
! DEFS	= -DNICE -DNICEVAL=4 -DBRL -DJOBS	# for BSD, add -DBSD	# -DACCT
  CFLAGS	= $(DEFS) -O
  ACCTINC	=					# -I/usr/src/cmd/acct
  LDFLAGS	= -s -n

--- 3,9 -----
  TESTDIR	= .
  INS	= cp
  INSDIR	= /usr/5bin
! DEFS	= -DNICE -DNICEVAL=4 -DBRL -DJOBS -DBSD # for BSD, add -DBSD	# -DACCT
  CFLAGS	= $(DEFS) -O
  ACCTINC	=					# -I/usr/src/cmd/acct
  LDFLAGS	= -s -n
***************
*** 12,18
  OFILES	= setbrk.o blok.o stak.o cmd.o fault.o main.o word.o string.o\
  	  name.o args.o xec.o service.o error.o io.o print.o macro.o expand.o\
  	  ctype.o msg.o test.o defs.o hash.o hashserv.o pwd.o func.o\
! 	  echo.o jobs.o	# for BSD, remove echo.o and add signal.o and ulimit.o
  
  CFILES	= setbrk.c blok.c stak.c cmd.c fault.c main.c word.c string.c\
  	  name.c args.c xec.c service.c error.c io.c print.c macro.c expand.c\

--- 12,19 -----
  OFILES	= setbrk.o blok.o stak.o cmd.o fault.o main.o word.o string.o\
  	  name.o args.o xec.o service.o error.o io.o print.o macro.o expand.o\
  	  ctype.o msg.o test.o defs.o hash.o hashserv.o pwd.o func.o\
! 	  history.o homedir.o \
! 	  echo.o jobs.o	signal.o ulimit.o # for BSD, add signal.o and ulimit.o
  
  CFILES	= setbrk.c blok.c stak.c cmd.c fault.c main.c word.c string.c\
  	  name.c args.c xec.c service.c error.c io.c print.c macro.c expand.c\
***************
*** 17,23
  CFILES	= setbrk.c blok.c stak.c cmd.c fault.c main.c word.c string.c\
  	  name.c args.c xec.c service.c error.c io.c print.c macro.c expand.c\
  	  ctype.c msg.c test.c defs.c hash.c hashserv.c pwd.c func.c\
! 	  echo.c jobs.c	# for BSD, remove echo.c and add signal.c and ulimit.c
  
  all:		sh
  

--- 18,25 -----
  CFILES	= setbrk.c blok.c stak.c cmd.c fault.c main.c word.c string.c\
  	  name.c args.c xec.c service.c error.c io.c print.c macro.c expand.c\
  	  ctype.c msg.c test.c defs.c hash.c hashserv.c pwd.c func.c\
! 	  history.c homedir.c \
! 	  echo.c jobs.c signal.c ulimit.c # for BSD, add signal.c and ulimit.c
  
  all:		sh
  
***************
*** 37,46
  main.o:		timeout.h
  
  ctype.o:
! 	if gould; \
! 	then	$(CC) $(CFLAGS) -R -c ctype.c; \
! 	else	sh ./:fix ctype; \
! 	fi
  
  msg.o:
  	if gould; \

--- 39,49 -----
  main.o:		timeout.h
  
  ctype.o:
! 	$(CC) $(CFLAGS) -S ctype.c
! 	sed '/^[ 	]*\.data/s/text/data/' < ctype.s > x.s
! 	$(CC) -c x.s
! 	mv x.o ctype.o
! 	rm x.s ctype.s
  
  msg.o:
  	$(CC) $(CFLAGS) -S msg.c
***************
*** 43,52
  	fi
  
  msg.o:
! 	if gould; \
! 	then	$(CC) $(CFLAGS) -R -c msg.c; \
! 	else	sh ./:fix msg; \
! 	fi
  
  service.o:
  	$(CC) $(CFLAGS) $(ACCTINC) -c service.c

--- 46,56 -----
  	rm x.s ctype.s
  
  msg.o:
! 	$(CC) $(CFLAGS) -S msg.c
! 	sed '/^[ 	]*\.data/s/text/data/' < msg.s > x.s
! 	$(CC) -c x.s
! 	mv x.o msg.o
! 	rm x.s msg.s
  
  service.o:
  	$(CC) $(CFLAGS) $(ACCTINC) -c service.c
:::::::: Makefile.gould :::::::
No differences encountered
:::::::: SH_NOTES :::::::
No differences encountered
:::::::: args.c :::::::
*** ../orig.u/args.c	Wed May 15 17:11:55 1985
--- args.c	Wed Jun  5 14:48:23 1985
***************
*** 15,21
  
  #if BRL
  #if JOBS
! char	flagadr[17];
  #else
  char	flagadr[16];
  #endif

--- 15,21 -----
  
  #if BRL
  #if JOBS
! char	flagadr[19];
  #else
  char	flagadr[18];
  #endif
***************
*** 17,23
  #if JOBS
  char	flagadr[17];
  #else
! char	flagadr[16];
  #endif
  #else	/* !BRL */
  #if JOBS

--- 17,23 -----
  #if JOBS
  char	flagadr[19];
  #else
! char	flagadr[18];
  #endif
  #else	/* !BRL */
  #if JOBS
***************
*** 21,27
  #endif
  #else	/* !BRL */
  #if JOBS
! char	flagadr[15];
  #else
  char	flagadr[14];
  #endif

--- 21,27 -----
  #endif
  #else	/* !BRL */
  #if JOBS
! char	flagadr[17];
  #else
  char	flagadr[16];
  #endif
***************
*** 23,29
  #if JOBS
  char	flagadr[15];
  #else
! char	flagadr[14];
  #endif
  #endif
  

--- 23,29 -----
  #if JOBS
  char	flagadr[17];
  #else
! char	flagadr[16];
  #endif
  #endif
  
***************
*** 49,54
  #if JOBS
  	'J',
  #endif
  	 0
  };
  

--- 49,56 -----
  #if JOBS
  	'J',
  #endif
+ 	'q',		/* ADR -- -q to not read ~/.shrc */
+ 	'H',		/* ADR -- -H turn off history mechanism */
  	 0
  };
  
***************
*** 74,79
  #if JOBS
  	jobflg,
  #endif
  	  0
  };
  

--- 76,83 -----
  #if JOBS
  	jobflg,
  #endif
+ 	quickflg,
+ 	nohistflg,
  	  0
  };
  
***************
*** 109,115
  
  		/*
  		 * Step along 'flagchar[]' looking for matches.
! 		 * 'sicr' are not legal with 'set' command.
  		 */
  
  		while (*++cp)

--- 113,119 -----
  
  		/*
  		 * Step along 'flagchar[]' looking for matches.
! 		 * 'sicrq' are not legal with 'set' command.
  		 */
  
  		while (*++cp)
***************
*** 119,125
  				flagc++;
  			if (*cp == *flagc)
  			{
! 				if (eq(argv[0], setstr) && any(*cp, sicrstr))	/* DAG -- made strings sharable */
  					failed(argv[1], badopt);
  				else
  				{

--- 123,129 -----
  				flagc++;
  			if (*cp == *flagc)
  			{
! 				if (eq(argv[0], setstr) && any(*cp, sicrqstr))	/* DAG -- made strings sharable */
  					failed(argv[1], badopt);
  				else
  				{
***************
*** 147,152
  	}
  	else if (argc > 1 && *argp[1] == '+')	/* unset flags x, k, t, n, v, e, u */
  						/* or any added BRL/JOBS flags */
  	{
  		cp = argp[1];
  		while (*++cp)

--- 151,157 -----
  	}
  	else if (argc > 1 && *argp[1] == '+')	/* unset flags x, k, t, n, v, e, u */
  						/* or any added BRL/JOBS flags */
+ 						/* or history flag */
  	{
  		cp = argp[1];
  		while (*++cp)
***************
*** 157,163
  			/*
  			 * step through flags
  			 */
! 			if (!any(*cp, sicrstr) && *cp == *flagc)	/* DAG -- made string sharable */
  			{
  				/*
  				 * only turn off if already on

--- 162,168 -----
  			/*
  			 * step through flags
  			 */
! 			if (!any(*cp, sicrqstr) && *cp == *flagc)	/* DAG -- made string sharable */
  			{
  				/*
  				 * only turn off if already on
:::::::: blok.c :::::::
No differences encountered
:::::::: brkincr.h :::::::
No differences encountered
:::::::: cmd.c :::::::
No differences encountered
:::::::: ctype.c :::::::
No differences encountered
:::::::: ctype.h :::::::
*** ../orig.u/ctype.h	Wed May 15 17:11:55 1985
--- ctype.h	Thu Apr 25 11:44:38 1985
***************
*** 80,86
  extern char	_ctype2[];
  
  #define	digit(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_DIG))
! #define dolchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_AST|T_BRC|T_DIG|T_IDC|T_SHN))
  #define defchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_DEF))
  #define setchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_SET))
  #define digchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_AST|T_DIG))

--- 80,86 -----
  extern char	_ctype2[];
  
  #define	digit(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_DIG))
! #define dolchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_AST|T_BRC|T_DIG|T_IDC|T_SHN|_PLS))
  #define defchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_DEF))
  #define setchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_SET))
  #define digchar(c)	(((c)&QUOTE)==0 && _ctype2[c]&(T_AST|T_DIG))
:::::::: defs.c :::::::
*** ../orig.u/defs.c	Wed May 15 17:11:56 1985
--- defs.c	Thu May  9 10:57:13 1985
***************
*** 17,22
  struct ionod	*iopend;	/* documents waiting to be read at NL */
  struct fdsave	fdmap[NOFILE];
  
  /* substitution */
  int				dolc;
  char			**dolv;

--- 17,34 -----
  struct ionod	*iopend;	/* documents waiting to be read at NL */
  struct fdsave	fdmap[NOFILE];
  
+ /* history stuff */
+ int	event_count = 1;
+ int	expanded = 0;	/* did a history expansion occur? */
+ 
+ /* keep track of the parent pid */
+ int	ppid;
+ 
+ #if pyr
+ /* keep track of the current universe */
+ int	cur_univ;
+ #endif
+ 
  /* substitution */
  int				dolc;
  char			**dolv;
***************
*** 36,41
  /* special names */
  char			*pcsadr;
  char			*pidadr;
  char			*cmdadr;
  
  /* transput */ 

--- 48,54 -----
  /* special names */
  char			*pcsadr;
  char			*pidadr;
+ char			*ppidadr;
  char			*cmdadr;
  
  /* transput */ 
:::::::: defs.h :::::::
*** ../orig.u/defs.h	Wed May 15 17:11:56 1985
--- defs.h	Wed Jun  5 15:19:40 1985
***************
*** 3,9
   *	UNIX shell
   */
  
! #if BSD || gould
  #define	void	int	/* avoid compiler bug */
  #endif
  

--- 3,9 -----
   *	UNIX shell
   */
  
! #if BSD || gould || pyr
  #define	void	int	/* avoid compiler bug */
  #endif
  
***************
*** 87,92
  #define		SYSJOBS		29
  #define		SYSFG		30
  #define		SYSBG		31
  #endif
  
  /* used for input and output of shell */

--- 87,93 -----
  #define		SYSJOBS		29
  #define		SYSFG		30
  #define		SYSBG		31
+ #define		SYSSUSPEND	32
  #endif
  
  #if pyr
***************
*** 89,94
  #define		SYSBG		31
  #endif
  
  /* used for input and output of shell */
  #define 	INIO 		19
  

--- 90,105 -----
  #define		SYSSUSPEND	32
  #endif
  
+ #if pyr
+ #define		SYSATT		33
+ #define		SYSUCB		34
+ #define		SYSUNIVERSE	35
+ #define		U_ATT		1	/* ATT is Universe number 1 */
+ #define		U_UCB		2	/* UCB is Universe number 2 */
+ #endif
+ 
+ #define		SYSHISTORY	36
+ 
  /* used for input and output of shell */
  #define 	INIO 		19
  
***************
*** 111,117
  #include	"mode.h"
  #include	"name.h"
  #include	<signal.h>
! #if BSD
  #define	SIGUSR1	16
  #define	SIGUSR2	17
  #endif

--- 122,128 -----
  #include	"mode.h"
  #include	"name.h"
  #include	<signal.h>
! #if BSD && ! defined(pyr)	/* avoid dual universe problems */
  #define	SIGUSR1	16
  #define	SIGUSR2	17
  #endif
***************
*** 115,121
  #define	SIGUSR1	16
  #define	SIGUSR2	17
  #endif
! #if defined(JOBS) && !defined(BSD)
  #define	SIGSTOP	17
  #define	SIGTSTP	18
  #define	SIGCONT	19

--- 126,132 -----
  #define	SIGUSR1	16
  #define	SIGUSR2	17
  #endif
! #if defined(JOBS) && !defined(BSD) && !defined(pyr)
  #define	SIGSTOP	17
  #define	SIGTSTP	18
  #define	SIGCONT	19
***************
*** 123,128
  #define	SIGTTOU	22
  #endif
  
  
  /*	error catching */
  extern int 		errno;

--- 134,140 -----
  #define	SIGTTOU	22
  #endif
  
+ #define HISTSIZE	4096
  
  /*	error catching */
  extern int 		errno;
***************
*** 148,153
  extern char				*mactrim();
  extern char				*macro();
  extern char				*execs();
  /* extern char				*copyto();	/* DAG -- (bug fix) static */
  extern int				exname();
  extern char				*staknam();

--- 160,168 -----
  extern char				*mactrim();
  extern char				*macro();
  extern char				*execs();
+ extern char				*homedir();
+ extern char				*username();
+ extern char				*retcwd();
  /* extern char				*copyto();	/* DAG -- (bug fix) static */
  extern int				exname();
  extern char				*staknam();
***************
*** 168,173
  extern BOOL				j_finish();
  extern char				*j_macro();
  #endif
  
  #define 	attrib(n,f)		(n->namflg |= f)
  #define 	round(a,b)		(((int)(((char *)(a)+b)-1))&~((b)-1))

--- 183,189 -----
  extern BOOL				j_finish();
  extern char				*j_macro();
  #endif
+ extern int				history();
  
  #define 	attrib(n,f)		(n->namflg |= f)
  #define 	round(a,b)		(((int)(((char *)(a)+b)-1))&~((b)-1))
***************
*** 184,189
  extern struct ionod		*iopend;	/* documents waiting to be read at NL */
  extern struct fdsave	fdmap[];
  
  
  /* substitution */
  extern int				dolc;

--- 200,208 -----
  extern struct ionod		*iopend;	/* documents waiting to be read at NL */
  extern struct fdsave	fdmap[];
  
+ /* history stuff */
+ extern int	event_count;
+ extern int	expanded;	/* did a history expansion occur? */
  
  /* keep track of the parent pid */
  extern int	ppid;
***************
*** 185,190
  extern struct fdsave	fdmap[];
  
  
  /* substitution */
  extern int				dolc;
  extern char				**dolv;

--- 204,219 -----
  extern int	event_count;
  extern int	expanded;	/* did a history expansion occur? */
  
+ /* keep track of the parent pid */
+ extern int	ppid;
+ 
+ #if pyr
+ /* keep track of the current universe */
+ extern int	cur_univ;
+ extern char	*univ_name[];		/* from <universe.h> */
+ extern char	*univ_longname[];
+ #endif
+ 
  /* substitution */
  extern int				dolc;
  extern char				**dolv;
***************
*** 205,211
  extern char				endoffile[];
  extern char				synmsg[];
  extern char				setstr[]; 	/* DAG -- made sharable */
! extern char				sicrstr[];	/* DAG */
  extern char				bang[];		/* DAG */
  extern char				pdstr[];	/* DAG */
  extern char				dotdot[];	/* DAG */

--- 234,240 -----
  extern char				endoffile[];
  extern char				synmsg[];
  extern char				setstr[]; 	/* DAG -- made sharable */
! extern char				sicrqstr[];	/* ADR */
  extern char				bang[];		/* DAG */
  extern char				pdstr[];	/* DAG */
  extern char				dotdot[];	/* DAG */
***************
*** 228,233
  extern char				dashd[];	/* DAG */
  extern char				dashf[];	/* DAG */
  extern char				dashg[];	/* DAG */
  extern char				dashk[];	/* DAG */
  extern char				dashn[];	/* DAG */
  extern char				dasho[];	/* DAG */

--- 257,263 -----
  extern char				dashd[];	/* DAG */
  extern char				dashf[];	/* DAG */
  extern char				dashg[];	/* DAG */
+ extern char				dashi[];	/* ADR */
  extern char				dashk[];	/* DAG */
  #if pyr
  extern char				dashl[];	/* ADR */
***************
*** 229,234
  extern char				dashf[];	/* DAG */
  extern char				dashg[];	/* DAG */
  extern char				dashk[];	/* DAG */
  extern char				dashn[];	/* DAG */
  extern char				dasho[];	/* DAG */
  extern char				dashp[];	/* DAG */

--- 259,267 -----
  extern char				dashg[];	/* DAG */
  extern char				dashi[];	/* ADR */
  extern char				dashk[];	/* DAG */
+ #if pyr
+ extern char				dashl[];	/* ADR */
+ #endif
  extern char				dashn[];	/* DAG */
  extern char				dasho[];	/* DAG */
  extern char				dashp[];	/* DAG */
***************
*** 274,279
  extern char				ishashed[];	/* DAG */
  extern char				rpnlstr[];	/* DAG */
  extern char				isstr[];	/* DAG */
  #if JOBS
  extern char				rsqbrk[];
  extern char				spspstr[];

--- 307,313 -----
  extern char				ishashed[];	/* DAG */
  extern char				rpnlstr[];	/* DAG */
  extern char				isstr[];	/* DAG */
+ extern char				rdwstr[];	/* ADR */
  #if JOBS
  extern char				rsqbrk[];
  extern char				spspstr[];
***************
*** 300,305
  extern char				selsstr[];
  extern char				sfistr[];
  extern char				iesacstr[];
  #endif
  #if SYMLINK
  extern char				nolstat[];

--- 334,340 -----
  extern char				selsstr[];
  extern char				sfistr[];
  extern char				iesacstr[];
+ extern char				nosusp[];
  #endif
  #if SYMLINK
  extern char				nolstat[];
***************
*** 339,344
  extern char				supprompt[];
  extern char				profile[];
  extern char				sysprofile[];
  
  /* built in names */
  extern struct namnod	fngnod;

--- 374,381 -----
  extern char				supprompt[];
  extern char				profile[];
  extern char				sysprofile[];
+ extern char				shrc[];
+ extern char				savehist[];
  
  /* built in names */
  extern struct namnod	fngnod;
***************
*** 355,360
  #if BRL
  extern struct namnod	timenod;
  #endif
  
  /* special names */
  extern char				flagadr[];

--- 392,401 -----
  #if BRL
  extern struct namnod	timenod;
  #endif
+ #if pyr
+ extern struct namnod	univnod;
+ #endif
+ extern struct namnod	histfnod;
  
  /* special names */
  extern char				flagadr[];
***************
*** 360,365
  extern char				flagadr[];
  extern char				*pcsadr;
  extern char				*pidadr;
  extern char				*cmdadr;
  
  extern char				defpath[];

--- 401,407 -----
  extern char				flagadr[];
  extern char				*pcsadr;
  extern char				*pidadr;
+ extern char				*ppidadr;
  extern char				*cmdadr;
  
  extern char				defpath[];
***************
*** 378,383
  #if BRL
  extern char				timename[];	/* TIMEOUT */
  #endif
  
  /* transput */
  extern char				tmpout[];

--- 420,429 -----
  #if BRL
  extern char				timename[];	/* TIMEOUT */
  #endif
+ #if pyr
+ extern char				univname[];	/* UNIVERSE */
+ #endif
+ extern char				histfilename[];	/* HISTFILE */
  
  /* transput */
  extern char				tmpout[];
***************
*** 436,441
  #define		noeotflg	02000000
  #define		dotflg		04000000
  #endif
  
  extern long				flags;
  extern int				rwait;	/* flags read waiting */

--- 482,489 -----
  #define		noeotflg	02000000
  #define		dotflg		04000000
  #endif
+ #define		quickflg	010000000
+ #define		nohistflg	020000000
  
  extern long				flags;
  extern int				rwait;	/* flags read waiting */
***************
*** 444,450
  #include	<setjmp.h>
  extern jmp_buf			subshell;
  extern jmp_buf			errshell;
! #if defined(BSD) && !defined(BSD41C)
  #define	setjmp( env )		_setjmp( env )
  #define	longjmp( env, val )	_longjmp( env, val )
  #endif

--- 492,498 -----
  #include	<setjmp.h>
  extern jmp_buf			subshell;
  extern jmp_buf			errshell;
! #if defined(BSD) && !defined(BSD41C) && !defined(pyr)
  #define	setjmp( env )		_setjmp( env )
  #define	longjmp( env, val )	_longjmp( env, val )
  #endif
:::::::: echo.c :::::::
No differences encountered
:::::::: error.c :::::::
*** ../orig.u/error.c	Wed May 15 17:11:56 1985
--- error.c	Wed May 15 16:02:49 1985
***************
*** 96,101
  		exit(99);
  	}
  #endif
  	exit(exitval);
  }
  

--- 96,103 -----
  		exit(99);
  	}
  #endif
+ 
+ 	histsave (histfnod.namval);
  	exit(exitval);
  }
  
:::::::: expand.c :::::::
No differences encountered
:::::::: fault.c :::::::
No differences encountered
:::::::: func.c :::::::
*** ../orig.u/func.c	Wed May 15 17:11:56 1985
--- func.c	Wed Jun  5 16:01:27 1985
***************
*** 371,376
  					prs_buff(fromastr);	/* DAG */
  
  			}
  			else if ((iof & IOPUT) == 0)
  				prc_buff('<');
  			else if (iof & IOAPP)

--- 371,378 -----
  					prs_buff(fromastr);	/* DAG */
  
  			}
+ 			else if (iof & IORDW)
+ 				prs_buff(rdwstr);	/* ADR */
  			else if ((iof & IOPUT) == 0)
  				prc_buff('<');
  			else if (iof & IOAPP)
:::::::: hash.c :::::::
No differences encountered
:::::::: hash.h :::::::
No differences encountered
:::::::: hashserv.c :::::::
No differences encountered
:::::::: io.c :::::::
No differences encountered
:::::::: jobs.c :::::::
*** ../orig.u/jobs.c	Wed May 15 17:11:57 1985
--- jobs.c	Wed Jun  5 11:55:37 1985
***************
*** 3,8
   *
   *  created by Ron Natalie, BRL
   *  slight changes by Doug Gwyn
   */
  
  #include "defs.h"

--- 3,9 -----
   *
   *  created by Ron Natalie, BRL
   *  slight changes by Doug Gwyn
+  *  some more slight changes by Arnold Robbins (mainly for the BSD /bin/sh)
   */
  
  #include "defs.h"
***************
*** 8,14
  #include "defs.h"
  #include "sym.h"
  
! #if BSD	/* native /bin/sh */
  #include <sys/ioctl.h>
  #else	/* /usr/5bin/sh */
  #include	<sys/_ioctl.h>

--- 9,27 -----
  #include "defs.h"
  #include "sym.h"
  
! #ifndef TAB	/* very original, early /bin/sh */
! #include <signal.h>
! #define comptr(x)	((COMPTR) x)
! #define lstptr(x)	((LSTPTR) x)
! #define forkptr(x)	((FORKPTR) x)
! #define parptr(x)	((PARPTR) x)
! #define forptr(x)	((FORPTR) x)
! #define whptr(x)	((WHPTR) x)
! #define ifptr(x)	((IFPTR) x)
! #define swptr(x)	((SWPTR) x)
! #endif
! 
! #if BSD || (JOBS && ! BRL)	/* native /bin/sh */
  #include <sys/ioctl.h>
  #else	/* /usr/5bin/sh */
  #include	<sys/_ioctl.h>
***************
*** 457,463
  				if(j_stuff(numbuf))
  					return 1;
  			}
! 			switch(iof & (IODOC|IOPUT|IOMOV|IOAPP))  {
  			case IOGET:
  				if(j_stuff(rdinstr))	/* DAG */
  					return 1;

--- 470,476 -----
  				if(j_stuff(numbuf))
  					return 1;
  			}
! 			switch(iof & (IODOC|IOPUT|IOMOV|IOAPP|IORDW))  {
  			case IOGET:
  				if(j_stuff(rdinstr))	/* DAG */
  					return 1;
***************
*** 482,487
  				if(j_stuff(fromastr))	/* DAG */
  					return 1;
  				break;
  			}
  			if(j_stuff(t->ioname))
  				return 1;

--- 495,504 -----
  				if(j_stuff(fromastr))	/* DAG */
  					return 1;
  				break;
+ 			case IORDW:
+ 				if(j_stuff(rdwstr))	/* ADR */
+ 					return 1;
+ 				break;
  			}
  			if(j_stuff(t->ioname))
  				return 1;
***************
*** 503,508
  
  	type = t->tretyp & COMMSK;
  	switch(type)  {
  	case	TFND:	/* added by DAG for System V Release 2 shell */
  		return j_stuff(fndptr(t)->fndnam)
  		    || j_stuff(sfnstr)	/* DAG */

--- 520,526 -----
  
  	type = t->tretyp & COMMSK;
  	switch(type)  {
+ #ifdef TFND	/* ADR --- don't put this stuff in the plain BSD /bin/sh */
  	case	TFND:	/* added by DAG for System V Release 2 shell */
  		return j_stuff(fndptr(t)->fndnam)
  		    || j_stuff(sfnstr)	/* DAG */
***************
*** 508,513
  		    || j_stuff(sfnstr)	/* DAG */
  		    || j_do(fndptr(t)->fndval)
  		    || j_stuff(efnstr);	/* DAG */
  
  	case	TCOM:
  		if(comptr(t)->comset)  {

--- 526,532 -----
  		    || j_stuff(sfnstr)	/* DAG */
  		    || j_do(fndptr(t)->fndval)
  		    || j_stuff(efnstr);	/* DAG */
+ #endif
  
  	case	TCOM:
  		if(comptr(t)->comset)  {
:::::::: mac.h :::::::
*** ../orig.u/mac.h	Wed May 15 17:11:57 1985
--- mac.h	Thu Apr 25 11:44:51 1985
***************
*** 19,24
  #define RQ	'\''
  #define MINUS	'-'
  #define COLON	':'
  #define TAB	'\t'
  
  

--- 19,25 -----
  #define RQ	'\''
  #define MINUS	'-'
  #define COLON	':'
+ #define SQUIGGLE	'~'	/* TILDE defined in BSD tty handler */
  #define TAB	'\t'
  
  
:::::::: macro.c :::::::
*** ../orig.u/macro.c	Wed May 15 17:11:57 1985
--- macro.c	Thu Apr 25 11:44:51 1985
***************
*** 133,138
  			}
  			else if (c == '$')
  				v = pidadr;
  			else if (c == '!')
  				v = pcsadr;
  			else if (c == '#')

--- 133,147 -----
  			}
  			else if (c == '$')
  				v = pidadr;
+ 			else if (c == '+')
+ 			{
+ 				if (ppid != getppid())	/* parent died */
+ 				{
+ 					ppid = getppid();
+ 					assnum (&ppidadr, ppid);
+ 				}
+ 				v = ppidadr;
+ 			}
  			else if (c == '!')
  				v = pcsadr;
  			else if (c == '#')
:::::::: main.c :::::::
*** ../orig.u/main.c	Wed May 15 17:11:57 1985
--- main.c	Tue May 21 17:17:32 1985
***************
*** 69,77
  		if (argv0[0] != '-' || argv0[1] != 'S')
  			loginsh = 0;
  	}
! #endif
! #endif
! #if !defined(BRL) || !defined(pdp11)
  	loginsh = argv0[0] == '-';
  #endif
  

--- 69,75 -----
  		if (argv0[0] != '-' || argv0[1] != 'S')
  			loginsh = 0;
  	}
! #else
  	loginsh = argv0[0] == '-';
  #endif
  #endif
***************
*** 74,79
  #if !defined(BRL) || !defined(pdp11)
  	loginsh = argv0[0] == '-';
  #endif
  
  	stdsigs();
  

--- 72,78 -----
  #else
  	loginsh = argv0[0] == '-';
  #endif
+ #endif
  
  	stdsigs();
  
***************
*** 179,184
  	replace(&cmdadr, dolv[0]);	/* cmdadr is $0 */
  
  	/*
  	 * set pidname '$$'
  	 */
  	assnum(&pidadr, getpid());

--- 178,189 -----
  	replace(&cmdadr, dolv[0]);	/* cmdadr is $0 */
  
  	/*
+ 	 * set ppidname '$+'
+ 	 */
+ 	ppid = getppid();
+ 	assnum (& ppidadr, ppid);
+ 
+ 	/*
  	 * set pidname '$$'
  	 */
  	assnum(&pidadr, getpid());
***************
*** 202,207
  	dfault(&mchknod, MAILCHECK);
  	mailchk = stoi(mchknod.namval);
  
  	if ((beenhere) == FALSE)	/* ? profile */	/* DAG -- only increment once */
  	{
  		++beenhere;		/* DAG */

--- 207,239 -----
  	dfault(&mchknod, MAILCHECK);
  	mailchk = stoi(mchknod.namval);
  
+ #if pyr
+ 	/*
+ 	 * find out current universe, initialize $UNIVERSE
+ 	 */
+ 	cur_univ = setuniverse (U_UCB); /* retrieve old and set to UCB */
+ 	if (cur_univ == -1)
+ 	{
+ 		/* unknown current, default to UCB */
+ 		cur_univ = U_UCB;
+ 		setuniverse (cur_univ);
+ 	}
+ 	else if (cur_univ != U_UCB)
+ 		setuniverse (cur_univ); /* restore to what it was */
+ 	
+ 	/*
+ 	 * force value, ignore whatever was in environment
+ 	 */
+ 	assign (& univnod, univ_name[cur_univ - 1]);
+ 	attrib ((& univnod), N_RDONLY);   /* user can not set $UNIVERSE */
+ #endif
+ 
+ 	/*
+ 	 * assign default value of $HOME/.history to $HISTFILE
+ 	 */
+ 	(void) catpath ("~", savehist);
+ 	dfault (& histfnod, curstak());
+ 
  	if ((beenhere) == FALSE)	/* ? profile */	/* DAG -- only increment once */
  	{
  		++beenhere;		/* DAG */
***************
*** 211,216
  			struct stat	statb;	/* needed for test */
  #endif
  
  #ifndef RES
  
  			if ((input = pathopen(nullstr, sysprofile)) >= 0)

--- 243,253 -----
  			struct stat	statb;	/* needed for test */
  #endif
  
+ 			if (geteuid() != getuid())
+ 				setuid (getuid());
+ 			if (getegid() != getgid())
+ 				setgid (getgid());
+ 
  #ifndef RES
  
  			if ((input = pathopen(nullstr, sysprofile)) >= 0)
***************
*** 232,237
  		}
  		if (rsflag == 0 || rflag == 0)
  			flags |= rshflg;
  		/*
  		 * open input file if specified
  		 */

--- 269,288 -----
  		}
  		if (rsflag == 0 || rflag == 0)
  			flags |= rshflg;
+ 
+ 		/* if all OK, process $HOME/.shrc */
+ 		if (geteuid() == getuid() && getegid() == getgid()
+ 			&& (flags & (rshflg|quickflg)) == 0
+ 			&& (input = pathopen ("~", shrc)) >= 0)
+ 		{
+ 			int promptflags = (flags & (ttyflg|intflg|prompt));
+ 
+ 			/* turn off anything that will cause prompting */
+ 			flags &= ~promptflags;
+ 			exfile (rflag);
+ 			flags |= promptflags;
+ 		}
+ 
  		/*
  		 * open input file if specified
  		 */
***************
*** 300,305
  			setmail(mailpnod.namval);
  		else
  			setmail(mailnod.namval);
  	}
  	else
  	{

--- 351,359 -----
  			setmail(mailpnod.namval);
  		else
  			setmail(mailnod.namval);
+ 
+ 		/* restore previous history */
+ 		histrest (histfnod.namval);
  	}
  	else
  	{
***************
*** 349,355
  				}
  			}
  
! 			prs(ps1nod.namval);
  
  #if BRL
  			if (userid == 0 && !eq(ps1nod.namval, supprompt))

--- 403,410 -----
  				}
  			}
  
! 			/* do special handling for $PS1 */
! 			pr_prompt(ps1nod.namval);
  
  #if BRL
  			if (userid == 0 && !eq(ps1nod.namval, supprompt))
:::::::: mode.h :::::::
No differences encountered
:::::::: msg.c :::::::
*** ../orig.u/msg.c	Wed May 15 17:11:58 1985
--- msg.c	Wed Jun  5 15:19:55 1985
***************
*** 42,49
  char	wtfailed[]	= "is read only";
  char	notid[]		= "is not an identifier";
  char 	badulimit[]	= "bad ulimit";	/* DAG -- lower case */
! char	badreturn[] = "cannot return when not in function";
! char	badexport[] = "cannot export functions";
  char	badunset[] 	= "cannot unset";
  char	nohome[]	= "no home directory";
  char 	badperm[]	= "execute permission denied";

--- 42,49 -----
  char	wtfailed[]	= "is read only";
  char	notid[]		= "is not an identifier";
  char 	badulimit[]	= "bad ulimit";	/* DAG -- lower case */
! char	badreturn[]	= "cannot return when not in function";
! char	badexport[]	= "cannot export functions";
  char	badunset[] 	= "cannot unset";
  char	nohome[]	= "no home directory";
  char 	badperm[]	= "execute permission denied";
***************
*** 98,103
  #if BRL
  char	timename[]	= "TIMEOUT";
  #endif
  
  /*
   * string constants

--- 98,107 -----
  #if BRL
  char	timename[]	= "TIMEOUT";
  #endif
+ #if pyr
+ char	univname[]	= "UNIVERSE";
+ #endif
+ char	histfilename[]	= "HISTFILE";
  
  /*
   * string constants
***************
*** 116,122
  char	stdprompt[]	= "$ ";
  char	supprompt[]	= "# ";
  char	profile[]	= ".profile";
! #if !defined(BRL) || defined(pdp11)
  char	sysprofile[]	= "/etc/profile";
  #else
  char	sysprofile[]	= "/usr/5lib/profile";

--- 120,128 -----
  char	stdprompt[]	= "$ ";
  char	supprompt[]	= "# ";
  char	profile[]	= ".profile";
! char	shrc[]		= ".shrc";
! char	savehist[]	= ".history";
! #if defined(GATECH) || !defined(BRL) || defined(pdp11)
  char	sysprofile[]	= "/etc/profile";
  #else
  char	sysprofile[]	= "/usr/5lib/profile";
***************
*** 122,128
  char	sysprofile[]	= "/usr/5lib/profile";
  #endif
  char	setstr[]	= "set";			/* DAG -- made sharable */
! char	sicrstr[]	= "sicr";			/* DAG */
  char	bang[]		= "!";				/* DAG */
  char	pdstr[]		= ".";				/* DAG */
  char	dotdot[]	= "..";				/* DAG */

--- 128,134 -----
  char	sysprofile[]	= "/usr/5lib/profile";
  #endif
  char	setstr[]	= "set";			/* DAG -- made sharable */
! char	sicrqstr[]	= "sicrq";			/* ADR */
  char	bang[]		= "!";				/* DAG */
  char	pdstr[]		= ".";				/* DAG */
  char	dotdot[]	= "..";				/* DAG */
***************
*** 145,150
  char	dashd[]		= "-d";				/* DAG */
  char	dashf[]		= "-f";				/* DAG */
  char	dashg[]		= "-g";				/* DAG */
  char	dashk[]		= "-k";				/* DAG */
  char	dashn[]		= "-n";				/* DAG */
  char	dasho[]		= "-o";				/* DAG */

--- 151,157 -----
  char	dashd[]		= "-d";				/* DAG */
  char	dashf[]		= "-f";				/* DAG */
  char	dashg[]		= "-g";				/* DAG */
+ char	dashi[]		= "-i";				/* ADR */
  char	dashk[]		= "-k";				/* DAG */
  #if pyr
  char	dashl[]		= "-l";				/* ADR */
***************
*** 146,151
  char	dashf[]		= "-f";				/* DAG */
  char	dashg[]		= "-g";				/* DAG */
  char	dashk[]		= "-k";				/* DAG */
  char	dashn[]		= "-n";				/* DAG */
  char	dasho[]		= "-o";				/* DAG */
  char	dashp[]		= "-p";				/* DAG */

--- 153,161 -----
  char	dashg[]		= "-g";				/* DAG */
  char	dashi[]		= "-i";				/* ADR */
  char	dashk[]		= "-k";				/* DAG */
+ #if pyr
+ char	dashl[]		= "-l";				/* ADR */
+ #endif
  char	dashn[]		= "-n";				/* DAG */
  char	dasho[]		= "-o";				/* DAG */
  char	dashp[]		= "-p";				/* DAG */
***************
*** 191,196
  char	ishashed[]	= " is hashed (";		/* DAG */
  char	rpnlstr[]	= ")\n";			/* DAG */
  char	isstr[]		= " is ";			/* DAG */
  #if JOBS
  char	rsqbrk[]	= "] ";
  char	spspstr[]	= " \ ";

--- 201,207 -----
  char	ishashed[]	= " is hashed (";		/* DAG */
  char	rpnlstr[]	= ")\n";			/* DAG */
  char	isstr[]		= " is ";			/* DAG */
+ char	rdwstr[]	= "<> ";
  #if JOBS
  char	rsqbrk[]	= "] ";
  char	spspstr[]	= " \ ";
***************
*** 217,222
  char	selsstr[]	= "; else ";
  char	sfistr[]	= "; fi";
  char	iesacstr[]	= " in ... esac";
  #endif
  #if BRL
  char	drshell[]	= "-rsh";

--- 228,234 -----
  char	selsstr[]	= "; else ";
  char	sfistr[]	= "; fi";
  char	iesacstr[]	= " in ... esac";
+ char	nosusp[]	= "cannot suspend a login shell\n";	/* yet... */
  #endif
  #if BRL
  char	drshell[]	= "-rsh";
***************
*** 329,334
  	{ lbstr,	SYSTST },	/* DAG -- use shared string */
  #endif
  
  #if JOBS
  	{ "bg",		SYSBG },
  #endif

--- 341,350 -----
  	{ lbstr,	SYSTST },	/* DAG -- use shared string */
  #endif
  
+ #if pyr
+ 	{ "att",	SYSATT },
+ #endif
+ 
  #if JOBS
  	{ "bg",		SYSBG },
  #endif
***************
*** 347,352
  #endif
  
  	{ "hash",	SYSHASH	},
  
  #if JOBS
  	{ "jobs",	SYSJOBS },

--- 363,369 -----
  #endif
  
  	{ "hash",	SYSHASH	},
+ 	{ "history",	SYSHISTORY },
  
  #if JOBS
  	{ "jobs",	SYSJOBS },
***************
*** 376,381
  	{ "return",	SYSRETURN },
  	{ setstr,	SYSSET	},	/* DAG -- use shared string */
  	{ "shift",	SYSSHFT	},
  	{ "test",	SYSTST },
  	{ "times",	SYSTIMES },
  	{ "trap",	SYSTRAP	},

--- 393,401 -----
  	{ "return",	SYSRETURN },
  	{ setstr,	SYSSET	},	/* DAG -- use shared string */
  	{ "shift",	SYSSHFT	},
+ #if JOBS
+ 	{ "suspend",	SYSSUSPEND },	/* ADR */
+ #endif
  	{ "test",	SYSTST },
  	{ "times",	SYSTIMES },
  	{ "trap",	SYSTRAP	},
***************
*** 381,386
  	{ "trap",	SYSTRAP	},
  	{ "type",	SYSTYPE },
  
  
  #ifndef RES		
  	{ "ulimit",	SYSULIMIT },

--- 401,409 -----
  	{ "trap",	SYSTRAP	},
  	{ "type",	SYSTYPE },
  
+ #if pyr
+ 	{ "ucb",	SYSUCB },
+ #endif
  
  #ifndef RES		
  	{ "ulimit",	SYSULIMIT },
***************
*** 387,392
  	{ "umask",	SYSUMASK },
  #endif
  
  	{ "unset", 	SYSUNS },
  	{ "wait",	SYSWAIT	}
  };

--- 410,419 -----
  	{ "umask",	SYSUMASK },
  #endif
  
+ #if pyr
+ 	{ "universe",	SYSUNIVERSE },
+ #endif
+ 
  	{ "unset", 	SYSUNS },
  	{ "wait",	SYSWAIT	}
  };
***************
*** 392,394
  };
  
  int	no_commands = sizeof commands / sizeof(struct sysnod);	/* DAG -- improved */

--- 419,427 -----
  };
  
  int	no_commands = sizeof commands / sizeof(struct sysnod);	/* DAG -- improved */
+ 
+ #if pyr
+ #include <sys/types.h>	/* to get sys/inode.h to work (sigh) */
+ #include <sys/inode.h>	/* NUMUNIV is defined to be NCLNK */
+ #include <universe.h>	/* gets char *univ_name[] && char *univ_longname[] */
+ #endif
:::::::: name.c :::::::
*** ../orig.u/name.c	Wed May 15 17:11:58 1985
--- name.c	Wed May  8 10:02:45 1985
***************
*** 15,20
  #if BRL
  struct namnod timenod =	/* for TIMEOUT */
  {
  	(struct namnod *)NIL,
  	(struct namnod *)NIL,
  	timename

--- 15,24 -----
  #if BRL
  struct namnod timenod =	/* for TIMEOUT */
  {
+ 	&acctnod,
+ #if pyr
+ 	&univnod,
+ #else
  	(struct namnod *)NIL,
  #endif
  	timename
***************
*** 16,22
  struct namnod timenod =	/* for TIMEOUT */
  {
  	(struct namnod *)NIL,
! 	(struct namnod *)NIL,
  	timename
  };
  #endif

--- 20,26 -----
  	&univnod,
  #else
  	(struct namnod *)NIL,
! #endif
  	timename
  };
  #endif
***************
*** 20,26
  	timename
  };
  #endif
! struct namnod ps2nod =
  {
  	(struct namnod *)NIL,
  	&acctnod,

--- 24,31 -----
  	timename
  };
  #endif
! #if pyr
! struct namnod univnod = /* current universe */
  {
  #if BRL
  	(struct namnod *)NIL,
***************
*** 22,27
  #endif
  struct namnod ps2nod =
  {
  	(struct namnod *)NIL,
  	&acctnod,
  	ps2name

--- 27,33 -----
  #if pyr
  struct namnod univnod = /* current universe */
  {
+ #if BRL
  	(struct namnod *)NIL,
  #else
  	&acctnod,
***************
*** 23,28
  struct namnod ps2nod =
  {
  	(struct namnod *)NIL,
  	&acctnod,
  	ps2name
  };

--- 29,35 -----
  {
  #if BRL
  	(struct namnod *)NIL,
+ #else
  	&acctnod,
  #endif
  	(struct namnod *)NIL,
***************
*** 24,29
  {
  	(struct namnod *)NIL,
  	&acctnod,
  	ps2name
  };
  struct namnod cdpnod = 

--- 31,59 -----
  	(struct namnod *)NIL,
  #else
  	&acctnod,
+ #endif
+ 	(struct namnod *)NIL,
+ 	univname,
+ };
+ #endif
+ struct namnod histfnod =	/* history file */
+ {
+ 	&cdpnod,
+ 	&homenod,
+ 	histfilename
+ };
+ struct namnod ps2nod =
+ {
+ 	&ps1nod,
+ #if BRL
+ 	&timenod,
+ #else
+ #if pyr
+ 	&univnod,
+ #else
+ 	&acctnod,
+ #endif
+ #endif
  	ps2name
  };
  struct namnod cdpnod = 
***************
*** 34,40
  };
  struct namnod pathnod =
  {
- 	&mailpnod,
  	(struct namnod *)NIL,
  	pathname
  };

--- 64,69 -----
  };
  struct namnod pathnod =
  {
  	(struct namnod *)NIL,
  	(struct namnod *)NIL,
  	pathname
***************
*** 36,41
  {
  	&mailpnod,
  	(struct namnod *)NIL,
  	pathname
  };
  struct namnod ifsnod =

--- 65,71 -----
  struct namnod pathnod =
  {
  	(struct namnod *)NIL,
+ 	(struct namnod *)NIL,
  	pathname
  };
  struct namnod ifsnod =
***************
*** 40,46
  };
  struct namnod ifsnod =
  {
! 	&homenod,
  	&mailnod,
  	ifsname
  };

--- 70,76 -----
  };
  struct namnod ifsnod =
  {
! 	&histfnod,
  	&mailnod,
  	ifsname
  };
***************
*** 47,53
  struct namnod ps1nod =
  {
  	&pathnod,
! 	&ps2nod,
  	ps1name
  };
  struct namnod homenod =

--- 77,83 -----
  struct namnod ps1nod =
  {
  	&pathnod,
! 	(struct namnod *)NIL,
  	ps1name
  };
  struct namnod homenod =
***************
*** 52,58
  };
  struct namnod homenod =
  {
- 	&cdpnod,
  	(struct namnod *)NIL,
  	homename
  };

--- 82,87 -----
  };
  struct namnod homenod =
  {
  	(struct namnod *)NIL,
  	(struct namnod *)NIL,
  	homename
***************
*** 54,59
  {
  	&cdpnod,
  	(struct namnod *)NIL,
  	homename
  };
  struct namnod mailnod =

--- 83,89 -----
  struct namnod homenod =
  {
  	(struct namnod *)NIL,
+ 	(struct namnod *)NIL,
  	homename
  };
  struct namnod mailnod =
***************
*** 59,65
  struct namnod mailnod =
  {
  	(struct namnod *)NIL,
! 	(struct namnod *)NIL,
  	mailname
  };
  struct namnod mchknod =

--- 89,95 -----
  struct namnod mailnod =
  {
  	(struct namnod *)NIL,
! 	&mchknod,
  	mailname
  };
  struct namnod mchknod =
***************
*** 64,71
  };
  struct namnod mchknod =
  {
! 	&ifsnod,
! 	&ps1nod,
  	mchkname
  };
  struct namnod acctnod =

--- 94,101 -----
  };
  struct namnod mchknod =
  {
! 	(struct namnod *)NIL,
! 	(struct namnod *)NIL,
  	mchkname
  };
  struct namnod acctnod =
***************
*** 71,79
  struct namnod acctnod =
  {
  	(struct namnod *)NIL,
- #if BRL
- 	&timenod,	/* lopsided tree, but who cares */
- #else
  	(struct namnod *)NIL,
  #endif
  	acctname

--- 101,106 -----
  struct namnod acctnod =
  {
  	(struct namnod *)NIL,
  	(struct namnod *)NIL,
  	acctname
  };
***************
*** 75,81
  	&timenod,	/* lopsided tree, but who cares */
  #else
  	(struct namnod *)NIL,
- #endif
  	acctname
  };
  struct namnod mailpnod =

--- 102,107 -----
  {
  	(struct namnod *)NIL,
  	(struct namnod *)NIL,
  	acctname
  };
  struct namnod mailpnod =
***************
*** 80,87
  };
  struct namnod mailpnod =
  {
! 	(struct namnod *)NIL,
! 	(struct namnod *)NIL,
  	mailpname
  };
  

--- 106,113 -----
  };
  struct namnod mailpnod =
  {
! 	&ifsnod,
! 	&ps2nod,
  	mailpname
  };
  
***************
*** 86,92
  };
  
  
! struct namnod *namep = &mchknod;
  
  /* ========	variable and string handling	======== */
  

--- 112,118 -----
  };
  
  
! struct namnod *namep = &mailpnod;
  
  /* ========	variable and string handling	======== */
  
:::::::: name.h :::::::
No differences encountered
:::::::: print.c :::::::
*** ../orig.u/print.c	Wed May 15 17:11:58 1985
--- print.c	Wed May 29 16:24:45 1985
***************
*** 265,267
  
  	prs_buff(numbuf);
  }

--- 265,384 -----
  
  	prs_buff(numbuf);
  }
+ 
+ void
+ pr_prompt (str)
+ register char *str;
+ {
+ 	for (; *str; str++)
+ 	{
+ 		if (*str != '%')
+ 			prc_buff (*str);
+ 		else if (*(str+1) == 'd')
+ 		{
+ 			/* current directory */
+ 			str++;
+ 			prs_buff (retcwd());
+ 		}
+ 		else if (*(str+1) == 'e')
+ 		{
+ 			/* event count */
+ 			str++;
+ 			if ((flags & nohistflg) == 0)
+ 				prn_buff (event_count);
+ 		}
+ 		else if (*(str+1) == 'h')
+ 		{
+ 			/* hostname */
+ 			static char *cp = 0;
+ 			static int didhost = FALSE;
+ 			static int didgt = FALSE;
+ #ifdef BSD
+ 			static char buf[257];
+ 
+ 			if (! didhost)
+ 			{
+ 				gethostname (buf, sizeof buf);
+ 				didhost = TRUE;
+ 				cp = buf;
+ 			}
+ #else
+ #include <sys/utsname.h>	/* has an extern declaration in it */
+ 			static struct utsname name;
+ 
+ 			if (! didhost)
+ 			{
+ 				uname (& name);
+ 				/* avoid emulation bug */
+ 				name.sysname[sizeof(name.sysname)-1] = '\0';
+ 				didhost = TRUE;
+ 				cp = name.sysname;
+ 			}
+ #endif
+ 
+ #ifdef GATECH
+ 			/*
+ 			 * this is to get rid of the dumb gt- convention.
+ 			 * a gt w/out the - is also removed.
+ 			 */
+ 			if (! didgt)
+ 			{
+ 				didgt = TRUE;
+ 				if (cp[0] == 'g' && cp[1] == 't' && cp[2])
+ 				{
+ 					cp += 2;
+ 					if (cp[0] == '-' && cp[1])
+ 						cp++;
+ 				}
+ 			}
+ #endif
+ 			prs_buff (cp);
+ 			str++;
+ 		}
+ 		else if (*(str+1) == 'l')
+ 		{
+ 			/* login name */
+ 			static char *cp = 0;
+ 			static int didname = FALSE;
+ 
+ 			str++;
+ 			if (! didname)
+ 			{
+ 				cp = username ();
+ 				didname = TRUE;
+ 			}
+ 
+ 			if (cp)
+ 				prs_buff (cp);
+ 		}
+ 		else if (*(str+1) == 't')
+ 		{
+ 			/* current time, HH:MM */
+ 			long l;
+ 			char *cp, *ctime ();
+ 
+ 			str++;
+ 			time (& l);
+ 			cp = ctime (& l);
+ 			cp[16] = '\0';
+ 			cp += 11;
+ 			prs_buff (cp);
+ 		}
+ #if pyr
+ 		else if (*(str+1) == 'u')
+ 		{
+ 			/* current univeserse */
+ 			str++;
+ 			prs_buff (univ_name[cur_univ-1]);
+ 		}
+ #endif
+ 		else if (*(str+1) == '\0')	/* % was last char in string */
+ 		{
+ 			prc_buff (*str);
+ 			continue;
+ 		}
+ 		else
+ 			prc_buff (*(++str));
+ 	}
+ 	flushb();
+ }
:::::::: pwd.c :::::::
*** ../orig.u/pwd.c	Wed May 15 17:11:58 1985
--- pwd.c	Thu Apr 25 11:44:56 1985
***************
*** 455,457
  	return retval;
  	}
  #endif

--- 455,466 -----
  	return retval;
  	}
  #endif
+ 
+ char *
+ retcwd()
+ {
+ 	if (didpwd == FALSE)
+ 		pwd ();
+ 	
+ 	return (cwdname);
+ }
:::::::: service.c :::::::
*** ../orig.u/service.c	Wed May 15 17:11:58 1985
--- service.c	Wed May 29 15:55:29 1985
***************
*** 79,84
  				else
  					fd = dup(fd);
  			}
  			else if ((iof & IOPUT) == 0)
  				fd = chkopen(ion);
  			else if (flags & rshflg)

--- 79,89 -----
  				else
  					fd = dup(fd);
  			}
+ 			else if (iof & IORDW)
+ 			{
+ 				if ((fd = open(ion, 2)) < 0)
+ 					failed(ion, badopen);
+ 			}
  			else if ((iof & IOPUT) == 0)
  				fd = chkopen(ion);
  			else if (flags & rshflg)
***************
*** 157,162
  	 */
  	register char	*scanp = path;
  	register char	*argp = locstak();
  
  	while (*scanp && *scanp != COLON)
  		*argp++ = *scanp++;

--- 162,169 -----
  	 */
  	register char	*scanp = path;
  	register char	*argp = locstak();
+ 	char	*save = argp;
+ 	char	*cp;
  
  	while (*scanp && *scanp != COLON)
  		*argp++ = *scanp++;
***************
*** 160,165
  
  	while (*scanp && *scanp != COLON)
  		*argp++ = *scanp++;
  	if (scanp != path)
  		*argp++ = '/';
  	if (*scanp == COLON)

--- 167,179 -----
  
  	while (*scanp && *scanp != COLON)
  		*argp++ = *scanp++;
+ 	*argp = '\0';
+ 	/* try a tilde expansion */
+ 	if (*save == SQUIGGLE && (cp = homedir (save + 1)) != nullstr)
+ 	{
+ 		movstr (cp, save);
+ 		argp = save + length (save) - 1;
+ 	}
  	if (scanp != path)
  		*argp++ = '/';
  	if (*scanp == COLON)
:::::::: setbrk.c :::::::
No differences encountered
:::::::: signal.vax :::::::
No differences encountered
:::::::: stak.c :::::::
No differences encountered
:::::::: stak.h :::::::
No differences encountered
:::::::: string.c :::::::
No differences encountered
:::::::: sym.h :::::::
No differences encountered
:::::::: test.c :::::::
*** ../orig.u/test.c	Wed May 15 17:11:59 1985
--- test.c	Thu Apr 25 11:45:03 1985
***************
*** 126,132
  		if (eq(a, dashk))				/* DAG */
  			return(ftype(nxtarg(0), S_ISVTX));
  		if (eq(a, dashp))				/* DAG */
! #if BSD
  #define S_IFIFO	S_IFSOCK	/* fifo - map to socket on 4.2BSD */
  #endif
  			return(filtyp(nxtarg(0),S_IFIFO));

--- 126,132 -----
  		if (eq(a, dashk))				/* DAG */
  			return(ftype(nxtarg(0), S_ISVTX));
  		if (eq(a, dashp))				/* DAG */
! #if BSD && !defined(pyr)
  #define S_IFIFO	S_IFSOCK	/* fifo - map to socket on 4.2BSD */
  #endif
  			return(filtyp(nxtarg(0),S_IFIFO));
:::::::: timeout.h :::::::
No differences encountered
:::::::: ulimit.c :::::::
No differences encountered
:::::::: word.c :::::::
*** ../orig.u/word.c	Wed May 15 17:11:59 1985
--- word.c	Thu Jun  6 14:32:13 1985
***************
*** 19,24
  	struct argnod	*arg = (struct argnod *)locstak();
  	register char	*argp = arg->argval;
  	int		alpha = 1;
  
  	wdnum = 0;
  	wdset = 0;

--- 19,25 -----
  	struct argnod	*arg = (struct argnod *)locstak();
  	register char	*argp = arg->argval;
  	int		alpha = 1;
+ 	char		*save;
  
  	wdnum = 0;
  	wdset = 0;
***************
*** 41,46
  			break;	/* out of comment - white space loop */
  		}
  	}
  	if (!eofmeta(c))
  	{
  		do

--- 42,48 -----
  			break;	/* out of comment - white space loop */
  		}
  	}
+ 	save = argp;	/* save start of word */
  	if (!eofmeta(c))
  	{
  		do
***************
*** 72,77
  							chkpr();
  					}
  				}
  			}
  		} while ((c = nextc(0), !eofmeta(c)));
  		argp = endstak(argp);

--- 74,98 -----
  							chkpr();
  					}
  				}
+ 				/*
+ 				 * check for ~login name
+ 				 */
+ 				else if (c == SQUIGGLE &&
+ 						validtilde (save, argp))
+ 				{
+ 					char *name, *home;
+ 
+ 					name = argp;
+ 					while ((c = nextc(0)) != '/' &&
+ 							!eofmeta(c))
+ 						*name++ = c;
+ 					peekc = c;
+ 					*name = '\0';
+ 					home = homedir(argp);
+ 					if (*home)
+ 						movstr (home, --argp);
+ 					argp += length (argp) - 1;
+ 				}
  			}
  		} while ((c = nextc(0), !eofmeta(c)));
  		argp = endstak(argp);
***************
*** 120,125
  			wdval = EOFSYM;
  		if (iopend && eolchar(c))
  		{
  			copy(iopend);
  			iopend = 0;
  		}

--- 141,149 -----
  			wdval = EOFSYM;
  		if (iopend && eolchar(c))
  		{
+ 			int histon = (flags&nohistflg) == 0;
+ 
+ 			flags |= nohistflg;	/* no history in here docs */
  			copy(iopend);
  			if (histon)		/* turn history back on */
  				flags &= ~nohistflg;
***************
*** 121,126
  		if (iopend && eolchar(c))
  		{
  			copy(iopend);
  			iopend = 0;
  		}
  	}

--- 145,152 -----
  
  			flags |= nohistflg;	/* no history in here docs */
  			copy(iopend);
+ 			if (histon)		/* turn history back on */
+ 				flags &= ~nohistflg;
  			iopend = 0;
  		}
  	}
***************
*** 245,251
  	}
  	else
  	{
! 		f->fend = (f->fnxt = f->fbuf) + len;
  #if BRL || JOBS
  		eofcount = 0;
  #endif

--- 271,278 -----
  	}
  	else
  	{
! 		/* f->fend = (f->fnxt = f->fbuf) + len; */
! 		f->fend = f->fnxt + len;
  #if BRL || JOBS
  		eofcount = 0;
  #endif
***************
*** 255,261
  }
  
  static
! readb()
  {
  	register struct fileblk *f = standin;
  	register int	len;

--- 282,288 -----
  }
  
  static
! readblock()	/* ADR -- changed the name */
  {
  	register struct fileblk *f = standin;
  	register int	len;
***************
*** 275,278
  		}
  	} while ((len = read(f->fdes, f->fbuf, f->fsiz)) < 0 && trapnote);
  	return(len);
  }

--- 302,502 -----
  		}
  	} while ((len = read(f->fdes, f->fbuf, f->fsiz)) < 0 && trapnote);
  	return(len);
+ }
+ 
+ /* readb --- read a block from the outside world, and history process it */
+ 
+ /*
+  * In BSD systems, using the literal next capability of the tty driver, it
+  * is actually possible to put a newline in the middle of the input line,
+  * and then hit return, so that the shell sees two lines of input.
+  *
+  * As a design decision, if there is a \n in the middle of what we've read
+  * from a terminal, treat the commands as two separately typed commands. I.e.
+  *
+  *	echo hi ^J echo there
+  *
+  * is the same as
+  *
+  *	echo hi
+  *	echo there
+  *
+  * The major reason for doing it this way is that the history mechanism knows
+  * that a \n is the end of a line.
+  *
+  * Finally, on USG systems, we just leave this code alone, since it won't
+  * get executed anyway.
+  */
+ 
+ /*
+  * In word.c, the readc() function keeps a pointer to what standin pointed to
+  * when readc first gets called.  Therefore, where standin points to can not 
+  * not change across calls to readb().  To get around this, we change the
+  * contents of the structure pointed to by standin, saving and restoring
+  * it as necessary.
+  */
+ 
+ #define LARGEBUF	(HISTSIZE / 2)	/* size of expanded history */
+ 
+ static
+ readb()
+ {
+ 	int ilen, i, j;
+ 	char ibuf[BUFSIZ];	/* input into scratch area, pass to history */
+ 	static char expansion[LARGEBUF];
+ 	static int moreinbuf = FALSE;
+ 	static int saved_ilen = 0;
+ 	static int start_here = 0;
+ 	static struct fileblk *f = 0;
+ 	auto int gotoutofbuf = 0;
+ 
+ 	if (expanded)	/* just did a history substitution */
+ 		expanded = 0;
+ 
+ 	if ((flags & nohistflg) || (flags & prompt) == 0 || ! isatty (input)
+ 			|| standin->fstak != 0)
+ 	{
+ 		ilen = readblock ();
+ 		if (ilen > 0)
+ 			standin->fnxt = standin->fbuf;
+ 		return (ilen);
+ 		/* not doing history expansion at all */
+ 	}
+ 
+ 	if (f == 0)
+ 		f = standin;
+ 
+ 	ilen = 0;
+ 
+ 	/*
+ 	 * First, if there was more stuff in the last buffer, go and get it.
+ 	 * If not get some more from the outside world.
+ 	 *
+ 	 * Then, make sure we've read up to a newline.
+ 	 * This is basically in case someone has done something bizarre
+ 	 * like 'stty raw', and input is coming in one character at a time.
+ 	 *
+ 	 * We use a heuristic.  If amount read is just 1, keep reading till
+ 	 * we get a newline.  Else, read in a complete line from the terminal.
+ 	 * Once we're in raw mode, can't reset it until a newline is typed.
+ 	 *
+ 	 * If not reading one character at a time, then do the stuff for
+ 	 * embedded newlines.
+ 	 */
+ 
+ 	if (moreinbuf)
+ 	{
+ 		for (i = 0, j = start_here; f->fbuf[j] != NL && j < saved_ilen; i++, j++)
+ 			ibuf[i] = f->fbuf[j];
+ 
+ #ifdef notdef
+ 		if (f->fbuf[j] != NL)
+ 		{
+ 			prs ("internal i/o error C in readb\n");
+ 			return (0);
+ 		}
+ #endif
+ 
+ 		if (f->fbuf[j] == NL)
+ 			ibuf[i++] = NL;
+ 		ibuf[i] = '\0';
+ 		ilen = i;
+ 		/* embedded newline */
+ 		moreinbuf = (++j < saved_ilen - 1);
+ 		if (moreinbuf)
+ 			start_here = j;	/* where to start next time */
+ 		gotoutofbuf = 1;
+ 	}
+ 	else	/* wasn't an embedded \n last time */
+ 	{
+ 		ilen = readblock ();
+ 	
+ 		if (ilen <= 0)	/* EOF or error */
+ 			return (ilen);
+ 
+ 		if (ilen == 1)	/* either in raw mode, or an empty line */
+ 		{
+ 			i = 0;
+ 			ibuf[i++] = f->fbuf[0];
+ 			if (f->fbuf[0] == NL)
+ 			{
+ 				ibuf[i] = '\0';
+ 				goto dohist;
+ 			}
+ 
+ 			while ((ilen = readblock()) > 0)
+ 			{
+ 				if (ilen != 1)
+ 				{
+ 					prs ("internal i/o error A in readb\n");
+ 					return (0);
+ 				}
+ 				ibuf[i++] = f->fbuf[0];
+ 				if (f->fbuf[0] == NL)
+ 				{
+ 					ibuf[i] = '\0';
+ 					break;	/* while */
+ 				}
+ 			}
+ 			ilen = i;
+ 			gotoutofbuf = TRUE;
+ 			/* force code below to use collected string */
+ 		}
+ 		else
+ 		{
+ 			/* reading bunches of characters at once */
+ 			for (i = 0; f->fbuf[i] != NL && i < ilen; i++)
+ 				ibuf[i] = f->fbuf[i];
+ 
+ #ifdef notdef
+ 			if (f->fbuf[i] != NL)
+ 			{
+ 				prs ("internal i/o error B in readb\n");
+ 				return (0);
+ 			}
+ #endif
+ 
+ 			ibuf[i++] = NL;
+ 			ibuf[i] = '\0';
+ 			/* ilen was set by readblock() */
+ 			/* embedded newline */
+ 			moreinbuf = (i < ilen - 1);
+ 			if (moreinbuf)
+ 			{
+ 				saved_ilen = ilen;
+ 				start_here = i;
+ 				/* where to start next time */
+ 				gotoutofbuf = 1;
+ 			}
+ 		}
+ 	}
+ 
+ dohist:
+ 	/* quick heuristic */
+ 	if (! gotoutofbuf && ilen == 1 && f->fbuf[0] == NL)
+ 	{
+ 		f->fnxt = f->fbuf;
+ 		return (ilen);
+ 	}
+ 
+ 	if (histsub (ibuf, expansion, sizeof expansion))
+ 	{
+ 		int olen = length (expansion) - 1;
+ 		if (! expanded && ! gotoutofbuf)
+ 		{
+ 			standin->fnxt = standin->fbuf;
+ 			return (ilen);
+ 		}
+ 		/* else
+ 			expanded == TRUE or from buffer */
+ 		standin->fnxt = expansion;
+ 		return (olen);
+ 	}
+ 	else
+ 	{
+ 		/* hist expansion failed, return an empty line */
+ 		standin->fnxt = standin->fbuf;
+ 		standin->fbuf[0] = NL;
+ 		return (1);
+ 	}
  }
:::::::: xec.c :::::::
*** ../orig.u/xec.c	Wed May 15 17:12:00 1985
--- xec.c	Tue Jun  4 17:57:01 1985
***************
*** 27,32
  	 */
  	register struct trenod	*t;
  	char		*sav = savstak();
  
  	sigchk();
  	if (!errorflg)

--- 27,42 -----
  	 */
  	register struct trenod	*t;
  	char		*sav = savstak();
+ #if pyr
+ 	auto int change_univ = FALSE;
+ 	auto int new_univ = 0;
+ 	/*
+ 	 * univesrses run from 1 to NUMUNIV: We start out at 0
+ 	 * and increment new_univ in the switch for internal
+ 	 * commands, below.  new_univ must *not* be assigned to, directly
+ 	 * or via side effects, any place else.
+ 	 */
+ #endif
  
  	sigchk();
  	if (!errorflg)
***************
*** 109,114
  					if (flags & execpr)
  						execprint(com);
  
  					if (comtype == NOTFOUND)
  					{
  						pos = hashdata(cmdhash);

--- 119,130 -----
  					if (flags & execpr)
  						execprint(com);
  
+ 					/*
+ 					 * fix a bug which caused the shell
+ 					 * to do not do a second command if
+ 					 * the first was not found. (bug fix
+ 					 * from USENET)
+ 					 */
  					if (comtype == NOTFOUND)
  					{
  						char *errstr;
***************
*** 111,116
  
  					if (comtype == NOTFOUND)
  					{
  						pos = hashdata(cmdhash);
  						if (pos == 1)
  							failed(*com, notfound);

--- 127,134 -----
  					 */
  					if (comtype == NOTFOUND)
  					{
+ 						char *errstr;
+ 
  						pos = hashdata(cmdhash);
  						if (pos == 1)
  							errstr = notfound;
***************
*** 113,119
  					{
  						pos = hashdata(cmdhash);
  						if (pos == 1)
! 							failed(*com, notfound);
  						else if (pos == 2)
  							failed(*com, badexec);
  						else

--- 131,137 -----
  
  						pos = hashdata(cmdhash);
  						if (pos == 1)
! 							errstr = notfound;
  						else if (pos == 2)
  							errstr = badexec;
  						else
***************
*** 115,121
  						if (pos == 1)
  							failed(*com, notfound);
  						else if (pos == 2)
! 							failed(*com, badexec);
  						else
  							failed(*com, badperm);
  						break;

--- 133,139 -----
  						if (pos == 1)
  							errstr = notfound;
  						else if (pos == 2)
! 							errstr = badexec;
  						else
  							errstr = badperm;
  						prp();
***************
*** 117,123
  						else if (pos == 2)
  							failed(*com, badexec);
  						else
! 							failed(*com, badperm);
  						break;
  					}
  

--- 135,147 -----
  						else if (pos == 2)
  							errstr = badexec;
  						else
! 							errstr = badperm;
! 						prp();
! 						prs_cntl(*com);
! 						prs (colon);
! 						prs (errstr);
! 						newline();
! 						exitval = 1;
  						break;
  					}
  
***************
*** 193,198
  							if (j_finish(FALSE))
  								break;
  #endif
  							flags |= forked;	/* force exit */	
  #if BRL && pdp11
  							if (loginsh)

--- 217,224 -----
  							if (j_finish(FALSE))
  								break;
  #endif
+ 							histsave (histfnod.namval);
+ 							/* save before setting flag */
  							flags |= forked;	/* force exit */	
  #if BRL && pdp11
  							if (loginsh)
***************
*** 289,294
  #ifdef RES	/* Research includes login as part of the shell */	
  
  						case SYSLOGIN:
  							flags |= forked;	/* DAG -- bug fix (force bad exec to terminate shell) */
  							oldsigs();
  							execa(com, -1);

--- 315,321 -----
  #ifdef RES	/* Research includes login as part of the shell */	
  
  						case SYSLOGIN:
+ 							histsave (histfnod.namval);
  							flags |= forked;	/* DAG -- bug fix (force bad exec to terminate shell) */
  							oldsigs();
  							execa(com, -1);
***************
*** 298,303
  #ifndef	BRL
  						case SYSLOGIN:	
  #endif
  							flags |= forked;	/* DAG -- bug fix (force bad exec to terminate shell) */
  							oldsigs();	
  							execa(com, -1);

--- 325,331 -----
  #ifndef	BRL
  						case SYSLOGIN:	
  #endif
+ 							histsave (histfnod.namval);
  							flags |= forked;	/* DAG -- bug fix (force bad exec to terminate shell) */
  							oldsigs();	
  							execa(com, -1);
***************
*** 309,314
  								failed(com[0], restricted);	
  							else	
  							{	
  								flags |= forked;	/* force bad exec to terminate shell */	
  								oldsigs();	
  								execa(com, -1);

--- 337,343 -----
  								failed(com[0], restricted);	
  							else	
  							{	
+ 								histsave (histfnod.namval);
  								flags |= forked;	/* force bad exec to terminate shell */	
  								oldsigs();	
  								execa(com, -1);
***************
*** 518,524
  								if (command == 1 || command == 4)	
  								{	
  									prl(i);	
! 									prc_buff('\n');	
  								}	
  								break;	
  							}				

--- 547,553 -----
  								if (command == 1 || command == 4)	
  								{	
  									prl(i);	
! 									prc_buff(NL);	
  								}	
  								break;	
  							}				
***************
*** 669,674
  
  							j_resume(a1, TRUE);
  							break;
  #endif
  
  						default:	

--- 698,714 -----
  
  							j_resume(a1, TRUE);
  							break;
+ 
+ 						case SYSSUSPEND:
+ 							exitval = 1;
+ 							if (getppid() == 1)
+ 								prs (nosusp);
+ 							else
+ 							{
+ 								exitval = 0;
+ 								kill (getpid(), SIGSTOP);
+ 							}
+ 							break;
  #endif
  
  #if pyr
***************
*** 671,676
  							break;
  #endif
  
  						default:	
  							prs_buff("unknown builtin\n");
  						}	

--- 711,754 -----
  							break;
  #endif
  
+ #if pyr
+ 						/*
+ 						 * UCB is Universe 2
+ 						 * ATT is Universe 1
+ 						 * new_univ == 0
+ 						 */
+ 						case SYSUCB:
+ 							new_univ++;
+ 							/* fall thru */
+ 						case SYSATT:
+ 							new_univ++;
+ 							if (argn > 1)
+ 							{
+ 								change_univ = TRUE;
+ 								com++;
+ 								goto doit;
+ 							}
+ 							else
+ 							{
+ 								setuniverse (cur_univ = new_univ);
+ 								univnod.namflg &= ~N_RDONLY;
+ 								assign (& univnod, univ_name[cur_univ - 1]);
+ 								attrib ((& univnod), N_RDONLY);
+ 								break;
+ 							}
+ 						
+ 						case SYSUNIVERSE:
+ 							if (eq(com[1], dashl))
+ 								prs_buff (univ_longname[cur_univ - 1]);
+ 							else
+ 								prs_buff (univ_name[cur_univ - 1]);
+ 							prc_buff (NL);
+ 							break;
+ #endif
+ 
+ 						case SYSHISTORY:
+ 							exitval = history (argn, com);
+ 							break;
  						default:	
  							prs_buff("unknown builtin\n");
  						}	
***************
*** 709,714
  			}
  
  		case TFORK:
  			exitval = 0;
  			if (execflg && (treeflgs & (FAMP | FPOU)) == 0)
  				parent = 0;

--- 787,795 -----
  			}
  
  		case TFORK:
+ #if pyr
+ 		doit:
+ #endif
  			exitval = 0;
  			if (execflg && (treeflgs & (FAMP | FPOU)) == 0)
  				parent = 0;
***************
*** 788,793
  			}
  			else	/* this is the forked branch (child) of execute */
  			{
  #if BRL
  				loginsh = 0;
  #endif

--- 869,884 -----
  			}
  			else	/* this is the forked branch (child) of execute */
  			{
+ #if pyr
+ 				if (change_univ)
+ 				{
+ 					setuniverse (new_univ);
+ 					univnod.namflg &= ~N_RDONLY;
+ 					assign (& univnod, univ_name[cur_univ - 1]);
+ 					attrib ((& univnod), N_RDONLY);
+ 				}
+ #endif
+ 
  #if BRL
  				loginsh = 0;
  #endif
