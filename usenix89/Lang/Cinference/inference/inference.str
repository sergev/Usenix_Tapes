/*
**
**	This is the inference engine for which the rule compiler
**	has the task of compiling the rules into a knowledge base
**	This knowledge base has the following parts:

		hypstack consisting of a stack of integers, each
		of which points to the offset into the rule base
		which is a hypothesis.
		
		rule base consisting of an orderd set of flags and
		pointers, each comprising a single rule statement.
		Each flag identifies the type of rule and the pointer
		points to the specific string within the string buffer
		which accompanied the rule keyword.
		
		the keywords are defined in the rule compiler documentation
		so look there for it.
		
		
**
**
**
*/

/*********************INFERENCE ENGINE STRUCTURE******************/

/*
**   MAIN VERIFICATION DRIVER
**

MAIN(ARGC,ARGV)
{
READ ALL DATA FROM COMPILED RULES INTO INTERNAL BUFFERS
CLEAR THE KNOWN TRUE AND KNOWN FALSE STACKS
WHILE(ALL CONSEQUENT NOT DONE)
	{
	POP A CONSEQUENT OFF OF THE CONSEQUENT STACK (INVERSE ORDER)
	IF((CONSEQUENT IS KNOWN TRUE) OR (CONSEQUENT IS KNOWN FALSE))
		{
		CONTINUE
		}
	VERIFY(CONSEQUENT) 
	IF(CONSEQUENT IS TRUE)
		{
		IF(CONSEQUENT.FLAG == ROUTINE_TRUE)
			{
			IF(CONSEQUENT IS NOT KNOWN TRUE OR 
			     CONSEQUENT IS NOT KNOWN FALSE)
				{
				PRINT RUNNING CONSEQUENT (CONSEQUENT)
				RESULT = RUN ROUTINE (CONSEQUENT)
				TELL USER RESULT OF RUN
				}
			}
		ELSE
			{
			TELL USER THE TRUTH AND OR CONCLUSION
			}
		}
	}
IF(NO CONSEQUENT WAS PROVEN)
	{
	TELL USER "CANNOT PROVE ANYTHING"
	}
}
**
**
*/

/*
**
**	VERIFY A PARTICULAR CONSEQUENT
**

VERIFY(CONSEQUENT)  (RECURSIVE VERIFY OF THE CONSEQUENT)
{
GET ALL ANTECEDENTS FOR CONSEQUENT ONTO STACK
IF(THERE ARE NO ANTECEDENTS FOR THE CONSEQUENT)
	{
	PRINT "BAD CONSEQUENT -- HAS NO ANTECEDENTS"
	RETURN(TRUE)
	}
WHILE(ALL ANTECEDENTS FOR CONSEQUENT NOT PROVED)
	{
	POP ANTECEDENT OFF OF STACK
	IF(ANTECEDENT IS CONSEQUENT)
		{
		IF(CONSEQUENT IS KNOWN FALSE)
			{
			RETURN(FALSE)
			}
		IF(CONSEQUENT IS KNOWN TRUE)
			{
			CONTINUE
			}
		VERIFY(CONSEQUENT)
		IF(CONSEQUENT IS TRUE)
			{
			IF(CONSEQUENT.FLAG == ROUTINE_TRUE)
				{
				PRINT RUNNING CONSEQUENT (CONSEQUENT)
				RESULT = RUN ROUTINE (CONSEQUENT)
				IF (RESULT == FALSE)
					{
					RETURN(FALSE)
					}
				}
			ELSE
				{
				PUT CONSEQUENT ON KNOWN TRUE STACK
				}
			CONTINUE
			}
		ELSE
			{
			PUT CONSEQUENT ON KNOWN FALSE STACK
			RETURN(FALSE)
			}
		}
	ELSE
		{
		IF(ANTECEDENT IS KNOWN TRUE)
			{
			CONTINUE
			}
		IF(ANTECEDENT IS KNOWN FALSE)
			{
			RETURN (FALSE)
			}
		SWITCH(ANTECEDENT.FLAG):
			{
			CASE (STRING_TRUE) :
				RESULT = GET TRUTH FOR STATEMNT (ANTECEDENT)
				IF(RESULT == FALSE)
					{
					RETETURN (FALSE)
					}
				BREAK ;
			CASE (STRING_FALSE) :
				RESULT = GET TRUTH FOR STATEMNT (ANTECEDENT)
				IF(RESULT == TRUE)
					{
					RETURN(FALSE)
					}
				BREAK ;
			CASE (ROUTINE_TRUE) : 
				PRINT "RUNNING ROUTINE --"
				PRINT STRING POINTED TO BY ANTECEDENT.STRING
				RESULT = RUN ROUTINE (ANTECEDENT)
				IF(RESULT == FALSE)
					{
					RETURN (FALSE)
					}
				BREAK ;
			CASE (ROUTINE_FALSE) : 
				PRINT "RUNNING ROUTINE --"
				PRINT STRING POINTED TO BY ANTECEDENT.STRING
				RESULT = RUN ROUTINE(ANTECEDENT)
				IF(TRUE)
					{
					RETURN(FALSE)
					}
				BREAK ;
			DEFAULT:
				'DIS IS SOME PROBLEM MAMA!
			}
		}
	}
RETURN(TRUE)
}

**
**
*/

/*
**
**	ROUTINE FOR GETTING TRUTH OUT OF USER
**	PRINTS STRING AND ASKS FOR WHETHER IT IS TRUE OR FALSE
**

GET TRUTH FOR STATEMNT(ANTECEDENT)
{
PRINT "IS THE FOLLOWING TRUE?"
PRINT STATEMENT AT ANTECEDENT.STRING
GET USER RESPONSE (YES, WHY OR NO)
DO FOREVER
	{
	IF(USER RESPONSE IS YES)
		{
		PLACE ANTECEDENT IN KNOWN TRUE STACK
		RETURN(TRUE)
		}
	IF(USER RESPONSE IS NO)
		{
		PLACE ANTECEDENT IN KNOW FALSE STACK
		RETETURN (FALSE)
		}
	IF(USER RESPONSE IS WHY)
		{
		PRINT OUT CONSEQUENT/ANTECEDENT STACK IN A NICE FORMAT
		}
	}
}
**
**
*/

/*
**
**	ROUTINE TO TEST THE TRUTH OF A ROUTINE
**


RUN ROUTINE (ANTECEDENT)
{
SPAWN THE ROUTINE NAMED IN THE STRING POINTED TO BY ANTECEDENT.STRING
WAIT FOR ROUTINE TO FINISH
GET RESULT OF THE ROUTINE
IF(RESULT OF ROUTINE IS TRUE)
	{
	PLACE ANTECEDENT IN KNOWN TRUE STACK
	RETURN(TRUE)
	}
ELSE
	{
	PLACE ANTECEDENT IN KNOWN FALSE STACK
	RETURN (FALSE)
	}
}

**
**
**
*/


