
#! /bin/sh
# To extract, remove mail header lines and type "sh filename"
echo x - Makefile
sed -e 's/^X//' > Makefile << '!FaR!OuT!'
XDEST=/usr/local/bin
XLFLAGS=
XYFLAGS=
XLDFLAGS=-s
XCFLAGS=-O
XLOADLIBES=-ltrw -lprofile -lglob -ll
X
Xall: index
X
Xindex: indexlex.c index.o
X	$(CC) $(CFLAGS) $(LDFLAGS) -o index index.o $(LOADLIBES)
X
Xindexlex.c: indexlex.l
X
Xindex.o: indexlex.c
X
Xinstall: all
X	install index $(DEST)
X
Xclean:
X	-rm *.o lex.yy.c y.tab.c indexlex.c index
!FaR!OuT!
echo x - index.1
sed -e 's/^X//' > index.1 << '!FaR!OuT!'
X.if t .ds LX L\v'-.22m'a\v'.22m'T\h'-.1667m'\v'.22m'E\h'-.125m'\v'-.22m'X
X.if n .ds LX LaTeX
X.TH INDEX 1 TRW
X.UC
X.SH NAME
Xindex \- index processor for converting LaTeX idx files
X.SH ORIGIN
XTRW
X.SH SYNOPSIS
X.B index [ -l ]
X.B [ -f
X.I alphabetizefile
X.B ] [
X.I file...
X.B ]
X.SH DESCRIPTION
X.I Index
Xconverts 
X.I idx 
Xfiles generated by \*(LX into 
X.I theindex 
Xenvironments that can be processed by \*(LX.
XMultiple files may be given.
XIf the file is not found, the extension
X.I idx
Xis appended and the new file is looked for.
XIndex files will be created with the extension
X.I ind.
XIf no files are given, standard input is read and standard output it written.
XSubitems and subsubitems can be generated by separating index entries
Xwith commas.
XFor example, after running your document
Xthrough \*(LX you may obtain an index file 
X.I sample.idx
Xcontaining entries
Xthat look like
X.RS
X.nf
X\eindexentry{Reagan}{32}
X\eindexentry{Reagan}{54}
X\eindexentry{Reagan,republicans}{54}
X\eindexentry{Carter}{60}
X\eindexentry{Reagan,republicans,conventions}{62}
X.fi
X.RE
XAfter running the index file through
X.I index
Xa file
X.I sample.ind 
Xwill be created that will contain
X.RS
X.nf
X\ebegin{theindex}
X\eitem Carter 60
X\eindexspace 
X\eitem Reagan 32, 54
X  \esubitem republicans 54
X    \esubsubitem conventions 62
X\eend{theindex}
X.fi
X.RE
XThe 
X.I indexspace 
Xleaves a little extra vertical space between the entries that start with
Xa new letter.
XIf the 
X.I -l 
Xoption is given, then a large index letter will precede each entry
Xthat starts with a new letter.
X.PP
X.I Index
Xreads the file
X.I .alphabetize
Xin the home directory if it exists
Xto determine how to alphabetize an
X.I idx
Xfile.
XThis file contains rules for skipping control sequences, characters, etc
Xwhen alphabetizing a file.
XThe format of this file is described in
X.IR index (5).
XIf the 
X.I -f 
Xoption is given, then another alphabetization file can be given.
X.PP
XA dash following an entry indicates the beginning of a range. 
XThe range is ended by the occurence of the next equivalent entry.
XFor example, suppose you had a \*(LX file containing
X.RS
X.nf
X\&...and they fought\eindex{fighting-} and wept...
X.fi
X.RE
Xon page 40 and
X.RS
X.nf
X\&...and were still fighting\eindex{fighting} years later...
X.fi
X.RE 
Xon page 42 with no intervening
X.I \eindex
Xcommands.
XThen after running the 
X.I idx
Xfile through 
X.I index,
Xthe line 
X.RS
X.nf
X\eitem fighting 40--42
X.fi
X.RE 
Xwould be contained in the 
X.I ind 
Xfile.
XWhen ranges are given for subitems and subsubitems, only the last
Xcomma separated entry should have a dash suffix.
XDuplicate page numbers are suppressed.
X.PP
XIf you wish to insert a comma into your index entry, you will need to 
Xhide it from the index processor with braces
Xsince only outer level commas are recognized as item delimeters.
XFor example,
X.RS
X.nf
X\eindex{Reagan{,} Ronald}
X.fi
X.RE
Xgenerates the index entry for
X.I Reagan, Ronald.
X.SH FILES
X.nf
X.ta \w'~/.alphabetize  'u
X~/.alphabetize	Default alphabetization file
X.fi
X.SH AUTHOR
XScott Simpson
X.SH SEE ALSO
Xprofile(3), index(5), profile(5)
X.SH DIAGNOSTICS
XComplains about illegal values in bindings in alphabetization file.
!FaR!OuT!
echo x - index.5
sed -e 's/^X//' > index.5 << '!FaR!OuT!'
X.if t .ds LX L\v'-.22m'a\v'.22m'T\h'-.1667m'\v'.22m'E\h'-.125m'\v'-.22m'X
X.if n .ds LX LaTeX
X.TH INDEX 5 TRW
X.UC
X.SH NAME
Xindex \- format of alphabetization stanza for LaTeX index processor
X.SH ORIGIN
XTRW
X.SH SYNOPSIS
X~/.alphabetize
X.SH DESCRIPTION
XThe \*(LX index processor
X.IR index (1)
Xreads the file
X.I .alphabetize
Xfile in the home directory to determine
Xhow to sort index entries.
XThis file is in 
X.IR profile (5)
Xformat and consists of a stanza containing bindings.
XThese bindings consist of key/value pairs.
XThere may be multiple values for each key.
X.PP
XThe stanza contained in the 
X.I .alphabetize 
Xfile should contain one stanza with the marker 
X.I alphabetize.
XThis stanza may contain three keys: 
X.I skipchars,
X.I mapctrlsequence 
Xand 
X.I mapindexentry.
X.PP
X.I Skipchars
Xis a list of characters to ignore when alphabetizing index entries.
X.PP
X.I Mapctrlsequence
Xis a list of pairs of values.
XThe odd numbered value 
X.I n
X(a control sequence)
Xmaps into the even value
X.I n+1
X(any text).
XThe leading backslash may 
Xbe omitted for the odd control sequence strings.
X.PP
X.I Mapindexentry
Xis a list of index entries to match exactly.
XThe odd numbered value
X.I n
X(an index entry) maps into the even value
X.I n+1
X(any text).
XThe backslashes
Xmay not be omitted here.
X.SH EXAMPLES
XHere is an example stanza to help clarify some ideas.
X.RS
X.nf
X.ta \w'    mapctrlsequence     'u
Xalphabetize
X{
X    skipchars		'{' '}' '$' '\e^' '\e'' '`' '_' '"'
X    mapctrlsequence	"\e\etrwlogo" "TRW" \e
X			"LaTeX" "LaTeX"
X    mapindexentry	"\e\everb|\e\e\e\e|" "\e\e" \e
X			"\e\everb|\e\e\e"|" "\e""
X}
X.fi
X.RE
XWhen alphabetizing the index file, the characters {, }, $, ^, ', `, _,
Xand " will be ignored.
X.IR Profile (5)
Xrequires escaping the ^, ' and \e.
X.PP
XThe control word
X.I \etrwlogo
Xwill be treated as the string
X.I TRW
Xwherever it occurs in an index entry
Xand the control word
X.I \eLaTeX
Xwill be treated as 
X.I LaTeX
Xwherever it occurs in an index entry.
XNote that the leading backslash in the third value (i.e.,
X.IR \eLaTeX )
Xcan be omitted without ill effect.
XNormally, control words and control symbols are removed when alphabetizing.
X.PP
XThe index entries
X.I \everb|\e\e|
Xand
X\fI\everb|\e"|\fR
Xwill be treated as \e and " when alphabetizing, respectively.
X.PP
XHere is one last example illustrating the sorting rules.
XSuppose we have the stanza
X.RS
X.nf
X.ta \w'    mapctrlsequence     'u
Xalphabetize
X{
X    skipchars		'{' '}'
X    mapctrlsequence	"\e\ehello" "salutation"
X    mapindexentry	"{\e\ela de da}" "z"
X}
X.fi
X.RE
Xand we have the
X.I \eindex
Xcommands
X.RS
X.nf
X\eindex{{\ebf Orca!} kills}
X\eindex{say,{\ela de da}}
X\eindex{say,{\ehello} there}
X\eindex{say,mazzard}
X\eindex{{\ela de da} de da}
X\eindex{{\eit Wolfman} Jack}
X.fi
X.RE
Xsprinkled throughout the document.
X\*(LX may generate the following 
X.I idx
Xfile
X.RS
X.nf
X\eindexentry{{\ebf Orca!} kills}{5}
X\eindexentry{say,{\ela de da}}{10}
X\eindexentry{say,{\ehello} there}{15}
X\eindexentry{say,mazzard}{20}
X\eindexentry{{\ela de da} de da}{25}
X\eindexentry{{\eit Wolfman} Jack}{30}
X.fi
X.RE
XAfter running through
X.I index
Xwe obtain the 
X.I ind
Xfile
X.RS
X.nf
X\ebegin{theindex}
X\eitem {\ela de da} de da 25
X\eindexspace
X\eitem {\ebf Orca!} kills 5
X\eindexspace
X\eitem say
X  \esubitem mazzard 20
X  \esubitem {\ehello} there 15
X  \esubitem {\ela de da} 10
X\eindexspace
X\eitem {\eit Wolfman} Jack 30
X\eend{theindex}
X.fi
X.RE
XThe entries are logically sorted using the strings
X.RS
X.nf
Xdedadeda
XOrca!kills
Xsay
X  mazzard
X  salutationthere
X  z
XWolfmanJack
X.fi
X.RE
XNote that the 
X.I mapindexentry
Xmust match everything between the commas and braces while the 
X.I mapctrlsequence
Xmatches control sequences anywhere within the index entry.
X.SH COMMENTS
XThe 
X.I mapindexentry 
Xentries are examined first and must completely match an index entry.
XIf they match, no other alphabetizing substitution takes place.
X.br
XUpper and lower case letters are equivalent when sorting.
XUpper case alphabetics are converted to lower case; consequently,
Xmost non-alphabetic characters precede the alphabetic characters
Xin the ASCII collating sequence.
XThe exception are the characters {, |, } and ~.
X.br
XBlanks are ignored when sorting.
X.br
XAfter control sequences are expanded into their logical sort string,
Xthey are not scanned for
X.I skipchars.
X.SH FILES
X.nf
X.ta \w'~/.alphabetize   'u
X~/.alphabetize	alphabetization file
X.fi
X.SH AUTHOR
XScott Simpson
X.SH SEE ALSO
Xindex(1), profile(3), profile(5), ascii(7)
X.SH BUGS
XThis manual page is confusing.
!FaR!OuT!
echo x - index.y
sed -e 's/^X//' > index.y << '!FaR!OuT!'
X/* Yacc parser for LaTeX index processor */
X%{
X#include <stdio.h>
X#include <local/standard.h>
X#include <local/profile.h>
X#include <ctype.h>
X#include <pwd.h>
X#define TABLEINCREMENT	50		/* Number of additional entries added when expanding a table */
X#define eq(s,t)		(!strcmp((s),(t)))
X#define odd(i)		(((i) % 2) == 1)
X#define ITEMDEPTH	3		/* Number of nestings of \item's, \subitem's, \subsubitem's, etc. */
Xchar *ItemRep[] = { "\\item", "\\subitem", "\\subsubitem", NULL }; /* and their representation */
Xchar	*calloc(), *realloc();
Xenum TokenType	{controlword, controlsymbol, string, integer, comma, obrace, cbrace, whitespace};
Xstruct IndexEntry {
X    char		literal[81];	/* Literal representation of index entry */
X    char		alphabetic[81];	/* Alphabetic representation for sorting of index entry */
X    struct Token	*tokenlist;	/* Doubly linked token list */
X    struct IndexEntry	*subitem;	/* Pointer to subitem table, subsubitem table, etc */
X    int			subitemcount;	/* Number of items in subitem table */
X    int			subitemtabsize;	/* Subitem table size currently allocated */
X    struct PageNoTable	*pagenos;	/* List of page numbers */
X    int			pagetablecount;	/* Number of items in page number table */
X    int			pagetablesize;	/* Size of page number table currently allocated */
X};
Xstruct Token {
X    enum TokenType	type;		/* Token type */
X    char		lexeme[81];	/* Representation of all the token types */
X    struct Token	*prev, *next;
X};
Xstruct PageNoTable {
X    int			number;		/* Page number */
X    Boolean		range;		/* True if this is the beginning of a range */
X};
Xstruct IndexEntry	*IndexTable = NULL;	/* Table of primary index entries */
Xint			IndexTableCount = 0;	/* Count of number of elements used in index table */
Xint			IndexTableSize = 0;	/* Current allocated size of index table */
Xint			ExitStatus = SUCCEED;	/* Guess */
Xint			LineNo = 1;		/* Line number at start of token */
Xint			EndLineNo = 1;		/* Line number at end of token */
XBoolean			Label = FALSE;		/* True if -l option given */
XBoolean			Range;			/* True if this \indexentry is a range */
XPROFILE_STANZA		*SortStanza = NULL;	/* Alphabetize stanza */
Xextern int		optind;			/* From getopt(3) */
Xextern char		*optarg;
Xchar			*Whoami;		/* argv[0] */
Xchar			*Usage = "Usage: %s [-l] [-f alphabetizefile] [file...]\n";
Xchar			*Marker[] = { "alphabetize", NULL };	/* Markers for alphabetize stanza */
Xchar			IdxFileName[81];	/* .idx file name */
Xchar			Literal[81];		/* Literal string of key */
Xchar			Alphabetic[81];		/* Alphabetic string of key */
XFILE			*InputFile;		/* Current input file */
XFILE			*OutputFile;		/* Current output file */
Xstruct Token		*CurKey;		/* Current key we are constructing */
Xstruct IndexEntry	**CurSearchTable;	/* Current table to search for match */
Xstruct IndexEntry	*CurEntry;		/* Current table entry */
Xstruct IndexEntry	*PrevEntry;		/* Previous Entry */
X%}
X%union {
X    char		value[81];
X    struct Token	*t;
X}
X%token <value> CONTROLSEQUENCE INTEGER WHITESPACE STRING INDEXENTRY
X%type <t> noncommaelement anyelement anyelements
X%%
Xindexfile :
X    optwhitespace
X    indexentries
X	{
X	    sort(IndexTable, IndexTableCount);
X	    fprintf(OutputFile, "\\begin{theindex}\n");
X	    if (Label) {
X		fprintf(OutputFile, "\\newcommand{\\largeletter}[1]{{\\huge\\hspace{-.5in}\\parbox[t]{.5in}{\\makebox[.35in][r]");
X		fprintf(OutputFile, "{\\uppercase{#1}}}\\vspace{-1.5ex}}}\n");
X	    }
X	    printindexentries(IndexTable, IndexTableCount, 1);
X	    fprintf(OutputFile, "\\end{theindex}\n");
X	}
X    ;
X
Xindexentries :
X    indexentries
X    indexentry
X    |
X    indexentry
X    ;
X
Xindexentry :
X    INDEXENTRY
X	{
X	    CurSearchTable = &IndexTable, PrevEntry = NULL;
X	    CurKey = NULL;
X	    Range = FALSE;
X	}
X    optwhitespace
X    '{'
X    keys
X    '}'
X    optwhitespace
X    '{'
X    optwhitespace
X    INTEGER
X	{
X	    struct PageNoTable	*p;
X
X	    if (!(p = findpage(CurEntry->pagenos, CurEntry->pagetablecount, atoi($10)))) {
X		if (CurEntry->pagetablecount >= CurEntry->pagetablesize) {
X		    if (!(CurEntry->pagenos = (struct PageNoTable *)reallocate(CurEntry->pagenos, CurEntry->pagetablesize,
X		    TABLEINCREMENT, sizeof(struct PageNoTable)))) {
X			yyerror("memory allocation failure");
X			exit(FAIL);
X		    }
X		    CurEntry->pagetablesize += TABLEINCREMENT;
X		}
X		CurEntry->pagenos[CurEntry->pagetablecount].number = atoi($10);
X		CurEntry->pagenos[CurEntry->pagetablecount].range = Range;
X		CurEntry->pagetablecount++;
X	    } else
X		p->range = Range;
X	}
X    optwhitespace
X    '}'
X    optwhitespace
X    ;
X
Xkeys :
X    multiplekeys
X    key
X    {
X	struct Token	*t;
X
X	for (t = CurKey; t->next; t = t->next)
X	    ;
X	if (t->type == string)
X	    if (t->lexeme[strlen(t->lexeme) - 1] == '-') {
X		t->lexeme[strlen(t->lexeme) - 1] = '\0';
X		Range = TRUE;
X	    }
X	goto installkey;
X    }
X    ;
X
Xmultiplekeys :
X    multiplekeys
X    key
X    ','
X	{
X	    struct Token	*t;
X
Xinstallkey: strcpy(Literal, literalstring(CurKey));
X	    strcpy(Alphabetic, alphabetizestring(CurKey, SortStanza));
X	    if (!*CurSearchTable) {
X		if (!(*CurSearchTable = (struct IndexEntry *)reallocate(*CurSearchTable, 0, TABLEINCREMENT,
X		sizeof(struct IndexEntry)))) {
X		    yyerror("memory allocation failure");
X		    exit(FAIL);
X		}
X		if (!PrevEntry)
X		    IndexTableSize = TABLEINCREMENT;
X		else
X		    PrevEntry->subitemtabsize = TABLEINCREMENT;
X	    }
X	    if (!(CurEntry = findentry(*CurSearchTable, PrevEntry ? PrevEntry->subitemcount : IndexTableCount, Literal))) {
X		if (!PrevEntry) {
X		    if (IndexTableCount >= IndexTableSize) {
X			if (!(*CurSearchTable = (struct IndexEntry *)reallocate(*CurSearchTable, IndexTableSize, TABLEINCREMENT,
X			sizeof(struct IndexEntry)))) {
X			    yyerror("memory allocation failure");
X			    exit(FAIL);
X			}
X			IndexTableSize += TABLEINCREMENT;
X		    }
X		    CurEntry = (*CurSearchTable + IndexTableCount);
X		    IndexTableCount++;
X		} else {
X		    if (PrevEntry->subitemcount >= PrevEntry->subitemtabsize) {
X			if (!(*CurSearchTable = (struct IndexEntry *)reallocate(*CurSearchTable, PrevEntry->subitemtabsize,
X			TABLEINCREMENT, sizeof(struct IndexEntry)))) {
X			    yyerror("memory allocation failure");
X			    exit(FAIL);
X			}
X			PrevEntry->subitemtabsize += TABLEINCREMENT;
X		    }
X		    CurEntry = (*CurSearchTable + PrevEntry->subitemcount);
X		    PrevEntry->subitemcount++;
X		}
X		strcpy(CurEntry->literal, Literal);
X		strcpy(CurEntry->alphabetic, Alphabetic);
X		CurKey->prev = CurEntry->tokenlist, CurEntry->tokenlist = CurKey;
X		CurEntry->subitem = NULL, CurEntry->subitemcount = CurEntry->subitemtabsize = 0;
X		CurEntry->pagenos = NULL, CurEntry->pagetablecount = CurEntry->pagetablesize = 0;
X	    }
X	    CurSearchTable = &CurEntry->subitem;
X	    PrevEntry = CurEntry;
X	    CurKey = NULL;
X	}
X    |
X    /* epsilon */
X    ;
X
Xkey :
X    key
X    noncommaelement
X    |
X    noncommaelement
X    ;
X
Xnoncommaelement :
X    CONTROLSEQUENCE
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = isalpha($1[1]) ? controlword : controlsymbol;
X	    strcpy($$->lexeme, $1);
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    |
X    INTEGER
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = integer;
X	    strcpy($$->lexeme, $1);
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    |
X    WHITESPACE
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = whitespace;
X	    strcpy($$->lexeme, $1);
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    |
X    STRING
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = string;
X	    strcpy($$->lexeme, $1);
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    |
X    '{'
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = obrace;
X	    strcpy($$->lexeme, "{");
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	}
X    anyelements
X    '}'
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = cbrace;
X	    strcpy($$->lexeme, "}");
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    ;
X
Xanyelements :
X    anyelements
X    anyelement
X	{
X	    $$ = $2;
X	}
X    |
X    anyelement		/* Default action is $$ = $1 */
X    ;
X
Xanyelement :
X    noncommaelement 	/* Default action is $$ = $1 */
X    |
X    ','
X	{
X	    if (!($$ = (struct Token *)calloc(1, sizeof(struct Token)))) {
X		yyerror("memory allocation failure");
X		exit(FAIL);
X	    }
X	    $$->type = comma;
X	    strcpy($$->lexeme, ",");
X	    $$->next = NULL;
X	    if (!CurKey)
X		$$->prev = CurKey, CurKey = $$;
X	    else {
X		struct Token *p;
X		
X		for (p = CurKey; p->next; p = p->next)
X		    ;
X		p->next = $$, $$->prev = p;
X	    }
X	    $$ = CurKey;
X	}
X    ;
X
Xoptwhitespace :
X    WHITESPACE
X    |
X    ;
X    
X%%
X#include "indexlex.c"
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X    int			c;
X    Boolean		sortfilegiven = FALSE;
X    char		sortfilename[81];
X    char		indfilename[81];
X    struct passwd	*pwentry;
X    FILE		*stanzafileptr;
X
X    Whoami = argv[0];
X    pwentry = getpwuid(geteuid());
X    sprintf(sortfilename, "%s/.alphabetize", pwentry->pw_dir);
X    while ((c = getopt(argc, argv, "f:l")) != EOF)
X	switch (c) {
X	case 'l':
X	    Label = TRUE;
X	    break;
X	case 'f':
X	    strcpy(sortfilename, optarg);
X	    sortfilegiven = TRUE;
X	    break;
X	case '?':
X	    fprintf(stderr, Usage, Whoami);
X	    exit(FAIL);
X	}
X    stanzafileptr = fopen(sortfilename, "r");
X    if (sortfilegiven && !stanzafileptr) {
X	fprintf(stderr, "%s: cannot open alphabetization file %s\n", Whoami, sortfilename);
X	exit(FAIL);
X    }
X    if (stanzafileptr) {
X	if (!(SortStanza = profile_read_profile(stanzafileptr))) {
X	    fprintf(stderr, "%s: file %s is not in stanza format\n", Whoami, sortfilename);
X	    fclose(stanzafileptr);
X	    exit(FAIL);
X	}
X	if (!(SortStanza = profile_has_stanza(SortStanza, Marker))) {
X	    fprintf(stderr, "%s: file %s does not contain a stanza with marker %s\n", Whoami, sortfilename, Marker[0]);
X	    fclose(stanzafileptr);
X	    exit(FAIL);
X	}
X	fclose(stanzafileptr);
X    }
X    checkstanza(SortStanza);
X    if (optind == argc) {
X	InputFile = stdin;
X	OutputFile = stdout;
X	strcpy(IdxFileName, "stdin");
X    }
X    do {
X	if (InputFile != stdin) {
X	    strcpy(IdxFileName, argv[optind]);
X	    if (!(InputFile = fopen(argv[optind], "r"))) {
X		strcpy(IdxFileName, argv[optind]);
X		strcat(IdxFileName, ".idx");
X		if (!(InputFile = fopen(IdxFileName, "r"))) {
X		    fprintf(stderr, "%s: cannot open %s\n", Whoami, IdxFileName);
X		    ExitStatus = FAIL;
X		    continue;
X		}
X	    }
X	    if (strlen(IdxFileName) >= 4 && eq(&IdxFileName[strlen(IdxFileName)-4], ".idx"))
X		sprintf(indfilename, "%.*s.ind", strlen(IdxFileName)-4, IdxFileName);
X	    else
X		sprintf(indfilename, "%s.ind", IdxFileName);
X	    if (!(OutputFile = fopen(indfilename, "w"))) {
X		fprintf(stderr, "%s: cannot open output file %s\n", Whoami, indfilename);
X		fclose(InputFile);
X		ExitStatus = FAIL;
X		continue;
X	    }
X	} else
X	    strcpy(IdxFileName, "stdin");
X	if (yyparse() != 0)
X	    ExitStatus = FAIL;
X	fclose(InputFile);
X	fclose(OutputFile);
X	freetables(IndexTable, IndexTableCount);
X	IndexTable = NULL, IndexTableCount = IndexTableSize = 0, LineNo = EndLineNo = 1;
X	yysptr = yysbuf;	/* Resets Lex lookahead buffer */
X    } while (++optind < argc);
X    exit(ExitStatus);
X}
X
Xyyerror(s)
Xchar *s;
X{
X    fprintf(stderr, "\"%s\", line %d: %s\n", IdxFileName, LineNo, s);
X}
X
X/* Allocates additional space for tables. Returns NULL if memory allocation failure or inconsistent parameters */
Xchar *reallocate(table, current, increment, elementsize)
Xchar	*table;			/* pointer to current table */
Xint	current;		/* current size of table */
Xint	increment;		/* additional entries to add */
Xint	elementsize;		/* size of an element in the table */
X{
X    char	*calloc(), *realloc();
X    char	*p;
X
X    if ((!table && current > 0) || current < 0 || increment < 0 || elementsize < 0)
X	return NULL;
X    if (increment == 0 || elementsize == 0)
X	return table;
X    if (current == 0)
X	if (!(p = calloc(increment, elementsize)))
X	    return NULL;
X	else
X	    return p;
X    else
X	if (!(p = realloc(table, (current + increment) * elementsize)))
X	    return NULL;
X	else
X	    return p;
X}
X
X/* Frees the space allocated for all the tables */
Xfreetables(index, noentries)
Xstruct IndexEntry	*index;		/* index table */
Xint			noentries;	/* number of entries in table */
X{
X    struct Token	*t, *ttemp;
X    int			i;
X
X    if (!index || noentries == 0)
X	return;
X    for (i = 0; i < noentries; i++)
X    if (index[i].subitem)
X	freetables(index[i].subitem, index[i].subitemcount);	/* recursion! */
X    for (t = index[i].tokenlist; t; t = ttemp)
X	ttemp = t->next, free(t);
X    if (index[i].pagenos)
X	free(index[i].pagenos);
X    free(index);
X}
X
X/* Checks alphabetize stanza for validity */
Xcheckstanza(ps)
XPROFILE_STANZA	*ps;
X{
X    PROFILE_BINDING	*pb;
X    PROFILE_VALUE	*pv;
X    int			count;
X
X    if (!ps)
X	return;
X    if (pb = profile_has_binding(ps, "skipchars"))
X	for (pv = pb->value; pv; pv = pv->next)
X	    if (pv->class != PROFILE_CHARACTER)
X		switch (pv->class) {
X		case PROFILE_INTEGER:
X		    fprintf(stderr, "%s: illegal integer constant %d in skipchars binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_HEX:
X		    fprintf(stderr, "%s: illegal hex constant 0x%x in skipchars binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_OCTAL:
X		    fprintf(stderr, "%s: illegal octal constant 0%o in skipchars binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_FLOAT:
X		    fprintf(stderr, "%s: illegal float constant %f in skipchars binding\n", Whoami, pv->value.f);
X		    break;
X		case PROFILE_STRING:
X		case PROFILE_OTHER:
X		    fprintf(stderr, "%s: illegal string constant %s in skipchars binding\n", Whoami, pv->value.s);
X		    break;
X		}
X    if (pb = profile_has_binding(ps, "mapctrlsequence")) {
X	for (count = 0, pv = pb->value; pv; pv = pv->next, count++)
X	    if (pv->class != PROFILE_OTHER || pv->class != PROFILE_STRING)
X		switch (pv->class) {
X		case PROFILE_INTEGER:
X		    fprintf(stderr, "%s: illegal integer constant %d in mapctrlsequence binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_HEX:
X		    fprintf(stderr, "%s: illegal hex constant 0x%x in mapctrlsequence binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_OCTAL:
X		    fprintf(stderr, "%s: illegal octal constant 0%o in mapctrlsequence binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_FLOAT:
X		    fprintf(stderr, "%s: illegal float constant %f in mapctrlsequence binding\n", Whoami, pv->value.f);
X		    break;
X		case PROFILE_CHARACTER:
X		    fprintf(stderr, "%s: illegal character constant %c in mapctrlsequence binding\n", Whoami, pv->value.c);
X		    break;
X		}
X	if (odd(count))
X	    fprintf(stderr, "%s: must have an even number of string values for mapctrlsequence binding\n", Whoami);
X    }
X    if (pb = profile_has_binding(ps, "mapindexentry")) {
X	for (count = 0, pv = pb->value; pv; pv = pv->next, count++)
X	    if (pv->class != PROFILE_OTHER || pv->class != PROFILE_STRING)
X		switch (pv->class) {
X		case PROFILE_INTEGER:
X		    fprintf(stderr, "%s: illegal integer constant %d in mapindexentry binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_HEX:
X		    fprintf(stderr, "%s: illegal hex constant 0x%x in mapindexentry binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_OCTAL:
X		    fprintf(stderr, "%s: illegal octal constant 0%o in mapindexentry binding\n", Whoami, pv->value.i);
X		    break;
X		case PROFILE_FLOAT:
X		    fprintf(stderr, "%s: illegal float constant %f in mapindexentry binding\n", Whoami, pv->value.f);
X		    break;
X		case PROFILE_CHARACTER:
X		    fprintf(stderr, "%s: illegal character constant %c in mapindexentry binding\n", Whoami, pv->value.c);
X		    break;
X		}
X	if (odd(count))
X	    fprintf(stderr, "%s: must have an even number of string values for mapindexentry binding\n", Whoami);
X    }
X}
X
X/* Returns the literal string of a token list */
Xchar	*literalstring(t)
Xstruct Token	*t;
X{
X    static char	literal[81];
X
X    strcpy(literal, "");
X    for (t = CurKey; t; t = t->next)
X	    strcat(literal, t->lexeme);
X    return literal;
X}
X
X/* Returns alphabetization string for a token list and a stanza */
Xchar	*alphabetizestring(tokenlist, stanza)
Xstruct Token	*tokenlist;
XPROFILE_STANZA	*stanza;
X{
X    char		litstring[81];
X    char		ctrlstring[21];
X    char		c[2];
X    static char		alphastring[81];
X    int			i;
X    Boolean		add;
X    struct Token	*t;
X    PROFILE_BINDING	*pb, *pbchars, *pbctrlsequence;
X    PROFILE_VALUE	*pv;
X    
X    if (!tokenlist)
X	return NULL;
X    strcpy(alphastring, "");
X    if (!stanza) {
X	for (t = tokenlist; t; t = t->next)
X	    switch (t->type) {
X	    case string:
X	    case integer:
X	    case comma:
X	    case obrace:
X	    case cbrace:
X		strcat(alphastring, t->lexeme);
X		break;
X	    }
X	return alphastring;
X    } else {
X	if (pb = profile_has_binding(stanza, "mapindexentry")) {
X	    strcpy(litstring, literalstring(tokenlist));
X	    for (pv = pb->value; pv && pv->next; pv = pv->next, pv = pv->next)
X		if ((pv->class == PROFILE_STRING || pv->class == PROFILE_OTHER) && (pv->next->class == PROFILE_STRING ||
X		pv->next->class == PROFILE_OTHER))
X		    if (eq(litstring, pv->value.s)) {
X			strcpy(alphastring, pv->next->value.s);
X			return alphastring;
X		    }
X	} /* end if there is a mapindexentry binding */
X	pbchars = profile_has_binding(stanza, "skipchars");
X	pbctrlsequence = profile_has_binding(stanza, "mapctrlsequence");
X	c[1] = '\0';
X	for (t = tokenlist; t; t = t->next)
X	    switch (t->type) {
X	    case controlword:
X	    case controlsymbol:
X		if (pbctrlsequence)
X		    for (pv = pbctrlsequence->value; pv && pv->next; pv = pv->next, pv = pv->next)
X			if ((pv->class == PROFILE_STRING || pv->class == PROFILE_OTHER) && (pv->next->class == PROFILE_STRING ||
X			pv->next->class == PROFILE_OTHER))
X			    if (strlen(pv->value.s) > 0) {
X				if (pv->value.s[0] != '\\')
X				    sprintf(ctrlstring, "\\%s", pv->value.s);
X				else
X				    strcpy(ctrlstring, pv->value.s);
X				if (eq(ctrlstring, t->lexeme))
X				    strcat(alphastring, pv->next->value.s);
X			    }
X		break;
X	    case string:
X	    case integer:
X		for (i = 0; t->lexeme[i]; i++)
X		    if (pbchars) {
X			for (add = TRUE, pv = pbchars->value; pv && add; pv = pv->next)
X			    if (pv->class == PROFILE_CHARACTER)
X				if (pv->value.c == t->lexeme[i])
X				    add = FALSE;
X			if (add) {
X			    c[0] = t->lexeme[i];
X			    strcat(alphastring, c);
X			}
X		    } else {
X			c[0] = t->lexeme[i];
X			strcat(alphastring, c);
X		    }
X		break;
X	    case comma:
X		c[0] = ',';
X		goto insert;
X	    case obrace:
X		c[0] = '{';
X		goto insert;
X	    case cbrace:
X		c[0] = '}';
Xinsert:		if (pbchars) {
X		    for (add = TRUE, pv = pbchars->value; pv && add; pv = pv->next)
X			if (pv->class == PROFILE_CHARACTER)
X			    if (pv->value.c == c[0])
X				add = FALSE;
X		    if (add)
X			strcat(alphastring, c);
X		} else
X		    strcat(alphastring, c);
X		break;
X	    }
X	return alphastring;
X    }
X}
X
X/* Finds an entry in a table. Returns NULL if not found. */
Xstruct IndexEntry	*findentry(table, noentries, string)
Xstruct IndexEntry 	*table;
Xint			noentries;
Xchar			*string;
X{
X    int	i;
X
X    if (noentries <= 0)
X	return NULL;
X    for (i = 0; i < noentries; i++)
X	if (eq(string, table[i].literal))
X	    return &table[i];
X    return NULL;
X}
X
X/* Returns pointer to page number if found, NULL otherwise */
Xstruct PageNoTable	*findpage(pagearray, elements, pageno)
Xstruct PageNoTable	*pagearray;
Xint			elements;
Xint			pageno;
X{
X    int	i;
X
X    if (!pagearray)
X	return NULL;
X    for (i = 0; i < elements; i++)
X	if (pagearray[i].number == pageno)
X	    return &pagearray[i];
X    return NULL;
X}
X
X/* Sorts the entries in the structures */
Xsort(base, numberelements)
Xstruct IndexEntry	*base;
Xint			numberelements;
X{
X    int	i;
X    int numericcompare();
X    int alphacompare();
X
X    for (i = 0; i < numberelements; i++) {
X	if (base[i].pagenos)
X	    qsort(base[i].pagenos, base[i].pagetablecount, sizeof(struct PageNoTable), numericcompare);
X	if (base[i].subitem)
X	    sort(base[i].subitem, base[i].subitemcount);	/* recursion! */
X    }
X    qsort(base, numberelements, sizeof(struct IndexEntry), alphacompare);
X}
X
X/* Prints out the index entries */
Xprintindexentries(base, noelements, level)
Xstruct IndexEntry	*base;
Xint			noelements;
Xint			level;
X{
X    int		i, j;
X    Boolean	prevoutput = FALSE;
X    Boolean	prevrange = FALSE;
X    char	c;
X    char	letter = '\0';
X
X    if (level > ITEMDEPTH)
X	return;
X    for (i = 0; i < noelements; i++) {
X	if (level == 1)
X	    if (strlen(base[i].alphabetic) > 0)
X		if (isalpha(base[i].alphabetic[0])) {
X		    if (isupper(c = base[i].alphabetic[0])) 
X			c = tolower(c);
X		    if (!letter) {
X			if (Label) {
X			    fprintf(OutputFile, "\\indexspace\n");
X			    fprintf(OutputFile, "\\largeletter{%c}\n", c);
X			} else if (prevoutput)
X			    fprintf(OutputFile, "\\indexspace\n");
X		    } else if (letter != c) {
X			fprintf(OutputFile, "\\indexspace\n");
X			if (Label)
X			    fprintf(OutputFile, "\\largeletter{%c}\n", c);
X		    }
X		    letter = c;
X		}
X	prevoutput = TRUE;
X	for (j = 1; j < level; j++)
X	    fprintf(OutputFile, "  ");
X	fprintf(OutputFile, "%s %s ", ItemRep[level - 1], base[i].literal);
X	if (base[i].pagenos) {
X	    for (j = 0; j < base[i].pagetablecount; j++) {
X		if (j == base[i].pagetablecount - 1)
X		    fprintf(OutputFile, "%d\n", base[i].pagenos[j].number);
X		else
X		    if (base[i].pagenos[j].range) {
X			if (!prevrange)
X			    fprintf(OutputFile, "%d--", base[i].pagenos[j].number);
X		    } else
X			fprintf(OutputFile, "%d, ", base[i].pagenos[j].number);
X		prevrange = base[i].pagenos[j].range;
X	    }
X	    if (prevrange)
X		fprintf(stderr, "%s: file %s, %s %s ends with a range\n", Whoami, IdxFileName, ItemRep[level - 1],
X		base[i].literal);
X	} else
X	    fprintf(OutputFile, "\n");
X	if (base[i].subitem)
X	    printindexentries(base[i].subitem, base[i].subitemcount, level + 1);	/* recursion! */
X    }
X}
X
Xint	numericcompare(e1, e2)
Xstruct PageNoTable	*e1, *e2;
X{
X    if (e1->number == e2->number)
X	return 0;
X    else if (e1->number < e2->number)
X	return -1;
X    else
X	return 1;
X}
X
Xint alphacompare(e1, e2)
Xstruct IndexEntry	*e1, *e2;
X{
X    char	s1[81], s2[81];
X
X    strcpy(s1, e1->alphabetic), strcpy(s2, e2->alphabetic);
X    return(strcmp(string_downshift(s1), string_downshift(s2)));
X}
!FaR!OuT!
echo x - indexlex.l
sed -e 's/^X//' > indexlex.l << '!FaR!OuT!'
X/* Lex Lexical Analyzer for LaTeX index processor */
X%{
X#undef input
X#define input()	(((yytchar=yysptr>yysbuf?U(*--yysptr):getc(InputFile)) \
X    ==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X%}
Xletter		[A-Za-z]
Xinteger		-?[0-9]{1,9}
Xwhitespace	[ \t\n]
X%%
X\\indexentry		{
X			    LineNo = EndLineNo;
X			    return(INDEXENTRY);
X			}
X\\{letter}+		{	/* Control word */
X			    LineNo = EndLineNo;
X			    strcpy(yylval.value, yytext);
X			    return(CONTROLSEQUENCE);
X			}
X\\[^{letter}]		{	/* Control symbol */
X			    LineNo = EndLineNo;
X			    strcpy(yylval.value, yytext);
X			    return(CONTROLSEQUENCE);
X			}
X\%.*\n			LineNo = EndLineNo++;	/* Comment. Don't pass to parser */
X{integer}		{
X			    LineNo = EndLineNo;
X			    strcpy(yylval.value, yytext);
X			    return(INTEGER);
X			}
X\{ |
X\} |
X\,			{
X			    LineNo = EndLineNo;
X			    return(yytext[0]);
X			}
X{whitespace}+		{
X			    char	*p;	/* Utility variable */
X
X			    LineNo = EndLineNo;
X			    for (p = yytext; *p; p++)
X				if (*p == '\n')
X				    EndLineNo++;
X			    strcpy(yylval.value, yytext);
X			    return(WHITESPACE);
X			}
X[^\\\{\}\%\, \t\n0-9]+	{
X			    LineNo = EndLineNo;
X			    strcpy(yylval.value, yytext);
X			    return(STRING);
X			}
X%%
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/glob.h
sed -e 's/^X//' > local.include/glob.h << '!FaR!OuT!'
X/* @(#)glob.h	1.1 (TRW) 1/14/86 */
X#define GLOB_MAX_PATTERN	1024
X#define GLOB_OK			0
X#define GLOB_PATTERN_TOO_BIG	-1
X#define GLOB_PATTERN_EMPTY	-2
X#define GLOB_BRACKET_MISSING	-3
X#define GLOB_RANGE_INVERTED	-4
X#define GLOB_SET_TOO_BIG	-5
X#define GLOB_EXECUTION_ERROR	-6
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/profile.h
sed -e 's/^X//' > local.include/profile.h << '!FaR!OuT!'
X/* @(#)profile.h	1.1 (TRW) 1/14/86 */
Xtypedef struct PROFILE_VALUE {
X	char class;
X	union {
X		long int i;
X		double f;
X		char c;
X		char *s;
X	} value;
X	struct PROFILE_VALUE *previous;
X	struct PROFILE_VALUE *next;
X} PROFILE_VALUE;
X
Xtypedef struct PROFILE_BINDING {
X	char *name;
X	PROFILE_VALUE *value;
X	struct PROFILE_BINDING *previous;
X	struct PROFILE_BINDING *next;
X} PROFILE_BINDING;
X
Xtypedef struct PROFILE_MARKER {
X	char *text;
X	struct PROFILE_MARKER *previous;
X	struct PROFILE_MARKER *next;
X} PROFILE_MARKER;
X
Xtypedef struct PROFILE_STANZA {
X	PROFILE_MARKER *marker;
X	PROFILE_BINDING *binding;
X	struct PROFILE_STANZA *previous;
X	struct PROFILE_STANZA *next;
X} PROFILE_STANZA;
X
X/* classes */
X#define PROFILE_INTEGER 01
X#define PROFILE_FLOAT 02
X#define PROFILE_STRING 03
X#define PROFILE_CHARACTER 04
X#define PROFILE_OTHER 05
X#define PROFILE_OCTAL 06
X#define PROFILE_HEX 07
X
X/* no single lexical element may exceed this size in characters */
X#define PROFILE_MAX_TEXT 255
X
XPROFILE_STANZA *profile_read_stanza();
XPROFILE_STANZA *profile_read_profile();
XPROFILE_MARKER *profile_has_marker();
XPROFILE_STANZA *profile_has_stanza();
XPROFILE_BINDING *profile_has_binding();
XPROFILE_STANZA *profile_stanza_space();
XPROFILE_MARKER *profile_marker_space();
XPROFILE_BINDING *profile_binding_space();
XPROFILE_VALUE *profile_value_space();
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/standard.h
sed -e 's/^X//' > local.include/standard.h << '!FaR!OuT!'
X/* @(#)standard.h	1.1 (TRW) 6/13/84 */
X#include <local/standenviron.h>
X#include <local/standtype.h>
X#include <local/standconst.h>
X#include <local/standmacro.h>
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/standconst.h
sed -e 's/^X//' > local.include/standconst.h << '!FaR!OuT!'
X/* @(#)standconst.h	1.1 (TRW) 6/13/84 */
X/* Standard constants. */
X
X/*
X * These are the only values boolean variables may be set to,
X * or that boolean functions may return.
X */
X#define	TRUE 1
X#define	FALSE 0
X
X/*
X * Program exit status.
X * These two codes are intended to be used as arguments to the
X * exit(2) system call.  Obviously, more failure codes may be
X * defined but for simple programs that need indicate only
X * success or failure these will suffice.
X */
X#define	SUCCEED 0	/* successful program execution	*/
X#define	FAIL 1		/* some error in running program */
X
X/* All bits on or off. */
X#define	ON ~(long)0	/* all bits set	*/
X#define	OFF (long)0	/* all bits off	*/
X
X/* UNIX file descriptor numbers for standard input, output, and error. */
X#define	STANDARD_IN 0
X#define	STANDARD_OUT 1
X#define	STANDARD_ERROR 2
X
X
X/*
X * Extreme values.
X * These constants are the largest and smallest values
X * that variables of the indicated type may hold.
X */
X#if defined(vax) || defined(pyr) || defined(pyramid)
X#   define MAX_TINY TINY(0x7f)
X#   define MIN_TINY TINY(0x80)
X
X#   define MAX_UNSIGNED_TINY UNSIGNED_TINY(0xff)
X#   define MIN_UNSIGNED_TINY 0
X
X#   define MAX_SHORT ((short)0x7fff)
X#   define MIN_SHORT ((short)0x8000)
X
X#   define MAX_UNSIGNED_SHORT 0xffff
X#   define MIN_UNSIGNED_SHORT 0
X
X#   define MAX_INTEGER 0x7fffffff
X#   define MIN_INTEGER 0x80000000
X
X#   define MAX_UNSIGNED_INTEGER 0xffffffff
X#   define MIN_UNSIGNED_INTEGER 0
X
X#   define MAX_LONG ((long)0x7fffffff)
X#   define MIN_LONG ((long)0x80000000)
X#   define MAX_UNSIGNED_LONG 0xffffffff
X#   define MIN_UNSIGNED_LONG 0
X#   define BITS_PER_BYTE 8
X#endif
X
X/* for pointers */
X#define NIL ((long)0)
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/standenviron.h
sed -e 's/^X//' > local.include/standenviron.h << '!FaR!OuT!'
X/* @(#)standenviron	1.1 (TRW) 6/13/84 */
X/*
X * This file defines the machine/compiler C environment. It defines
X * pre-processor macros that tell what C features are supported.
X *
X * #define HAS_UNSIGNED_SHORT	Implies unsigned shorts are supported
X * #define CHAR_IS_SIGNED	Implies chars are signed
X * #define HAS_UNSIGNED_CHAR	Implies unsigned chars are supported
X * #define HAS_UNSIGNED_LONG	Implies unsigned longs are supported
X * #define BITS_PER_CHAR n	Number of bits in a char
X * #define BITS_PER_INT n	Number of bits in an int
X * #define BITS_PER_LONG n	Number of bits in a long
X * #define BITS_PER_POINTER n	Number of bits in a pointer
X * #define BITS_PER_SHORT n	Number of bits in a short
X * #define HAS_VOID		Implies void function type is supported
X */
X
X#ifndef	STANDARD_ENVIRON	/* prevent multiple inclusions	*/
X
X#if defined(vax) || defined(pyr) || defined(pyramid)
X#   define HAS_UNSIGNED_SHORT
X#   define CHAR_IS_SIGNED
X#   define HAS_UNSIGNED_CHAR
X#   define HAS_UNSIGNED_LONG
X#   define HAS_VOID
X
X#   define BITS_PER_CHAR 8
X#   define BITS_PER_INT 32
X#   define BITS_PER_LONG 32
X#   define BITS_PER_POINTER 32
X#   define BITS_PER_SHORT 16
X#   define STANDARD_ENVIRON
X#endif
X
X#ifdef MC68000
X#   include "MC68000 unimplemented"
X#   define STANDARD_ENVIRON
X#endif MC6800
X
X/* make sure a known processor type was	specified */
X#ifndef	STANDARD_ENVIRON
X#   include "Processor type unknown or unspecified"
X#endif STANDARD_ENVIRON
X
X#endif STANDARD_ENVIRON
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/standmacro.h
sed -e 's/^X//' > local.include/standmacro.h << '!FaR!OuT!'
X/* @(#)standmacro.h	1.1 (TRW) 6/13/84 */
X/* Maximum of two values. */
X#define	MAX(x, y) ((x) > (y) ? (x) : (y))
X
X/* Minimum of two values. */
X#define	MIN(x, y) ((x) < (y) ? (x) : (y))
X
X/* Absolute value. */
X#define	ABS(x) ((x) < 0 ? -(x) : (x))
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/standtype.h
sed -e 's/^X//' > local.include/standtype.h << '!FaR!OuT!'
X/* @(#)standtype.h	1.1 (TRW) 6/13/84 */
X/* Standard machine independent type definitions. */
X
X#ifndef	STANDARD_TYPE	/* prevent multiple inclusions	*/
X#define	STANDARD_TYPE
X
X/*
X * Integers
X *     Tiny/UnsignedTiny	8+ bit integers
X *     Short/UnsignedShort	16+ bit integers
X *     Integer/UnsignedInteger	natural machine integer size
X *     Long/UnsignedLong	32+ bit integers
X *
X * Bits
X *     TinyBits		8+ bits
X *     Bits		16+ bits
X *     LongBits		32+ bits
X *
X * Booleans
X *     TinyBoolean
X *     Boolean
X *
X * Void
X *
X * Storage Classes
X *     Export		Seen in other compilation units
X *     Import		Supplied by another compilation unit
X *     Local		Unseen outside compilation unit
X */
X
X/*
X * Each of the following sections for the integer types defines both
X * a base type and an extraction macro for the value.
X */
X
X/* Not all machines have signed characters so we may have to simulate them. */
X#ifdef CHAR_IS_SIGNED
X    typedef char Tiny;
X#   define TINY(x) (x)
X#else
X    typedef char Tiny;
X#   define TINY(x) (((x) & 0x80) ? (~0x7f | (x)) : (x))
X#endif CHAR_IS_SIGNED
X
X/* Not all compilers support unsigned chars so we may have to simulate them. */
X#ifdef HAS_UNSIGNED_CHAR
X    typedef unsigned char UnsignedTiny;
X#   define UNSIGNED_TINY(x) (x)
X#else
X    typedef char UnsignedTiny;
X#   define UNSIGNED_TINY(x) ((x) & 0xff)
X#endif HAS_UNSIGNED_CHAR
X
X/*
X * All compilers have signed short integers.  This type is included
X * for lexical consistency.
X */
Xtypedef short Short;
X
X/* Not all compilers support unsigned shorts so we may have to simulate them. */
X#ifdef HAS_UNSIGNED_SHORT
X    typedef unsigned short UnsignedShort;
X#   define UNSIGNED_SHORT(x) (x)
X#else
X    typedef short UnsignedShort;
X#   define UNSIGNED_SHORT(x) ((unsigned)((x) & 0xffff))
X#endif
X
X/* These types are solely for lexical consistency. */
Xtypedef int Integer;
Xtypedef	unsigned int UnsignedInteger;
X
Xtypedef long Long;
X
X/* Not all compilers support unsigned longs so we may have to simulate them. */
X#ifdef HAS_UNSIGNED_LONG
X    typedef unsigned long UnsignedLong;
X#   define UNSIGNED_LONG(x) (x)
X#else
X    typedef long UnsignedLong;
X#   define UNSIGNED_LONG(x) ((long)((x) & 0x7fffffff))
X#endif HAS_UNSIGNED_LONG
X
X/* Boolean types take on only the values TRUE or FALSE. */
Xtypedef	char TinyBoolean;
Xtypedef	short Boolean;
X
X/* This type is included for lexical consistency. */
Xtypedef char Character;
X
X/* Bit types are used only for bit set, clear and test operations. */
Xtypedef	char TinyBits;
Xtypedef	short Bits;
Xtypedef	long LongBits;
X
X/* Not all compilers support void functions so we may have to simulate it. */
X#ifdef HAS_VOID
X#   define Void void
X#else
X    typedef int Void;
X#endif
X
X/* Storage classes. */
X#define	Export
X#define Import extern
X#define	Local static
X
X#endif	STANDARD_TYPE
!FaR!OuT!
if [ ! -d local.include ]
then
	mkdir local.include
	echo mkdir local.include
fi
echo x - local.include/universe.h
sed -e 's/^X//' > local.include/universe.h << '!FaR!OuT!'
Xstruct	universe { /* see getunent(3) */
X	char	*un_name;
X	char	*un_universe;
X};
X
Xstruct universe *getunent(), *getunnam();
!FaR!OuT!
exit
