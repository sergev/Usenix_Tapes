diff -rbc titroff/README /distribution/dwb/text/troff.d/README
*** titroff/README	Fri Jul 16 22:27:13 1982
--- /distribution/dwb/text/troff.d/README	Fri Sep  9 18:44:29 1983
***************
*** 1,5
  
! The troff in this directory (known as a.out)
  is a troff that produces machine-independent output.
  It requires a file of descriptive information about
  the particular typesetter you have in mind, and produces

--- 1,5 -----
  
! The troff in this directory
  is a troff that produces machine-independent output.
  It requires a file of descriptive information about
  the particular typesetter you have in mind, and produces
***************
*** 6,13
  output parameterized for that device.
  
  Thus:
! 	a.out -T202 ...
! produces output for the mergenthaler linotron 202.
  (This is the default.)
  
  To make this work, one needs to create a set of

--- 6,13 -----
  output parameterized for that device.
  
  Thus:
! 	troff -Taps ...
! produces output for the Autologic APS-5.
  (This is the default.)
  
  To make this work, one needs to create a set of
***************
*** 15,23
  	/usr/lib/font/devxxx
  where "xxx" is your device name.
  Currently supported devices are
! 	202	mergenthaler 202 using our software
! 	aps	autologic aps5
! 	cat	gsi cat (not really working at present)
  
  The file "DESC" contains information about the
  device itself and the character set.  The file dev202/DESC

--- 15,21 -----
  	/usr/lib/font/devxxx
  where "xxx" is your device name.
  Currently supported devices are
! 	aps	Autologic APS-5
  
  The file "DESC" contains information about the
  device itself and the character set.  The file devaps/DESC
***************
*** 20,26
  	cat	gsi cat (not really working at present)
  
  The file "DESC" contains information about the
! device itself and the character set.  The file dev202/DESC
  is a good example; follow the format closely.
  
  In addition, each font needs a description of its

--- 18,24 -----
  	aps	Autologic APS-5
  
  The file "DESC" contains information about the
! device itself and the character set.  The file devaps/DESC
  is a good example; follow the format closely.
  
  In addition, each font needs a description of its
***************
*** 25,31
  
  In addition, each font needs a description of its
  characters, width and device-driving codes;
! see dev202/R and S for typical examples.
  
  The program "makedev" will convert these text
  descriptions into a binary form that the a.out can

--- 23,29 -----
  
  In addition, each font needs a description of its
  characters, width and device-driving codes;
! see devaps/R and S for typical examples.
  
  The program "makedev" will convert these text
  descriptions into a binary form that the troff can
***************
*** 28,34
  see dev202/R and S for typical examples.
  
  The program "makedev" will convert these text
! descriptions into a binary form that the a.out can
  slurp up in a single gulp during initialization;
  these wind up in dev202/DESC.out (which includes
  default font info) and XX.out for info about font XX.

--- 26,32 -----
  see devaps/R and S for typical examples.
  
  The program "makedev" will convert these text
! descriptions into a binary form that the troff can
  slurp up in a single gulp during initialization;
  these wind up in devaps/DESC.out (which includes
  default font info) and XX.out for info about font XX.
***************
*** 30,36
  The program "makedev" will convert these text
  descriptions into a binary form that the a.out can
  slurp up in a single gulp during initialization;
! these wind up in dev202/DESC.out (which includes
  default font info) and XX.out for info about font XX.
  
  The second half of the job is to write a post-processor

--- 28,34 -----
  The program "makedev" will convert these text
  descriptions into a binary form that the troff can
  slurp up in a single gulp during initialization;
! these wind up in devaps/DESC.out (which includes
  default font info) and XX.out for info about font XX.
  
  The second half of the job is to write a post-processor
***************
*** 34,40
  default font info) and XX.out for info about font XX.
  
  The second half of the job is to write a post-processor
! that converts the more or less machine-independent a.out
  output into specific codes for your favorite typesetter.
  d202.c is the driver for the 202;
  it will serve as a useful prototype.  In particular,

--- 32,38 -----
  default font info) and XX.out for info about font XX.
  
  The second half of the job is to write a post-processor
! that converts the more or less machine-independent troff
  output into specific codes for your favorite typesetter.
  daps.c is the driver for the APS-5;
  it will serve as a useful prototype.  In particular,
***************
*** 36,42
  The second half of the job is to write a post-processor
  that converts the more or less machine-independent a.out
  output into specific codes for your favorite typesetter.
! d202.c is the driver for the 202;
  it will serve as a useful prototype.  In particular,
  it contains a precise description of the output language.
  Other postprocessors are

--- 34,40 -----
  The second half of the job is to write a post-processor
  that converts the more or less machine-independent troff
  output into specific codes for your favorite typesetter.
! daps.c is the driver for the APS-5;
  it will serve as a useful prototype.  In particular,
  it contains a precise description of the output language.
  Other postprocessors are
***************
*** 40,47
  it will serve as a useful prototype.  In particular,
  it contains a precise description of the output language.
  Other postprocessors are
- 	daps	aps5
- 	dcat	graphic systems CAT (not really up to date)
  	tc	tektronix 4014
  	hc	hp2621 (mainly for crude graphics)
  	ta	prints ascii on ordinary terminals (crudely)

--- 38,43 -----
  it will serve as a useful prototype.  In particular,
  it contains a precise description of the output language.
  Other postprocessors are
  	tc	tektronix 4014
  	hc	hp2621 (mainly for crude graphics)
  	ta	prints ascii on ordinary terminals (crudely)
***************
*** 45,52
  	tc	tektronix 4014
  	hc	hp2621 (mainly for crude graphics)
  	ta	prints ascii on ordinary terminals (crudely)
- 	dcan	driver for Imagen/Canon laser printer
- 	d8400	untested driver for compugraphics 8400
  
  The 202 driver writes onto /dev/202 in the same way that
  old troff writes on /dev/cat; to get its output on the std output,

--- 41,46 -----
  	tc	tektronix 4014
  	hc	hp2621 (mainly for crude graphics)
  	ta	prints ascii on ordinary terminals (crudely)
  
  The aps driver writes onto /dev/aps in the same way that
  old troff writes on /dev/cat; to get its output on the std output,
***************
*** 48,54
  	dcan	driver for Imagen/Canon laser printer
  	d8400	untested driver for compugraphics 8400
  
! The 202 driver writes onto /dev/202 in the same way that
  old troff writes on /dev/cat; to get its output on the std output,
  use, e.g., d202 -t ... >file.
  

--- 42,48 -----
  	hc	hp2621 (mainly for crude graphics)
  	ta	prints ascii on ordinary terminals (crudely)
  
! The aps driver writes onto /dev/aps in the same way that
  old troff writes on /dev/cat; to get its output on the std output,
  use, e.g., daps -t ... >file.
  
***************
*** 50,56
  
  The 202 driver writes onto /dev/202 in the same way that
  old troff writes on /dev/cat; to get its output on the std output,
! use, e.g., d202 -t ... >file.
  
  One can always simply run
  	a.out

--- 44,50 -----
  
  The aps driver writes onto /dev/aps in the same way that
  old troff writes on /dev/cat; to get its output on the std output,
! use, e.g., daps -t ... >file.
  
  One can always simply run
  	troff
***************
*** 53,59
  use, e.g., d202 -t ... >file.
  
  One can always simply run
! 	a.out
  and look at the output; it is guaranteed to be ascii text
  and thus safe to edit, grep, etc.
  (Since it is ascii, it is also guaranteed to be quite voluminous.)

--- 47,53 -----
  use, e.g., daps -t ... >file.
  
  One can always simply run
! 	troff
  and look at the output; it is guaranteed to be ascii text
  and thus safe to edit, grep, etc.
  (Since it is ascii, it is also guaranteed to be quite voluminous.)
***************
*** 57,86
  and look at the output; it is guaranteed to be ascii text
  and thus safe to edit, grep, etc.
  (Since it is ascii, it is also guaranteed to be quite voluminous.)
! On our system, /usr/bin/troff is actually a shell program
! that detects -Txxx arguments;  the current default is 202.
! 
! Putting output codes into the font description files
! seems like the right thing to do but I'm not happy yet.
! Accordingly, the formats of any or all of the files
! described here are subject to drastic change; hang loose.
! 
! To clear up one potential misapprehension, the code in this
! directory has not been retrofitted to make an nroff. 
! That would require major surgery, primarily on n6.c and n10.c.
! 
! As it says in the Unix warranty:
! 	"There is no warranty of merchantability nor any warranty
! 	of fitness for a particular purpose nor any other warranty,
! 	either express or implied, as to the accuracy of the
! 	enclosed materials or as to their suitability for any
! 	particular purpose.  Accordingly, Bell Telephone
! 	Laboratories assumes no responsibility for their use by the
! 	recipient.   Further, Bell Laboratories assumes no obligation
! 	to furnish any assistance of any kind whatsoever, or to
! 	furnish any additional information or documentation."
! 
! Nevertheless, I will try to answer questions in cases of
! dire necessity.  Suggestions and other comments would be appreciated.
! 
! Brian W. Kernighan

--- 51,54 -----
  and look at the output; it is guaranteed to be ascii text
  and thus safe to edit, grep, etc.
  (Since it is ascii, it is also guaranteed to be quite voluminous.)
! SCCS @(#)README	1.3
diff -rbc titroff/d.h /distribution/dwb/text/troff.d/d.h
*** titroff/d.h	Sun Feb 21 15:07:44 1982
--- /distribution/dwb/text/troff.d/d.h	Fri Sep  9 18:44:31 1983
***************
*** 1,2
  struct d {filep op; int dnl,dimac,ditrap,ditf,alss,blss,nls,mkline,
  		maxl,hnl,curd;} d[NDI], *dip;

--- 1,3 -----
+ /*      @(#)d.h	1.1     */
  struct d {filep op; int dnl,dimac,ditrap,ditf,alss,blss,nls,mkline,
  		maxl,hnl,curd;} d[NDI], *dip;
diff -rbc titroff/dev.h /distribution/dwb/text/troff.d/dev.h
*** titroff/dev.h	Mon Sep 15 22:29:14 1986
--- /distribution/dwb/text/troff.d/dev.h	Fri Sep  9 18:44:35 1983
***************
*** 1,3
  /*
  	dev.h: characteristics of a typesetter
  */

--- 1,4 -----
+ /*      @(#)dev.h	1.1     */
  /*
  	dev.h: characteristics of a typesetter
  */
***************
*** 18,26
  	short	lchname;	/* length of chname table */
  	short	spare1;		/* in case of expansion */
  	short	spare2;
- #ifdef DESCHASNAME
- 	char dname[10];		/* name of troff device (eg. APS, cat) */
- #endif DESCHASNAME
  };
  
  struct font {		/* characteristics of a font */

--- 19,24 -----
  	short	lchname;	/* length of chname table */
  	short	spare1;		/* in case of expansion */
  	short	spare2;
  };
  
  struct font {		/* characteristics of a font */
diff -rbc titroff/draw.c /distribution/dwb/text/troff.d/draw.c
*** titroff/draw.c	Thu Mar 15 14:35:46 1984
--- /distribution/dwb/text/troff.d/draw.c	Fri Sep  9 18:44:42 1983
***************
*** 1,3
  #include	<stdio.h>
  #include	<math.h>
  #define	PI	3.141592654

--- 1,4 -----
+ /*      @(#)draw.c	1.1     */
  #include	<stdio.h>
  #include	<math.h>
  #define	PI	3.141592654
diff -rbc titroff/ext.h /distribution/dwb/text/troff.d/ext.h
*** titroff/ext.h	Tue Nov 11 15:17:15 1986
--- /distribution/dwb/text/troff.d/ext.h	Fri Sep  9 18:44:47 1983
***************
*** 1,3
  extern	char	**argp;
  extern	char	*chname;
  extern	char	*eibuf;

--- 1,4 -----
+ /*      @(#)ext.h	1.1     */
  extern	char	**argp;
  extern	char	*chname;
  extern	char	*eibuf;
***************
*** 10,15
  extern	char	*unlkp;
  extern	char	*xbufp;
  extern	char	*xeibuf;
  extern	char	codetab[];
  extern	char	devname[];
  extern	char	fontfile[];

--- 11,17 -----
  extern	char	*unlkp;
  extern	char	*xbufp;
  extern	char	*xeibuf;
+ extern	char	cfname[NSO][NS];
  extern	char	codetab[];
  extern	char	devname[];
  extern	char	fontfile[];
***************
*** 230,245
  extern	tchar	oline[];
  extern	tchar	rchar;
  extern	tchar	word[];
- #ifdef LOCALWARN
- #ifdef WARNLEVELREG
- /* warning level is taken from v.h instead -- v.wl --- req */
- #else !WARNLEVELREG
- extern	int	warninglevel;
- #endif WARNLEVELREG
- #endif LOCALWARN
- #ifdef REPORTERRS
- extern int	reporterrs;	/* < 0 means no warnings given */
- #endif REPORTERRS
- #ifdef TCHARTOS
- extern char *tchartos();	/* gives a string representation of a tchar */
- #endif TCHARTOS

--- 232,234 -----
  extern	tchar	oline[];
  extern	tchar	rchar;
  extern	tchar	word[];
Only in titroff: local.c
Only in titroff: local.h
diff -rbc titroff/makedev.c /distribution/dwb/text/troff.d/makedev.c
*** titroff/makedev.c	Mon Nov 10 21:09:29 1986
--- /distribution/dwb/text/troff.d/makedev.c	Fri Sep  9 18:45:10 1983
***************
*** 1,3
  /*
    makedev:
  	read text info about a particular device

--- 1,4 -----
+ /*      @(#)makedev.c	1.2     */
  /*
    makedev:
  	read text info about a particular device
***************
*** 17,25
  		creates files F.out.
  
  	DESC.out contains:
- #ifdef DESCHASNAME
- 	dev structure with fundamental sizes & typesetter name
- #else !DESCHASNAME
  	dev structure with fundamental sizes
  #endif DESCHASNAME
  	list of sizes (nsizes+1) terminated by 0, as short's

--- 18,23 -----
  		creates files F.out.
  
  	DESC.out contains:
  	dev structure with fundamental sizes
  	list of sizes (nsizes+1) terminated by 0, as short's
  	indices of char names (nchtab * sizeof(short))
***************
*** 21,27
  	dev structure with fundamental sizes & typesetter name
  #else !DESCHASNAME
  	dev structure with fundamental sizes
- #endif DESCHASNAME
  	list of sizes (nsizes+1) terminated by 0, as short's
  	indices of char names (nchtab * sizeof(short))
  	char names as hy\0em\0... (lchname)

--- 19,24 -----
  
  	DESC.out contains:
  	dev structure with fundamental sizes
  	list of sizes (nsizes+1) terminated by 0, as short's
  	indices of char names (nchtab * sizeof(short))
  	char names as hy\0em\0... (lchname)
***************
*** 66,79
  char	kern[FSIZE];	/* ascender+descender info */
  char	code[FSIZE];	/* actual device codes for a physical font */
  
! #ifndef NFONT
! #ifdef MOREPREFONTS
! #define	NFONT	40	/* max number of default fonts */
! /* would like to get this from tdef.h, but then have problems with stdio.. */
! #else !MOREPREFONTS
! #define	NFONT	10	/* max number of default fonts */
! #endif MOREPREFONTS
! #endif !NFONT
  char	fname[NFONT][10];	/* temp space to hold default font names */
  
  int	fflag	= 0;	/* on if font table to be written */

--- 63,69 -----
  char	kern[FSIZE];	/* ascender+descender info */
  char	code[FSIZE];	/* actual device codes for a physical font */
  
! #define	NFONT	60	/* max number of default fonts */
  char	fname[NFONT][10];	/* temp space to hold default font names */
  
  int	fflag	= 0;	/* on if font table to be written */
***************
*** 86,93
  	FILE *fin;
  	char cmd[100], *p;
  	int i, totfont, v;
- #ifdef DESCHASNAME
- 	char devname[10];
  
  	dev.dname[0] = dev.dname[1] = '\0';	/* paranoia */
  #endif DESCHASNAME

--- 76,81 -----
  	FILE *fin;
  	char cmd[100], *p;
  	int i, totfont, v;
  
  	if ((fin = fopen("DESC", "r")) == NULL) {
  		fprintf(stderr, "makedev: can't open %s\n", argv[1]);
***************
*** 89,97
  #ifdef DESCHASNAME
  	char devname[10];
  
- 	dev.dname[0] = dev.dname[1] = '\0';	/* paranoia */
- #endif DESCHASNAME
- 
  	if ((fin = fopen("DESC", "r")) == NULL) {
  		fprintf(stderr, "makedev: can't open %s\n", argv[1]);
  		exit(1);

--- 77,82 -----
  	char cmd[100], *p;
  	int i, totfont, v;
  
  	if ((fin = fopen("DESC", "r")) == NULL) {
  		fprintf(stderr, "makedev: can't open %s\n", argv[1]);
  		exit(1);
***************
*** 98,111
  	}
  	while (fscanf(fin, "%s", cmd) != EOF) {
  		if (cmd[0] == '#')	/* comment */
- #ifdef DESCHASNAME
- 		{
- 			if (strcmp(cmd, "##name") == 0) {
- 				fscanf(fin, "%10s", dev.dname);
- 				dev.dname[9] = '\0';
- 				fprintf(stderr, "Makedev: DESC for %s\n",
- 								dev.dname);
- 			} else {
  				skipline(fin);
  			}
  		}

--- 83,88 -----
  	}
  	while (fscanf(fin, "%s", cmd) != EOF) {
  		if (cmd[0] == '#')	/* comment */
  			skipline(fin);
  		else if (strcmp(cmd, "res") == 0) {
  			fscanf(fin, "%hd", &dev.res);
***************
*** 107,117
  								dev.dname);
  			} else {
  				skipline(fin);
- 			}
- 		}
- #else !DESCHASNAME
- 			skipline(fin);
- #endif DESCHASNAME
  		else if (strcmp(cmd, "res") == 0) {
  			fscanf(fin, "%hd", &dev.res);
  		} else if (strcmp(cmd, "hor") == 0) {

--- 84,89 -----
  	while (fscanf(fin, "%s", cmd) != EOF) {
  		if (cmd[0] == '#')	/* comment */
  			skipline(fin);
  		else if (strcmp(cmd, "res") == 0) {
  			fscanf(fin, "%hd", &dev.res);
  		} else if (strcmp(cmd, "hor") == 0) {
***************
*** 153,164
  			fprintf(stderr, "makedev: unknown command %s\n", cmd);
  	}
  	if (argc > 0 && strcmp(argv[1], "DESC") == 0) {
- #ifdef DESCHASNAME
- 		if (dev.dname[0] == '\0') {
- 			fprintf(stderr, "makedev: no \"##name xxx\" entry in DESC\n");
- 			exit(1);
- 		}
- #endif DESCHASNAME
  		fdout = creat(fout, 0666);
  		if (fdout < 0) {
  			fprintf(stderr, "makedev: can't open %s\n", fout);

--- 125,130 -----
  			fprintf(stderr, "makedev: unknown command %s\n", cmd);
  	}
  	if (argc > 0 && strcmp(argv[1], "DESC") == 0) {
  		fdout = creat(fout, 0666);
  		if (fdout < 0) {
  			fprintf(stderr, "makedev: can't open %s\n", fout);
***************
*** 249,260
  				/* so leave previous values intact
  				*/
  				if (strlen(ch) == 1)	/* it's ascii */
- 				{
- #ifdef CHECKDESCFILES
- 					if (fitab[i]) {
- 						fprintf(stderr, "makedev: warning: duplicate entries for \"%s\"\n", ch);
- 					}
- #endif CHECKDESCFILES
  					fitab[ch[0] - 32] = nw;	/* fitab origin omits non-graphics */
  				}
  				else {		/* it has a funny name */

--- 215,220 -----
  				/* so leave previous values intact
  				*/
  				if (strlen(ch) == 1)	/* it's ascii */
  					fitab[ch[0] - 32] = nw;	/* fitab origin omits non-graphics */
  				else {		/* it has a funny name */
  					for (i = 0; i < dev.nchtab; i++)
***************
*** 256,262
  					}
  #endif CHECKDESCFILES
  					fitab[ch[0] - 32] = nw;	/* fitab origin omits non-graphics */
- 				}
  				else {		/* it has a funny name */
  					for (i = 0; i < dev.nchtab; i++)
  						if (strcmp(&chname[chtab[i]], ch) == 0) {

--- 216,221 -----
  				*/
  				if (strlen(ch) == 1)	/* it's ascii */
  					fitab[ch[0] - 32] = nw;	/* fitab origin omits non-graphics */
  				else {		/* it has a funny name */
  					for (i = 0; i < dev.nchtab; i++)
  						if (strcmp(&chname[chtab[i]], ch) == 0) {
***************
*** 260,270
  				else {		/* it has a funny name */
  					for (i = 0; i < dev.nchtab; i++)
  						if (strcmp(&chname[chtab[i]], ch) == 0) {
- #ifdef CHECKDESCFILES
- 							if (fitab[i]) {
- 								fprintf(stderr, "makedev: warning: duplicate entries for \"%s\"\n", ch);
- 							}
- #endif CHECKDESCFILES
  							fitab[i + 128-32] = nw;	/* starts after the ascii */
  							break;
  						}

--- 219,224 -----
  				else {		/* it has a funny name */
  					for (i = 0; i < dev.nchtab; i++)
  						if (strcmp(&chname[chtab[i]], ch) == 0) {
  							fitab[i + 128-32] = nw;	/* starts after the ascii */
  							break;
  						}
Only in titroff: makefile
diff -rbc titroff/n1.c /distribution/dwb/text/troff.d/n1.c
*** titroff/n1.c	Sat Nov 15 19:08:13 1986
--- /distribution/dwb/text/troff.d/n1.c	Tue Oct 25 17:24:09 1983
***************
*** 1,3
  #include <ctype.h>
  #include <sys/types.h>
  #include <sys/stat.h>

--- 1,5 -----
+ char xxxn1v[] = "@(#)n1.c	1.5";
+ 
  #include <ctype.h>
  #include <sys/types.h>
  #include <sys/stat.h>
***************
*** 2,10
  #include <sys/types.h>
  #include <sys/stat.h>
  #include "tdef.h"
- #ifdef BSD42
- #include <sys/time.h>
- #endif BSD42
  extern
  #include "d.h"
  extern

--- 4,9 -----
  #include <sys/types.h>
  #include <sys/stat.h>
  #include "tdef.h"
  extern
  #include "d.h"
  extern
***************
*** 28,39
  
  char	*sprintf();
  tchar	inchar[LNSIZE], *pinchar = inchar;	/* XXX */
- #ifdef COMMENT
- /* ioff, ipl[] and offl[] are also used in local.c, where they're decalred
-  * as extern.
-  * - req
-  */
- #endif COMMENT
  filep ipl[NSO];
  long	offl[NSO];
  long	ioff;

--- 27,32 -----
  
  char	*sprintf();
  tchar	inchar[LNSIZE], *pinchar = inchar;	/* XXX */
  filep ipl[NSO];
  long	offl[NSO];
  long	ioff;
***************
*** 38,50
  long	offl[NSO];
  long	ioff;
  char	*ttyp;
! #ifdef USEFONTPATH
! extern char *fontpath;	/* from t6.c */
! #endif USEFONTPATH
! 
! #ifdef COMMENT
! /* control table... rq is request name */
! #endif COMMENT
  extern struct contab {
  	int	rq;
  	union {

--- 31,38 -----
  long	offl[NSO];
  long	ioff;
  char	*ttyp;
! char	cfname[NSO][NS] = "<standard input>";	/*file name stack*/
! int	cfline[NSO];		/*input line count stack*/
  extern struct contab {
  	int	rq;
  	union {
***************
*** 52,59
  		unsigned	mx;
  	} x;
  } contab[NM];
- #ifdef REPORTERRS
- extern char *progname;
  
  #endif REPORTERRS
  

--- 40,45 -----
  		unsigned	mx;
  	} x;
  } contab[NM];
  
  main(argc, argv)
  int	argc;
***************
*** 55,62
  #ifdef REPORTERRS
  extern char *progname;
  
- #endif REPORTERRS
- 
  main(argc, argv)
  int	argc;
  char	**argv;

--- 41,46 -----
  	} x;
  } contab[NM];
  
  main(argc, argv)
  int	argc;
  char	**argv;
***************
*** 78,91
  	signal(SIGTERM, kcatch);
  	oargc = argc;
  	oargv = argv;
- #ifdef REPORTERRS
- 	/* save progname for local.c:errmsg() error reporting */
- 	for (p = argv[0]; *p; p++)
- 		;
- 	while (p > *argv && *p != '/')
- 		p--;
- 	progname = (p && *p == '/') ? ++p : argv[0];
- #endif REPORTERRS
  	init0();
  options:
  #ifdef ENVIRONMENT

--- 62,67 -----
  	signal(SIGTERM, kcatch);
  	oargc = argc;
  	oargv = argv;
  	init0();
  options:
  	while (--argc > 0 && (++argv)[0][0] == '-')
***************
*** 88,107
  #endif REPORTERRS
  	init0();
  options:
- #ifdef ENVIRONMENT
- 	/* no point making nroff look at the ditroff DESC files... */
- #ifndef NROFF
-       {	extern char *getenv();
- 	char *p = getenv("TYPESETTER");
- 
- 	if (p != (char *) 0) {
- 		strcpy(devname, p);
- 		dotT++;
- 	}
-       }
- #endif NROFF
- #endif ENVIRONMENT
- 
  	while (--argc > 0 && (++argv)[0][0] == '-')
  		switch (argv[0][1]) {
  

--- 64,69 -----
  	oargv = argv;
  	init0();
  options:
  	while (--argc > 0 && (++argv)[0][0] == '-')
  		switch (argv[0][1]) {
  
***************
*** 105,125
  	while (--argc > 0 && (++argv)[0][0] == '-')
  		switch (argv[0][1]) {
  
- #ifdef LOCALWARN
- #ifndef WARN_ALL
- #include "local.h"
- #endif WARN_ALL
- 		case 'W':
- 			/* print out warnings -- see local.h, local.c
- 			 * --- REQ 16/9/86
- 			 */
- #ifdef WARNLEVELREG
- 			v.wl = WARN_ALL;
- #else !WARNLEVELREG
- 			warninglevel = WARN_ALL;
- #endif WARNLEVELREG
- 			continue;
- #endif LOCALWARN
  		case 'F':	/* switch font tables from default */
  			if (argv[0][2] != '\0') {
  				strcpy(termtab, &argv[0][2]);

--- 67,72 -----
  	while (--argc > 0 && (++argv)[0][0] == '-')
  		switch (argv[0][1]) {
  
  		case 'F':	/* switch font tables from default */
  			if (argv[0][2] != '\0') {
  				strcpy(termtab, &argv[0][2]);
***************
*** 124,132
  			if (argv[0][2] != '\0') {
  				strcpy(termtab, &argv[0][2]);
  				strcpy(fontfile, &argv[0][2]);
- #ifdef USEFONTPATH
- 				fontpath = &argv[0][2];
- #endif USEFONTPATH
  			} else {
  				argv++; argc--;
  #ifdef NOOPTARGFIX

--- 71,76 -----
  			if (argv[0][2] != '\0') {
  				strcpy(termtab, &argv[0][2]);
  				strcpy(fontfile, &argv[0][2]);
  			} else {
  				argv++; argc--;
  				strcpy(termtab, argv[0]);
***************
*** 129,151
  #endif USEFONTPATH
  			} else {
  				argv++; argc--;
- #ifdef NOOPTARGFIX
- #ifdef REPORTERRS
- 				if (argc <= 0) {
- 					errmsg(done, 02,
- 					"-F option must be followed by a %s",
- #ifdef FONTFAMILIES
- 							"font path"
- #else !FONTFAMILIES
- 							"directory name"
- #endif FONTFAMILIES
- 									);
- #else !REPORTERRS
- 					fprintf(stderr, "troff: -F needs an argument");
- 					edone(02);
- #endif REPORTERRS
- #endif NOOPTARGFIX
- 				}
  				strcpy(termtab, argv[0]);
  				strcpy(fontfile, argv[0]);
  #ifdef USEFONTPATH

--- 73,78 -----
  				strcpy(fontfile, &argv[0][2]);
  			} else {
  				argv++; argc--;
  				strcpy(termtab, argv[0]);
  				strcpy(fontfile, argv[0]);
  			}
***************
*** 148,156
  				}
  				strcpy(termtab, argv[0]);
  				strcpy(fontfile, argv[0]);
- #ifdef USEFONTPATH
- 				fontpath = argv[0];
- #endif USEFONTPATH
  			}
  			continue;
  #ifdef COMMENT

--- 75,80 -----
  				argv++; argc--;
  				strcpy(termtab, argv[0]);
  				strcpy(fontfile, argv[0]);
  			}
  			continue;
  		case 0:
***************
*** 153,161
  #endif USEFONTPATH
  			}
  			continue;
- #ifdef COMMENT
- 		/* - : read stdin */
- #endif COMMENT
  		case 0:
  			goto start;
  #ifdef COMMENT

--- 77,82 -----
  				strcpy(fontfile, argv[0]);
  			}
  			continue;
  		case 0:
  			goto start;
  		case 'i':
***************
*** 158,166
  #endif COMMENT
  		case 0:
  			goto start;
- #ifdef COMMENT
- 		/* -i : read stdin after all i/p files have been exhausted */
- #endif COMMENT
  		case 'i':
  			stdi++;
  			continue;

--- 79,84 -----
  			continue;
  		case 0:
  			goto start;
  		case 'i':
  			stdi++;
  			continue;
***************
*** 164,172
  		case 'i':
  			stdi++;
  			continue;
- #ifdef COMMENT
- 		/* -q : simultaneous i/o mode of .rd */
- #endif COMMENT
  		case 'q':
  			quiet++;
  			if (gtty(0, &ttys) >= 0)

--- 82,87 -----
  		case 'i':
  			stdi++;
  			continue;
  		case 'q':
  			quiet++;
  			if (gtty(0, &ttys) >= 0)
***************
*** 172,180
  			if (gtty(0, &ttys) >= 0)
  				ttysave = ttys.sg_flags;
  			continue;
- #ifdef COMMENT
- 		/* -nM : 1st page to be numbered M */
- #endif COMMENT
  		case 'n':
  			npn = ctoi(&argv[0][2]);
  			continue;

--- 87,92 -----
  			if (gtty(0, &ttys) >= 0)
  				ttysave = ttys.sg_flags;
  			continue;
  		case 'n':
  			npn = ctoi(&argv[0][2]);
  			continue;
***************
*** 182,192
  			bdtab[3] = ctoi(&argv[0][2]);
  			if (bdtab[3] < 0 || bdtab[3] > 50)
  				bdtab[3] = 0;
- #ifdef REPORTERRS
- 			if (bdtab[3] == 0) {
- 				errmsg(EWARN, "-u option must be followed by a number in the range 0 - 50; using 0");
- 			}
- #endif REPORTERRS
  			continue;
  #ifdef COMMENT
  		/* -s -- stop every n pages */

--- 94,99 -----
  			bdtab[3] = ctoi(&argv[0][2]);
  			if (bdtab[3] < 0 || bdtab[3] > 50)
  				bdtab[3] = 0;
  			continue;
  		case 's':
  			if (!(stop = ctoi(&argv[0][2])))
***************
*** 188,196
  			}
  #endif REPORTERRS
  			continue;
- #ifdef COMMENT
- 		/* -s -- stop every n pages */
- #endif COMMENT
  		case 's':
  			if (!(stop = ctoi(&argv[0][2])))
  				stop++;

--- 95,100 -----
  			if (bdtab[3] < 0 || bdtab[3] > 50)
  				bdtab[3] = 0;
  			continue;
  		case 's':
  			if (!(stop = ctoi(&argv[0][2])))
  				stop++;
***************
*** 195,203
  			if (!(stop = ctoi(&argv[0][2])))
  				stop++;
  			continue;
- #ifdef COMMENT
- 		/* -rA=n --- set register A to n */
- #endif COMMENT
  		case 'r':
  			eibuf = sprintf(ibuf+strlen(ibuf), ".nr %c %s\n",
  				argv[0][2], &argv[0][3]);

--- 99,104 -----
  			if (!(stop = ctoi(&argv[0][2])))
  				stop++;
  			continue;
  		case 'r':
  			eibuf = sprintf(ibuf+strlen(ibuf), ".nr %c %s\n",
  				argv[0][2], &argv[0][3]);
***************
*** 202,210
  			eibuf = sprintf(ibuf+strlen(ibuf), ".nr %c %s\n",
  				argv[0][2], &argv[0][3]);
  			continue;
! #ifdef COMMENT
! 		/* -mxxx -- read macro package /usr/lib/tmac/tmac.xxx */ 
! #endif COMMENT
  		case 'm':
  			p = &nextf[nfi];
  			q = &argv[0][2];

--- 103,109 -----
  			eibuf = sprintf(ibuf+strlen(ibuf), ".nr %c %s\n",
  				argv[0][2], &argv[0][3]);
  			continue;
! 		case 'c':
  		case 'm':
  			p = &nextf[nfi];
  			q = &argv[0][2];
***************
*** 212,220
  				;
  			mflg++;
  			continue;
- #ifdef COMMENT
- 		/* -opagelist */
- #endif COMMENT
  		case 'o':
  			getpn(&argv[0][2]);
  			continue;

--- 111,116 -----
  				;
  			mflg++;
  			continue;
  		case 'o':
  			getpn(&argv[0][2]);
  			continue;
***************
*** 234,244
  			continue;
  #endif
  #ifndef NROFF
- #ifdef COMMENT
- 		/* -Txxx -- read the DESC.out for typesetter xxx from
- 		 * /usr/lib/troff/descs/devxxx
- 		 */
- #endif COMMENT
  		case 'T':
  			strcpy(devname, &argv[0][2]);
  			dotT++;

--- 130,135 -----
  			continue;
  #endif
  #ifndef NROFF
  		case 'T':
  			strncpy(devname, &argv[0][2], 11);
  			devname[11] = 0;	/*directory name is char[14]*/
***************
*** 240,246
  		 */
  #endif COMMENT
  		case 'T':
! 			strcpy(devname, &argv[0][2]);
  			dotT++;
  			continue;
  #ifdef COMMENT

--- 131,138 -----
  #endif
  #ifndef NROFF
  		case 'T':
! 			strncpy(devname, &argv[0][2], 11);
! 			devname[11] = 0;	/*directory name is char[14]*/
  			dotT++;
  			continue;
  		case 'z':
***************
*** 243,251
  			strcpy(devname, &argv[0][2]);
  			dotT++;
  			continue;
- #ifdef COMMENT
- 		/* -z --- efficiently suppress output */
- #endif COMMENT
  		case 'z':
  			no_out++;
  #ifdef COMMENT

--- 135,140 -----
  			devname[11] = 0;	/*directory name is char[14]*/
  			dotT++;
  			continue;
  		case 'z':
  			no_out++;
  		case 'a':
***************
*** 248,258
  #endif COMMENT
  		case 'z':
  			no_out++;
- #ifdef COMMENT
- 		/* -a -- provide ascii approximation to o/p.  Doesn't seem
- 		 * to work too well
- 		 */
- #endif COMMENT
  		case 'a':
  			ascii = 1;
  			nofeed++;

--- 137,142 -----
  			continue;
  		case 'z':
  			no_out++;
  		case 'a':
  			ascii = 1;
  			nofeed++;
***************
*** 258,266
  			nofeed++;
  		case 't':
  			ptid = 1;
- #ifdef COMMENT
- 		/* -f --- suppress final page-throw? */
- #endif COMMENT
  			continue;
  		case 'f':
  			nofeed++;

--- 142,147 -----
  			nofeed++;
  		case 't':
  			ptid = 1;
  			continue;
  		case 'f':
  			nofeed++;
***************
*** 270,284
  			fprintf(stderr, "troff: unknown option %s\n", argv[0]);
  			done(02);
  		}
- #ifndef NROFF
- #ifdef USEFONTPATH
- 	/*
- 	if (fontpath && devname && *devname) {
- 		sprintf(fontpath, FONTPATH, devname);
- 	}
- 	*/
- #endif USEFONTPATH
- #endif NROFF
  
  start:
  	init1(oargv[0][0]);

--- 151,156 -----
  			fprintf(stderr, "troff: unknown option %s\n", argv[0]);
  			done(02);
  		}
  
  start:
  	init1(oargv[0][0]);
***************
*** 298,306
  	if (pendt)
  		goto lt;
  	if ((j = cbits(i)) == XPAR) {
- #ifdef COMMENT
- 		/* transparent mode line... */
- #endif COMMENT
  		copyf++;
  		tflg++;
  		while (cbits(i) != '\n')

--- 170,175 -----
  	if (pendt)
  		goto lt;
  	if ((j = cbits(i)) == XPAR) {
  		copyf++;
  		tflg++;
  		while (cbits(i) != '\n')
***************
*** 310,318
  		goto loop;
  	}
  	if (j == cc || j == c2) {
- #ifdef COMMENT
- 		/* macro request... */
- #endif COMMENT
  		if (j == c2)
  			nb++;
  #ifdef COMMENT

--- 179,184 -----
  		goto loop;
  	}
  	if (j == cc || j == c2) {
  		if (j == c2)
  			nb++;
  		copyf++;
***************
*** 315,323
  #endif COMMENT
  		if (j == c2)
  			nb++;
- #ifdef COMMENT
- 			/* suppress line-break */
- #endif COMMENT
  		copyf++;
  #ifdef COMMENT
  		/* read macro args in copy mode */

--- 181,186 -----
  	if (j == cc || j == c2) {
  		if (j == c2)
  			nb++;
  		copyf++;
  		while ((j = cbits(i = getch())) == ' ' || j == '\t')
  			;
***************
*** 319,329
  			/* suppress line-break */
  #endif COMMENT
  		copyf++;
- #ifdef COMMENT
- 		/* read macro args in copy mode */
- 
- 		/* skip blanks between . and macro-name */
- #endif COMMENT
  		while ((j = cbits(i = getch())) == ' ' || j == '\t')
  			;
  		ch = i;

--- 182,187 -----
  		if (j == c2)
  			nb++;
  		copyf++;
  		while ((j = cbits(i = getch())) == ' ' || j == '\t')
  			;
  		ch = i;
***************
*** 352,363
  }
  
  
- #ifdef COMMENT
- /* init0 is called once, before any args are parsed (except that progname is
-  * defined)
-  * - req
-  */
- #endif COMMENT
  init0()
  {
  	eibuf = ibufp = ibuf;

--- 210,215 -----
  }
  
  
  init0()
  {
  	eibuf = ibufp = ibuf;
***************
*** 363,371
  	eibuf = ibufp = ibuf;
  	ibuf[0] = 0;
  	v.nl = -1;
- #ifdef WARNLEVELREG
- 	v.wl = WARN_ONCE;
- #endif WARNLEVELREG
  }
  
  

--- 215,220 -----
  	eibuf = ibufp = ibuf;
  	ibuf[0] = 0;
  	v.nl = -1;
  }
  
  
***************
*** 369,379
  }
  
  
- #ifdef COMMENT
- /* init1 is called once after the arguments have been parsed and before
-  * main processing - req
-  */
- #endif COMMENT
  init1(a)
  char	a;
  {

--- 218,223 -----
  }
  
  
  init1(a)
  char	a;
  {
***************
*** 382,388
  	register i;
  
  	p = mktemp("/usr/tmp/trtmpXXXXX");
- #ifdef USEDOTFORTMPIFA
  	if (a == 'a')
  		p = &p[9];
  #endif USEDOTFORTMPIFA

--- 226,231 -----
  	register i;
  
  	p = mktemp("/usr/tmp/trtmpXXXXX");
  	if (a == 'a')
  		p = &p[9];
  	if ((close(creat(p, 0600))) < 0) {
***************
*** 385,399
  #ifdef USEDOTFORTMPIFA
  	if (a == 'a')
  		p = &p[9];
- #endif USEDOTFORTMPIFA
- #ifdef COMMENT
- 	/* i.e., if troff's name begins with "a", use the current directory
- 	 * for tmp files.  The 9 refers to the string passed to mktemp.
- 	 * Presumable this is for testing, when titroff is complied as
- 	 * a.out
- 	 * REQ
- 	 */
- #endif COMMENT
  	if ((close(creat(p, 0600))) < 0) {
  #ifdef REPORTERRS
  		extern void exit();	/* ! */

--- 228,233 -----
  	p = mktemp("/usr/tmp/trtmpXXXXX");
  	if (a == 'a')
  		p = &p[9];
  	if ((close(creat(p, 0600))) < 0) {
  		fprintf(stderr, "troff: cannot create temp file.\n");
  		exit(-1);
***************
*** 395,405
  	 */
  #endif COMMENT
  	if ((close(creat(p, 0600))) < 0) {
- #ifdef REPORTERRS
- 		extern void exit();	/* ! */
- 
- 		errmsg(exit, -1, "cannot create temp file \"%s\"", p);
- #else !REPORTERRS
  		fprintf(stderr, "troff: cannot create temp file.\n");
  		exit(-1);
  #endif REPORTERRS

--- 229,234 -----
  	if (a == 'a')
  		p = &p[9];
  	if ((close(creat(p, 0600))) < 0) {
  		fprintf(stderr, "troff: cannot create temp file.\n");
  		exit(-1);
  	}
***************
*** 402,408
  #else !REPORTERRS
  		fprintf(stderr, "troff: cannot create temp file.\n");
  		exit(-1);
- #endif REPORTERRS
  	}
  	ibf = open(p, 2);
  	unlkp = p;

--- 231,236 -----
  	if ((close(creat(p, 0600))) < 0) {
  		fprintf(stderr, "troff: cannot create temp file.\n");
  		exit(-1);
  	}
  	ibf = open(p, 2);
  	unlkp = p;
***************
*** 412,422
  }
  
  
- #ifdef COMMENT
- /* init2 is called once, after init1, and after saving arg[cv] in oarg[cv]
-  * - req
-  */
- #endif COMMENT
  init2()
  {
  	register i, j;

--- 240,245 -----
  }
  
  
  init2()
  {
  	register i, j;
***************
*** 468,477
  	long	tt;
  	register i;
  	static int ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
- #ifdef BSD42
- 	struct timeval t;
- 	struct timezone tz;
- #endif BSD42
  
  #ifdef BSD42
  	gettimeofday(&t, &tz);

--- 291,296 -----
  	long	tt;
  	register i;
  	static int ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  
  	time(&tt);
  	tt -= 3600 * ZONE;	/* 5hrs for EST */
***************
*** 473,483
  	struct timezone tz;
  #endif BSD42
  
- #ifdef BSD42
- 	gettimeofday(&t, &tz);
- 	t.tv_sec -+ 60 * tz.tz_minuteswest;	/* 0 for GMT, 5h for EST */
- 	v.dy = (t.tv_sec/86400L) + 1;		/* day of the year */
- #else !BSD42
  	time(&tt);
  	tt -= 3600 * ZONE;	/* 5hrs for EST */
  	v.dy = (tt / 86400L) + 1;

--- 292,297 -----
  	register i;
  	static int ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  
  	time(&tt);
  	tt -= 3600 * ZONE;	/* 5hrs for EST */
  	v.dy = (tt / 86400L) + 1;
***************
*** 481,487
  	time(&tt);
  	tt -= 3600 * ZONE;	/* 5hrs for EST */
  	v.dy = (tt / 86400L) + 1;
- #endif BSD42
  	v.dw = (v.dy + 3) % 7 + 1;
  	for (v.yr = 70; ; v.yr++) {
  		if ((v.yr) % 4)

--- 295,300 -----
  	time(&tt);
  	tt -= 3600 * ZONE;	/* 5hrs for EST */
  	v.dy = (tt / 86400L) + 1;
  	v.dw = (v.dy + 3) % 7 + 1;
  	for (v.yr = 70; ; v.yr++) {
  		if ((v.yr) % 4)
***************
*** 694,702
  register int	a, b;
  {
  	register int	j;
- #ifdef BUILTINCONTROLFIX
- 	int i = 0;
- #endif BUILTINCONTROLFIX
  
  	if (a == 0 || (j = findmn(a)) == -1)
  #ifdef REPORTERRS

--- 507,512 -----
  register int	a, b;
  {
  	register int	j;
  
  	if (a == 0 || (j = findmn(a)) == -1)
  		return(0);
***************
*** 699,712
  #endif BUILTINCONTROLFIX
  
  	if (a == 0 || (j = findmn(a)) == -1)
- #ifdef REPORTERRS
- 	{
- 		extern char *realname();  /* defined in local.c */
- 
- 		if (a && a != PAIR(RIGHT, 0)) {
- 			errmsg(EWARN, "Call to unknown macro (%s) ignored",
- 								realname(a));
- 		}
  		return(0);
  	}
  #else !REPORTERRS

--- 509,514 -----
  	register int	j;
  
  	if (a == 0 || (j = findmn(a)) == -1)
  		return(0);
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
***************
*** 708,717
  								realname(a));
  		}
  		return(0);
- 	}
- #else !REPORTERRS
- 		return(0);
- #endif REPORTERRS
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
  #ifdef BUILTINCONTROLFIX

--- 510,515 -----
  
  	if (a == 0 || (j = findmn(a)) == -1)
  		return(0);
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
  		if (b)
***************
*** 714,722
  #endif REPORTERRS
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
- #ifdef BUILTINCONTROLFIX
- 		if (b > 0)
- #else !BUILTINCONTROLFIX
  		if (b)
  #endif BUILTINCONTROLFIX
  			collect();

--- 512,517 -----
  		return(0);
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
  		if (b)
  			collect();
  		flushi();
***************
*** 718,724
  		if (b > 0)
  #else !BUILTINCONTROLFIX
  		if (b)
- #endif BUILTINCONTROLFIX
  			collect();
  		flushi();
  		return(pushi((filep)contab[j].x.mx));

--- 513,518 -----
  	if (contab[j].rq & MMASK) {
  		nxf->nargs = 0;
  		if (b)
  			collect();
  		flushi();
  		return(pushi((filep)contab[j].x.mx));
***************
*** 723,740
  		flushi();
  		return(pushi((filep)contab[j].x.mx));
  	} else if (b)
- #ifdef BUILTINCONTROLFIX
- 	{
- 		if (b < 0) {
- 			/* don't want built-in macro to read input */
- 			/* this is from callsp() in n7.c */
- 			if (flss)
- 				i = flss; 
- 			else 
- 				i = lss;
- 			flss = 0;
- 			return((*contab[j].x.f)(i));
- 		} else {
  			return((*contab[j].x.f)(0));
  		}
  	}

--- 517,522 -----
  		flushi();
  		return(pushi((filep)contab[j].x.mx));
  	} else if (b)
  		return((*contab[j].x.f)(0));
  	else
  		return(0);
***************
*** 736,746
  			return((*contab[j].x.f)(i));
  		} else {
  			return((*contab[j].x.f)(0));
- 		}
- 	}
- #else !BUILTINCONTROLFIX
- 		return((*contab[j].x.f)(0));
- #endif BUILTINCONTROLFIX
  	else
  		return(0);
  }

--- 518,523 -----
  		return(pushi((filep)contab[j].x.mx));
  	} else if (b)
  		return((*contab[j].x.f)(0));
  	else
  		return(0);
  }
***************
*** 763,771
  	register int	k;
  	tchar i, j;
  	tchar setht(), setslant();
- #ifdef REPORTERRS
- 	static int leftcount = 0;	/* how many more \{ than \} in input */
- #endif REPORTERRS
  
  	level++;
  g0:

--- 540,545 -----
  	register int	k;
  	tchar i, j;
  	tchar setht(), setslant();
  
  	level++;
  g0:
***************
*** 825,837
  	switch (k) {
  
  	case '\n':	/* concealed newline */
- #ifdef LINENUMFIX
- 		/* current input line in this file */
- 		if (ip == 0) {
- 			/* reading from file rather than macro */
- 			v.cd++;
- 		}
- #endif LINENUMFIX
  		goto g0;
  	case 'n':	/* number register */
  		setn();

--- 599,604 -----
  	switch (k) {
  
  	case '\n':	/* concealed newline */
  		goto g0;
  	case 'n':	/* number register */
  		setn();
***************
*** 844,852
  		goto g0;
  	case '{':	/* LEFT */
  		i = LEFT;
- #ifdef REPORTERRS
- 		leftcount++;
- #endif REPORTERRS
  		goto gx;
  	case '}':	/* RIGHT */
  		i = RIGHT;

--- 611,616 -----
  		goto g0;
  	case '{':	/* LEFT */
  		i = LEFT;
  		goto gx;
  	case '}':	/* RIGHT */
  		i = RIGHT;
***************
*** 850,861
  		goto gx;
  	case '}':	/* RIGHT */
  		i = RIGHT;
- #ifdef REPORTERRS
- 		if (--leftcount < 0) {
- 			errmsg(EWARN, "\\} without a matching \\{");
- 			leftcount = 0;
- 		}
- #endif REPORTERRS
  		goto gx;
  	case '"':	/* comment */
  		while (cbits(i = getch0()) != '\n')

--- 614,619 -----
  		goto gx;
  	case '}':	/* RIGHT */
  		i = RIGHT;
  		goto gx;
  	case '"':	/* comment */
  		while (cbits(i = getch0()) != '\n')
***************
*** 934,947
  		case 'S':	/* slant */
  			i = setslant();
  			break;
- #ifdef ANYBASESTR
- 		case 'R':	/* \R'drawing function'string' --
- 				 * use 'drawing function' as baseline for text
- 				 * - req
- 				 */
- 			i = setbasestr();
- 			break;
- #endif ANYBASESTR
  		case 'f':	/* font indicator */
  			setfont(0);
  			goto g0;

--- 692,697 -----
  		case 'S':	/* slant */
  			i = setslant();
  			break;
  		case 'f':	/* font indicator */
  			setfont(0);
  			goto g0;
***************
*** 978,988
  			if ((k = findr(getsn())) != -1) {
  				vlist[k] = v.hp = sumhp();
  			}
- #ifdef REPORTERRS
- 			else {
- 				errmsg(EWARN, "\\k must be follwed by a valid number register name");
- 			}
- #endif REPORTERRS
  			goto g0;
  		case '0':	/* number space */
  			i = makem(width('0' | chbits));

--- 728,733 -----
  			if ((k = findr(getsn())) != -1) {
  				vlist[k] = v.hp = sumhp();
  			}
  			goto g0;
  		case '0':	/* number space */
  			i = makem(width('0' | chbits));
***************
*** 998,1006
  			break;
  		default:
  			i = j;
- #ifdef REPORTERRS
- 			errmsg(EWARN, "Unknown inline escape \"\\%s\"", tchartos(j));
- #endif REPORTERRS
  		}
  	else {
  		ch0 = j;

--- 743,748 -----
  			break;
  		default:
  			i = j;
  		}
  	else {
  		ch0 = j;
***************
*** 1056,1078
  		return(rchar);
  	}
  
- #ifdef COMMENT
- 	/* this is where input push-back is done for number registers,
- 	 * strings, macros & diversions.
- 	 * For a number register, \n(xx is expanded into cbuf[], and cp is
- 	 * set equal to cbuf.
- 	 *
- 	 * for macro arguments and strings, ap is used (Arg Pointer ?);
- 	 *
- 	 * for macros and diversions, ip is set.
- 	 *
- 	 * For single-char push-back, ch is set (all over the place!) --
- 	 * this is used at the start of getch()
- 	 *
- 	 * -- req
- 	 *
- 	 */
- #endif COMMENT
  again:
  	if (cp) {
  		if ((i = *cp++) == 0) {

--- 798,803 -----
  		return(rchar);
  	}
  
  again:
  	if (cp) {
  		if ((i = *cp++) == 0) {
***************
*** 1158,1163
  n1:
  	if ((p[0] == '-') && (p[1] == 0)) {
  		ifile = 0;
  	} else if ((ifile = open(p, 0)) < 0) {
  		fprintf(stderr, "troff: cannot open %s\n", p);
  		nfo -= mflg;

--- 883,889 -----
  n1:
  	if ((p[0] == '-') && (p[1] == 0)) {
  		ifile = 0;
+ 		strcpy(cfname[ifi],"<standard input>");
  	} else if ((ifile = open(p, 0)) < 0) {
  		fprintf(stderr, "troff: cannot open %s\n", p);
  		nfo -= mflg;
***************
*** 1162,1168
  		fprintf(stderr, "troff: cannot open %s\n", p);
  		nfo -= mflg;
  		done(02);
! 	}
  	nfo++;
  	v.cd = 0;
  	ioff = 0;

--- 888,895 -----
  		fprintf(stderr, "troff: cannot open %s\n", p);
  		nfo -= mflg;
  		done(02);
! 	} else
! 		strcpy(cfname[ifi],p);
  	nfo++;
  	v.cd = 0;
  	ioff = 0;
***************
*** 1166,1191
  	nfo++;
  	v.cd = 0;
  	ioff = 0;
- #ifdef REPORTERRS
- 	{
- 		extern char *ifilename;
- 
- 		/* set the filename so that local.c:errmsg() can use it */
- 
- 		ifilename = p;
- 		if (! strcmp(p, "-")) {
- 			ifilename = "stdin";
- 		}
- 		/* potential bug if the storage for nextf that p points to
- 		 * doesn't persist.  But as far as I can see it does.  Don't
- 		 * really want to invent a fixed-sized buffer.  If I get time,
- 		 * though, there will be a troff string that will contain
- 		 * the filename, and then storage won't be a problem.
- 		 * --- req, 6/10/86
- 		 */
- 		 /* BUG2: no easy way to change progname on a .so */
- 	}
- #endif REPORTERRS
  	return(0);
  n2:
  	if ((nfo -= mflg) && !stdi)

--- 893,898 -----
  	nfo++;
  	v.cd = 0;
  	ioff = 0;
  	return(0);
  n2:
  	if ((nfo -= mflg) && !stdi)
***************
*** 1192,1197
  		done(0);
  	nfo++;
  	v.cd = ifile = stdi = mflg = 0;
  	ioff = 0;
  	return(0);
  }

--- 899,905 -----
  		done(0);
  	nfo++;
  	v.cd = ifile = stdi = mflg = 0;
+ 	strcpy(cfname[ifi],"<standard input>");
  	ioff = 0;
  	return(0);
  }
***************
*** 1204,1209
  	extern char	*ttyname();
  
  	ioff = offl[--ifi];
  	ip = ipl[ifi];
  	if ((ifile = ifl[ifi]) == 0) {
  		p = xbuf;

--- 912,918 -----
  	extern char	*ttyname();
  
  	ioff = offl[--ifi];
+ 	v.cd = cfline[ifi];		/*restore line counter*/
  	ip = ipl[ifi];
  	if ((ifile = ifl[ifi]) == 0) {
  		p = xbuf;
***************
*** 1302,1318
  
  	lgf++;
  	nextf[0] = 0;
- #ifdef FONTFAMILIES
- 	if (skip() || !getname()) {
- #ifdef REPORTERRS
- 		errmsg(EWARN, "Call to .so with no arguments ignored");
- #else !REPORTERRS
- 		fprintf(stderr, "troff: Call to .so with no args ignored");
- #endif REPORTERRS
- 		return 0;
- 	}
- 	dosofile(".so");
- #else !FONTFAMILIES
  	if (skip() || !getname() || ((i = open(nextf, 0)) < 0) || (ifi >= NSO)) {
  #ifdef REPORTERRS
  		errmsg(done, 02, ".so: can't open file %s", nextf);

--- 1011,1016 -----
  
  	lgf++;
  	nextf[0] = 0;
  	if (skip() || !getname() || ((i = open(nextf, 0)) < 0) || (ifi >= NSO)) {
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
***************
*** 1314,1322
  	dosofile(".so");
  #else !FONTFAMILIES
  	if (skip() || !getname() || ((i = open(nextf, 0)) < 0) || (ifi >= NSO)) {
- #ifdef REPORTERRS
- 		errmsg(done, 02, ".so: can't open file %s", nextf);
- #else !REPORTERRS
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
  #endif REPORTERRS

--- 1012,1017 -----
  	lgf++;
  	nextf[0] = 0;
  	if (skip() || !getname() || ((i = open(nextf, 0)) < 0) || (ifi >= NSO)) {
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
  	}
***************
*** 1319,1325
  #else !REPORTERRS
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
- #endif REPORTERRS
  	}
  	flushi();
  	ifl[ifi] = ifile;

--- 1014,1019 -----
  	if (skip() || !getname() || ((i = open(nextf, 0)) < 0) || (ifi >= NSO)) {
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
  	}
  	strcpy(cfname[ifi+1], nextf);
  	cfline[ifi] = v.cd;		/*hold line counter*/
***************
*** 1321,1326
  		done(02);
  #endif REPORTERRS
  	}
  	flushi();
  	ifl[ifi] = ifile;
  	ifile = i;

--- 1015,1023 -----
  		fprintf(stderr, "troff: can't open file %s\n", nextf);
  		done(02);
  	}
+ 	strcpy(cfname[ifi+1], nextf);
+ 	cfline[ifi] = v.cd;		/*hold line counter*/
+ 	v.cd = 0;
  	flushi();
  	ifl[ifi] = ifile;
  	ifile = i;
***************
*** 1338,1344
  		while (p < eibuf)
  			*q++ = *p++;
  	}
- #endif FONTFAMILIES
  }
  
  

--- 1035,1040 -----
  		while (p < eibuf)
  			*q++ = *p++;
  	}
  }
  
  
***************
*** 1393,1401
  	register int n, neg;
  
  	if (*a == 0)
- #ifdef REPORTERRS
- 	{
- 		errmsg(EWARN, "-o: usage is -oLIST; no LIST of pagenumbers found");
  		return;
  	}
  #else !REPORTERRS

--- 1089,1094 -----
  	register int n, neg;
  
  	if (*a == 0)
  		return;
  	neg = 0;
  	for ( ; *a; a++)
***************
*** 1397,1406
  	{
  		errmsg(EWARN, "-o: usage is -oLIST; no LIST of pagenumbers found");
  		return;
- 	}
- #else !REPORTERRS
- 		return;
- #endif REPORTERRS
  	neg = 0;
  	for ( ; *a; a++)
  		switch (*a) {

--- 1090,1095 -----
  
  	if (*a == 0)
  		return;
  	neg = 0;
  	for ( ; *a; a++)
  		switch (*a) {
***************
*** 1422,1430
  			*pnp++ = neg ? -n : n;
  			neg = 0;
  			if (pnp >= &pnlist[NPN-2]) {
- #ifdef REPORTERRS
- 				errmsg(done2, -3, "too many pagenumbers (maximum is %d)", NPN);
- #else !REPORTERRS
  				fprintf(stderr, "troff: too many page numbers\n");
  				done3(-3);
  #endif REPORTERRS

--- 1111,1116 -----
  			*pnp++ = neg ? -n : n;
  			neg = 0;
  			if (pnp >= &pnlist[NPN-2]) {
  				fprintf(stderr, "troff: too many page numbers\n");
  				done3(-3);
  			}
***************
*** 1427,1433
  #else !REPORTERRS
  				fprintf(stderr, "troff: too many page numbers\n");
  				done3(-3);
- #endif REPORTERRS
  			}
  		}
  	if (neg)

--- 1113,1118 -----
  			if (pnp >= &pnlist[NPN-2]) {
  				fprintf(stderr, "troff: too many page numbers\n");
  				done3(-3);
  			}
  		}
  	if (neg)
Only in titroff: n10.c
